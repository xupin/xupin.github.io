<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mark&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/2951352e5bcbaf7ac77463667c5bbfa4</icon>
  <subtitle>Keep it simple, stupid</subtitle>
  <link href="http://xupin.im/atom.xml" rel="self"/>
  
  <link href="http://xupin.im/"/>
  <updated>2023-07-22T06:24:54.609Z</updated>
  <id>http://xupin.im/</id>
  
  <author>
    <name>Mark</name>
    <email>xupinbest@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>游戏开发笔记 - Behavior Tree(行为树)</title>
    <link href="http://xupin.im/2023/07/21/game-behavior-tree/"/>
    <id>http://xupin.im/2023/07/21/game-behavior-tree/</id>
    <published>2023-07-20T16:00:00.000Z</published>
    <updated>2023-07-22T06:24:54.609Z</updated>
    
    <content type="html"><![CDATA[<p>行为树一般应用于游戏内物体的AI决策，以树的形式控制物体接下来的动作。比如: 血量太少 -&gt; 吃药、攻击距离不够 -&gt; 移动等等。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在摸索小游戏开发，有一些联机型的功能需要机器人参与，所以需要实现一下游戏AI。综合一下实现方案基本是以下两种：</p><ul><li>有限状态机（Finite State Machine）</li></ul><blockquote><p>FSM也是最开始采用的方案，实现起来简单粗暴。缺点是整个逻辑非常臃肿很难模块化，后面再对AI进行更新和维护比较恶心，很容易因为漏改、错改导致不可用。</p></blockquote><ul><li>行为树（Behavior Tree）</li></ul><blockquote><p>行为树是由一系列节点构成的，每个节点对应一个动作，自上而下执行且每个节点都会返回执行状态。</p></blockquote><p><img src="/assets/bt/bt.png" alt="drawing" width="300" height="180"></p><a id="more"></a><h3 id="行为树"><a href="#行为树" class="headerlink" title="行为树"></a>行为树</h3><p>行为树一般由：根节点（Root）、序列节点（Sequence）、选择节点（Selector）、并行节点（Parallel）等等节点组成，可能还会有条件节点（Condition）。这些节点也可以被抽象的归为4类:</p><ul><li><p>控制节点</p><ol><li>序列节点（Sequence）</li><li>选择节点（Selector）</li><li>并行节点（Parallel）</li></ol></li><li><p>条件节点</p><ol><li>条件节点（Condition）</li></ol></li><li><p>装饰节点</p><ol><li>逆变节点（Inverter）</li><li>重复执行节点（Repeater）</li><li>装饰节点也算是自定义节点，主要作用是辅助子节点执行。</li></ol></li><li><p>行为节点</p><ol><li>自定义节点。比如：攻击、防御、吃药等，是真正执行游戏逻辑的节点。</li></ol></li></ul><p>需要注意的是，无论是什么节点都必须实现<code>Exec()</code>执行方法。</p><p>定义节点接口：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Status <span class="keyword">int8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Success Status = <span class="literal">iota</span></span><br><span class="line">    Failure</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> INode <span class="keyword">interface</span> &#123;</span><br><span class="line">    Exec() Status</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="序列节点"><a href="#序列节点" class="headerlink" title="序列节点"></a>序列节点</h3><p>有序的执行子节点，任意子节点失败终止执行返回失败，全部执行完毕返回成功。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列</span></span><br><span class="line"><span class="keyword">type</span> Sequence <span class="keyword">struct</span> &#123;</span><br><span class="line">    children []INode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSequence</span><span class="params">(children ...INode)</span> *<span class="title">Sequence</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Sequence&#123;</span><br><span class="line">        children: children,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Sequence)</span> <span class="title">Exec</span><span class="params">()</span> <span class="title">Status</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, child := <span class="keyword">range</span> r.children &#123;</span><br><span class="line">        <span class="keyword">if</span> result := child.Exec(); result == Failure &#123;</span><br><span class="line">            <span class="keyword">return</span> Failure</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Success</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择节点"><a href="#选择节点" class="headerlink" title="选择节点"></a>选择节点</h3><p>同样有序的执行子节点、和序列节点不同的是任意子节点执行成功返回成功。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Selector <span class="keyword">struct</span> &#123;</span><br><span class="line">    children []INode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSelector</span><span class="params">(children ...INode)</span> *<span class="title">Selector</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Selector&#123;</span><br><span class="line">        children: children,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Selector)</span> <span class="title">Exec</span><span class="params">()</span> <span class="title">Status</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, child := <span class="keyword">range</span> r.children &#123;</span><br><span class="line">        <span class="keyword">if</span> result := child.Exec(); result == Success &#123;</span><br><span class="line">            <span class="keyword">return</span> Success</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Failure</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并行节点"><a href="#并行节点" class="headerlink" title="并行节点"></a>并行节点</h3><p>同时执行所有子节点</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Parallel <span class="keyword">struct</span> &#123;</span><br><span class="line">    children []INode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewParallel</span><span class="params">(children ...INode)</span> *<span class="title">Parallel</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Parallel&#123;</span><br><span class="line">        children: children,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Parallel)</span> <span class="title">Exec</span><span class="params">()</span> <span class="title">Status</span></span> &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, child := <span class="keyword">range</span> r.children &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(node INode)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            node.Exec()</span><br><span class="line">        &#125;(child)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="keyword">return</span> Success</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件节点-行为节点"><a href="#条件节点-行为节点" class="headerlink" title="条件节点 / 行为节点"></a>条件节点 / 行为节点</h3><p>顾名思义，执行子节点前需要检查是不是符合条件。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Condition <span class="keyword">struct</span> &#123;</span><br><span class="line">    f <span class="function"><span class="keyword">func</span><span class="params">(IBlackboard)</span> <span class="title">bool</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCondition</span><span class="params">(f <span class="keyword">func</span>(IBlackboard)</span> <span class="title">bool</span>) *<span class="title">Condition</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Condition&#123;</span><br><span class="line">        f: f,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Condition)</span> <span class="title">Exec</span><span class="params">(db IBlackboard)</span> <span class="title">Status</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> v := r.f(db); !v &#123;</span><br><span class="line">        <span class="keyword">return</span> Failure</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Success</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这引入一个概念: <code>Blackboard</code>，一般一个行为树有且只有一个，用于各节点间共享数据。调用实现:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绝招</span></span><br><span class="line"><span class="keyword">type</span> JueZhao <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewJueZhao</span><span class="params">()</span> *<span class="title">JueZhao</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;JueZhao&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *JueZhao)</span> <span class="title">Exec</span><span class="params">(db IBlackboard)</span> <span class="title">Status</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"[绝招]done"</span>)</span><br><span class="line">    db.Set(<span class="string">"can_use_skill"</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span> Success</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 蓄力</span></span><br><span class="line"><span class="keyword">type</span> XuLi <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewXuLi</span><span class="params">()</span> *<span class="title">XuLi</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;XuLi&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *XuLi)</span> <span class="title">Exec</span><span class="params">(db IBlackboard)</span> <span class="title">Status</span></span> &#123;</span><br><span class="line">    db.Set(<span class="string">"can_use_skill"</span>, <span class="literal">true</span>)</span><br><span class="line">    fmt.Println(<span class="string">"[蓄力]done"</span>)</span><br><span class="line">    <span class="keyword">return</span> Success</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义根节点</span></span><br><span class="line">    bt := NewSequence(</span><br><span class="line">        NewXuLi(),</span><br><span class="line">        NewCondition(<span class="function"><span class="keyword">func</span><span class="params">(db IBlackboard)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">            result := db.Get(<span class="string">"can_use_skill"</span>)</span><br><span class="line">            <span class="keyword">if</span> result == <span class="literal">nil</span> || !result.(<span class="keyword">bool</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;),</span><br><span class="line">        NewJueZhao(),</span><br><span class="line">    )</span><br><span class="line">    db := &amp;Blackboard&#123;</span><br><span class="line">        data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    result := bt.Exec(db)</span><br><span class="line">    fmt.Print(<span class="string">"结果: "</span>)</span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> Success:</span><br><span class="line">        fmt.Println(<span class="string">"成功"</span>)</span><br><span class="line">    <span class="keyword">case</span> Failure:</span><br><span class="line">        fmt.Println(<span class="string">"失败"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [蓄力]done</span></span><br><span class="line"><span class="comment">// [绝招]done</span></span><br><span class="line"><span class="comment">// 结果: 成功</span></span><br></pre></td></tr></table></figure></p><h3 id="装饰节点"><a href="#装饰节点" class="headerlink" title="装饰节点"></a>装饰节点</h3><p>比如让AI连续执行3次绝招。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Repeater <span class="keyword">struct</span> &#123;</span><br><span class="line">    child INode</span><br><span class="line">    count <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRepeater</span><span class="params">(child INode, count <span class="keyword">int8</span>)</span> *<span class="title">Repeater</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Repeater&#123;</span><br><span class="line">        child: child,</span><br><span class="line">        count: count,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Repeater)</span> <span class="title">Exec</span><span class="params">(db IBlackboard)</span> <span class="title">Status</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> r.count &gt; <span class="number">0</span> &#123;</span><br><span class="line">        r.child.Exec(db)</span><br><span class="line">        r.count -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Success</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>通过以上几个简单实现，大概知道行为树其实就是把想要让AI执行的动作抽象成一个一个行为节点，使用组合节点加以控制组成一个复杂的AI树。</p><p>优点显而易见，可读性好、方便扩展、可以脚本化编写。部分游戏引擎也提供可视化编写，比如：Unreal、Unity的Behavior Designer插件等</p><p>缺点是每次都从根节点运行，行为树比较复杂的情况运行效率不会高。当然针对这个问题可以进行优化，就是对节点做Running记录，下次从Running节点继续执行。</p><p>附上示例：<a href="https://github.com/xupin/example/blob/main/behavior-tree/main.go" target="_blank" rel="noopener">bt/main.go</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;行为树一般应用于游戏内物体的AI决策，以树的形式控制物体接下来的动作。比如: 血量太少 -&amp;gt; 吃药、攻击距离不够 -&amp;gt; 移动等等。&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近在摸索小游戏开发，有一些联机型的功能需要机器人参与，所以需要实现一下游戏AI。综合一下实现方案基本是以下两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有限状态机（Finite State Machine）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;FSM也是最开始采用的方案，实现起来简单粗暴。缺点是整个逻辑非常臃肿很难模块化，后面再对AI进行更新和维护比较恶心，很容易因为漏改、错改导致不可用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;行为树（Behavior Tree）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;行为树是由一系列节点构成的，每个节点对应一个动作，自上而下执行且每个节点都会返回执行状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/assets/bt/bt.png&quot; alt=&quot;drawing&quot; width=&quot;300&quot; height=&quot;180&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="game" scheme="http://xupin.im/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>游戏开发笔记 - 通信协议</title>
    <link href="http://xupin.im/2023/02/27/game-communications-protocol/"/>
    <id>http://xupin.im/2023/02/27/game-communications-protocol/</id>
    <published>2023-02-26T16:00:00.000Z</published>
    <updated>2023-02-27T06:46:22.417Z</updated>
    
    <content type="html"><![CDATA[<p>在网络游戏中，通信协议是其中必不可少的组成部分。一个通信协议的大小、结构将与服务器负载及客户端延迟息息相关。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>游戏的通信协议，一般需要考虑2个部分：</p><ol><li><p>网络传输协议</p></li><li><p>数据交换格式</p></li></ol><a id="more"></a><h3 id="网络传输协议"><a href="#网络传输协议" class="headerlink" title="网络传输协议"></a>网络传输协议</h3><p>根据游戏类型的不同，网络传输协议选择也有些许不同。比如：</p><ul><li>弱联网类型</li></ul><blockquote><p>单工/半双工通信协议：HTTP1.0、HTTP1.1</p></blockquote><ul><li>强联网、强交互类型</li></ul><blockquote><p>全双工通信协议：WebSocket、TCP</p></blockquote><ul><li>强联网、实时交互类型</li></ul><blockquote><p>UDP</p></blockquote><p>单工、半双工及全双工通信协议的区别用3张图来表示一下，具体内容留到下篇学习笔记再水…</p><p>单工<br><img src="/assets/game-protocol/single.gif" width="300" height="100" alt="drawing"></p><p>半双工<br><img src="/assets/game-protocol/two-way.gif" width="300" height="100" alt="drawing"></p><p>全双工<br><img src="/assets/game-protocol/full-duplex.gif" width="300" height="100" alt="drawing"></p><h3 id="数据交换格式"><a href="#数据交换格式" class="headerlink" title="数据交换格式"></a>数据交换格式</h3><p>对于数据交换格式来说，需要解决的最主要的问题就是内容语义清晰，结构稳定，通俗地说不同的程序都可以稳定的解析并且知道怎样去处理它们。</p><p>对于数据结构，一般有以下几个选择：</p><ul><li>XML</li></ul><blockquote><p>可读性高，解析难度高</p></blockquote><ul><li>JSON</li></ul><blockquote><p>可读性高、易解析、体积小</p></blockquote><ul><li>Protocol Buffers</li></ul><blockquote><p>可读性差、易解析、体积特别小</p></blockquote><p>在确定数据交换协议后，还需要制定数据交换的格式，保证数据不会出现歧义。比如下图这样的格式（未考虑加密）。</p><p><img src="/assets/game-protocol/structure.png" alt="drawing"></p><p>从左向右结构：<code>头字节表示协议名称的长度、中间部分是协议名称、最后是协议的具体数据（可以是XML、JSON、PB等）。</code></p><h3 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h3><p>使用WebSocket + PB来实现一套通信协议，实现一个简易登录协议。</p><p>协议文件<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line">option go_package = <span class="string">"./protocol"</span>;</span><br><span class="line"></span><br><span class="line">message login &#123;</span><br><span class="line">    <span class="keyword">string</span> username = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">string</span> password = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务端核心代码<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Packet <span class="keyword">struct</span> &#123;</span><br><span class="line">Protocol <span class="keyword">string</span></span><br><span class="line">Bytes    []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Packet)</span> <span class="title">Encode</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">buffer := &amp;bytes.Buffer&#123;&#125;</span><br><span class="line"><span class="comment">// 2字节，协议名称长度</span></span><br><span class="line">buffer.Write(r.shortBytes(<span class="keyword">uint16</span>(<span class="built_in">len</span>(r.Protocol))))</span><br><span class="line"><span class="comment">// 协议名称</span></span><br><span class="line">buffer.WriteString(r.Protocol)</span><br><span class="line"><span class="comment">// 协议内容</span></span><br><span class="line">buffer.Write(r.Bytes)</span><br><span class="line"><span class="keyword">return</span> buffer.Bytes()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Packet)</span> <span class="title">Decode</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">buffer := bytes.NewBuffer(r.Bytes)</span><br><span class="line">byteLen := buffer.Len()</span><br><span class="line"><span class="comment">// 2字节，协议名称长度</span></span><br><span class="line">headLen := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2</span>)</span><br><span class="line">buffer.Read(headLen)</span><br><span class="line"><span class="comment">// 协议名称</span></span><br><span class="line">protocolLen := r.readShort(headLen)</span><br><span class="line">protocol := <span class="built_in">make</span>([]<span class="keyword">byte</span>, protocolLen)</span><br><span class="line">buffer.Read(protocol)</span><br><span class="line">r.Protocol = <span class="keyword">string</span>(protocol)</span><br><span class="line"><span class="comment">// 协议内容</span></span><br><span class="line">bytes := <span class="built_in">make</span>([]<span class="keyword">byte</span>, byteLen<span class="number">-2</span>-<span class="keyword">int</span>(protocolLen))</span><br><span class="line">buffer.Read(bytes)</span><br><span class="line">r.Bytes = bytes</span><br><span class="line"><span class="keyword">return</span> bytes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Packet)</span> <span class="title">readShort</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="title">uint16</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> binary.BigEndian.Uint16(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Packet)</span> <span class="title">shortBytes</span><span class="params">(i <span class="keyword">uint16</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">bytes := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2</span>)</span><br><span class="line">binary.BigEndian.PutUint16(bytes, i)</span><br><span class="line"><span class="keyword">return</span> bytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>附上完整实现：<br><a href="https://github.com/xupin/example/tree/main/protocol-cli" target="_blank" rel="noopener">客户端-ts</a><br><a href="https://github.com/xupin/example/tree/main/protocol-svr" target="_blank" rel="noopener">服务端-go</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在网络游戏中，通信协议是其中必不可少的组成部分。一个通信协议的大小、结构将与服务器负载及客户端延迟息息相关。&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;游戏的通信协议，一般需要考虑2个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;网络传输协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据交换格式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="game" scheme="http://xupin.im/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>游戏开发笔记 - 地图编辑器</title>
    <link href="http://xupin.im/2023/01/30/game-map-editor/"/>
    <id>http://xupin.im/2023/01/30/game-map-editor/</id>
    <published>2023-01-29T16:00:00.000Z</published>
    <updated>2023-01-31T09:05:27.841Z</updated>
    
    <content type="html"><![CDATA[<p>之前在学习<a href="/2022/08/01/data-structures-algorithms-astar/" title="数据结构与算法 - AStar(A*)">数据结构与算法 - AStar(A*)</a>等寻路算法的过程中提到过网格地图时由类似<code>0是可移动节点、1是障碍节点</code>的网格组成的一张地图，这些地图信息是怎样生成出来的呢？</p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>地图编辑器是一种所见即所得的游戏地图制作工具，它辅助设计和输出地图数据，包括创建、编辑、存储和管理游戏地图数据。</p><h3 id="如何生成地图数据"><a href="#如何生成地图数据" class="headerlink" title="如何生成地图数据"></a>如何生成地图数据</h3><p>只考虑2D地图，一般来说有两种方式：</p><a id="more"></a><ul><li><p>PhotoShop<br>打开原始地图文件，按照网格大小进行标注类型</p></li><li><p>地图编辑器<br>2D游戏有很多成熟的编辑器，比如：<a href="https://github.com/mapeditor/tiled" target="_blank" rel="noopener">tiled editor</a>，但本着“造轮子”的原则就是开发一套啦！</p></li></ul><p>地图编辑器使用什么技术来开发，选择也很多样性。</p><p>考虑学习成本问题，这里使用Cocos Creator + Typescript来开发一套简易的地图编辑器。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li><p>加载贴图文件</p></li><li><p>根据指定网格大小进行划分网格</p></li><li><p>可以对网格填充不同的颜色（可行走、不可行走）</p></li><li><p>导出结果</p></li></ol><p>地图编辑器是游戏开发中最入门的部分，简单粗暴！</p><h3 id="加载贴图文件"><a href="#加载贴图文件" class="headerlink" title="加载贴图文件"></a>加载贴图文件</h3><p>创建一个用于显示地图的<code>Sprite</code>节点。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; ccclass, property &#125; = cc._decorator;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ccclass</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> main <span class="keyword">extends</span> cc.Component &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地图贴图节点</span></span><br><span class="line">    <span class="meta">@property</span>(cc.Node)</span><br><span class="line">    mapNode: cc.Node = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    start() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    onLoad() &#123;</span><br><span class="line">        <span class="comment">// init logic</span></span><br><span class="line">        cc.resources.load(<span class="string">"textures/4006"</span>, cc.SpriteFrame, <span class="function">(<span class="params">err, frame: cc.SpriteFrame</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(err.message || err);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.mapNode.getComponent(cc.Sprite).spriteFrame = frame;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/map-editor/load-sprite.jpg" alt="drawing" width="500" height="313"></p><h3 id="划分网格"><a href="#划分网格" class="headerlink" title="划分网格"></a>划分网格</h3><p>在Sprite节点下创建一个绘图子节点<code>Graphics</code>。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘图节点</span></span><br><span class="line"><span class="meta">@property</span>(cc.Graphics)</span><br><span class="line">mapGraphics: cc.Graphics = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 地图原始尺寸</span></span><br><span class="line">originWidth: <span class="built_in">number</span> = <span class="number">2862</span>;</span><br><span class="line">originHeight: <span class="built_in">number</span> = <span class="number">2304</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网格大小</span></span><br><span class="line">gridWidth: <span class="built_in">number</span> = <span class="number">20</span>;</span><br><span class="line">gridHeight: <span class="built_in">number</span> = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></p><p>之后在<code>Graphics</code>节点进行绘制。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.mapGraphics.clear() <span class="comment">// 清除所有绘制</span></span><br><span class="line"><span class="keyword">this</span>.mapGraphics.strokeColor = cc.Color.RED <span class="comment">// 红色</span></span><br><span class="line"><span class="keyword">this</span>.mapGraphics.lineWidth = <span class="number">1</span> <span class="comment">// 线宽度</span></span><br><span class="line"><span class="comment">// 画竖线</span></span><br><span class="line"><span class="keyword">let</span> xMax: <span class="built_in">number</span> = <span class="built_in">Math</span>.floor(<span class="keyword">this</span>.mapNode.width / <span class="keyword">this</span>.gridWidth)</span><br><span class="line"><span class="comment">// console.log("xMax = width / gridWidth", xMax, this.mapNode.width, this.gridWidth)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i: <span class="built_in">number</span> = <span class="number">0</span>; i &lt; xMax; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = i * <span class="keyword">this</span>.gridWidth;</span><br><span class="line">    <span class="keyword">this</span>.mapGraphics.moveTo(x, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">this</span>.mapGraphics.lineTo(x, <span class="keyword">this</span>.mapNode.height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 画横线</span></span><br><span class="line"><span class="keyword">let</span> yMax: <span class="built_in">number</span> = <span class="built_in">Math</span>.floor(<span class="keyword">this</span>.mapNode.height / <span class="keyword">this</span>.gridHeight)</span><br><span class="line"><span class="comment">// console.log("yMax = height / gridHeight", yMax, this.mapNode.height, this.gridHeight)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i: <span class="built_in">number</span> = <span class="number">0</span>; i &lt; yMax; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> y = i * <span class="keyword">this</span>.gridHeight;</span><br><span class="line">    <span class="keyword">this</span>.mapGraphics.moveTo(<span class="number">0</span>, y)</span><br><span class="line">    <span class="keyword">this</span>.mapGraphics.lineTo(<span class="keyword">this</span>.mapNode.width, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.mapGraphics.stroke();</span><br></pre></td></tr></table></figure></p><p><img src="/assets/map-editor/graphics.jpg" alt="drawing" width="500" height="313"></p><h3 id="填充颜色"><a href="#填充颜色" class="headerlink" title="填充颜色"></a>填充颜色</h3><p>监听触屏事件<code>TOUCH_START</code>、<code>TOUCH_MOVE</code>。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mouse event</span></span><br><span class="line"><span class="keyword">this</span>.mapNode.on(cc.Node.EventType.TOUCH_START, <span class="keyword">this</span>.updateGrid, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>.mapNode.on(cc.Node.EventType.TOUCH_MOVE, <span class="keyword">this</span>.updateGrid, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p><p>事件触发，给鼠标所在坐标的网格填充颜色。这里需要注意的小知识点<code>坐标系的转换</code>，可分为：世界坐标、本地坐标、像素坐标。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventPos: cc.Vec2 = event.getLocation();</span><br><span class="line"><span class="keyword">let</span> pos = <span class="keyword">this</span>.mapNode.convertToNodeSpaceAR(eventPos); <span class="comment">// 转换至节点坐标</span></span><br><span class="line"><span class="keyword">let</span> x: <span class="built_in">number</span> = <span class="built_in">Math</span>.floor(pos.x / <span class="keyword">this</span>.gridWidth);</span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">number</span> = <span class="built_in">Math</span>.floor(pos.y / <span class="keyword">this</span>.gridHeight);</span><br><span class="line"><span class="keyword">this</span>.mapGraphics.rect(x * <span class="keyword">this</span>.gridWidth, y * <span class="keyword">this</span>.gridHeight, <span class="keyword">this</span>.gridWidth, <span class="keyword">this</span>.gridHeight);</span><br><span class="line"><span class="keyword">this</span>.mapGraphics.fillColor = cc.Color.BLUE;</span><br><span class="line"><span class="keyword">this</span>.mapGraphics.fill();</span><br></pre></td></tr></table></figure></p><p><img src="/assets/map-editor/fill-color.gif" alt="drawing" width="500" height="313"></p><h3 id="导出结果"><a href="#导出结果" class="headerlink" title="导出结果"></a>导出结果</h3><p>导出结果逻辑很简单，需要在填充颜色时记录对应网格的类型，最后输出到文件。</p><p>生成x*y个网。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网格信息</span></span><br><span class="line">grids: <span class="built_in">Array</span>&lt;<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;&gt;;</span><br></pre></td></tr></table></figure></p><p>记录网格信息。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录格子信息</span></span><br><span class="line"><span class="keyword">this</span>.grids = <span class="keyword">new</span> <span class="built_in">Array</span>(xMax);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i: <span class="built_in">number</span> = <span class="number">0</span>; i &lt; xMax; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>.grids[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(yMax);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j: <span class="built_in">number</span> = <span class="number">0</span>; j &lt; yMax; j++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.grids[i][j] = <span class="number">1</span>; <span class="comment">// 默认不可行走</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出到文件<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v: object = &#123;</span><br><span class="line">    map: &#123;</span><br><span class="line">        originWidth: <span class="keyword">this</span>.originWidth,</span><br><span class="line">        originHeight: <span class="keyword">this</span>.originHeight,</span><br><span class="line">        width: <span class="keyword">this</span>.mapNode.width,</span><br><span class="line">        height: <span class="keyword">this</span>.mapNode.height,</span><br><span class="line">    &#125;,</span><br><span class="line">    grid: &#123;</span><br><span class="line">        width: <span class="keyword">this</span>.gridWidth,</span><br><span class="line">        height: <span class="keyword">this</span>.gridHeight,</span><br><span class="line">    &#125;,</span><br><span class="line">    data: <span class="keyword">this</span>.grids,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (cc.sys.isBrowser) &#123;</span><br><span class="line">    <span class="keyword">let</span> json = <span class="built_in">JSON</span>.stringify(v)</span><br><span class="line">    <span class="keyword">let</span> blob = <span class="keyword">new</span> Blob([json], &#123; <span class="keyword">type</span>: <span class="string">'application/json'</span> &#125;);</span><br><span class="line">    <span class="keyword">let</span> aLink = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line">    aLink.download = <span class="string">'map.json'</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.webkitURL != <span class="literal">null</span>) &#123;</span><br><span class="line">        aLink.href = <span class="built_in">window</span>.webkitURL.createObjectURL(blob);</span><br><span class="line">    &#125;</span><br><span class="line">    aLink.click();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"导出仅支持浏览器"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>附上完整代码：<a href="https://github.com/xupin/example/tree/main/map-editor" target="_blank" rel="noopener">map-editor</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前在学习&lt;a href=&quot;/2022/08/01/data-structures-algorithms-astar/&quot; title=&quot;数据结构与算法 - AStar(A*)&quot;&gt;数据结构与算法 - AStar(A*)&lt;/a&gt;等寻路算法的过程中提到过网格地图时由类似&lt;code&gt;0是可移动节点、1是障碍节点&lt;/code&gt;的网格组成的一张地图，这些地图信息是怎样生成出来的呢？&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;地图编辑器是一种所见即所得的游戏地图制作工具，它辅助设计和输出地图数据，包括创建、编辑、存储和管理游戏地图数据。&lt;/p&gt;
&lt;h3 id=&quot;如何生成地图数据&quot;&gt;&lt;a href=&quot;#如何生成地图数据&quot; class=&quot;headerlink&quot; title=&quot;如何生成地图数据&quot;&gt;&lt;/a&gt;如何生成地图数据&lt;/h3&gt;&lt;p&gt;只考虑2D地图，一般来说有两种方式：&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="game" scheme="http://xupin.im/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 - AST</title>
    <link href="http://xupin.im/2022/12/13/data-structures-algorithms-ast/"/>
    <id>http://xupin.im/2022/12/13/data-structures-algorithms-ast/</id>
    <published>2022-12-12T16:00:00.000Z</published>
    <updated>2022-12-28T07:31:41.772Z</updated>
    
    <content type="html"><![CDATA[<p>AST（Abstract syntax tree）抽象语法树，用于表示编程语言源代码的一种抽象语法的结构，树的每个节点都对应源代码中的一个结构。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>计算机如何生成AST结构？一般来说顺序如下：</p><ol><li>词法分析</li></ol><blockquote><p>扫描源代码，生成标记（token）</p></blockquote><ol><li>语法分析</li></ol><blockquote><p>解析tokens，构造AST结构</p></blockquote><a id="more"></a><p>分析过程：<br><img src="/assets/ast/process.png" alt="drawing" width="400" height="150"></p><p>AST结构：<br><img src="/assets/ast/ast.png" alt="drawing" width="400" height="420"></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>AST应用场景比较广泛，比如：</p><ul><li><p>Typescript编译Javascript文件</p></li><li><p>格式化插件</p></li><li><p>代码混淆/压缩</p></li><li><p>类型检查/推导</p></li></ul><p>等等…诸多应用场景。</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>如何读入源代码，扫描、解析以及生成AST？下面尝试用一个可以计算<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>公式的小程序来学习和实验。</p><p>假设，给定的源码是<code>1+2+3</code>，应该怎样去扫描？扫描原理很简单，通俗的说就是按字符读取记录为Token。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先定义存储标记的结构</span></span><br><span class="line"><span class="keyword">type</span> Token <span class="keyword">struct</span> &#123;</span><br><span class="line">Str   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描源码</span></span><br><span class="line">s := <span class="string">"1+2+3"</span></span><br><span class="line">tokens := []Token&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">tokens = <span class="built_in">append</span>(tokens, Token&#123;</span><br><span class="line">Str: <span class="keyword">string</span>(c),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, tokens)</span><br><span class="line"><span class="comment">// [&#123;Str:1&#125; &#123;Str:+&#125; &#123;Str:2&#125; &#123;Str:+&#125; &#123;Str:3&#125;]</span></span><br></pre></td></tr></table></figure><p>以上，扫描工作就完成了！</p><p>但词法分析一般没有这么简单，比如数字<code>1</code>和操作符<code>+</code>也不应该是同一种类型。所以我们需要改造词法分析器！在生成Token的同时记录类型，方便进一步处理。这里我们使用状态机的设计思路：</p><ol><li>读入一个字符</li><li>判断字符类型，数字 or 操作符<br>&nbsp;&nbsp;&nbsp;&nbsp;1. 是数字，记录当前字符位置，继续读取下一个字符，直至非数字或者字符边界，记录完整的数值。<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 不是数字，直接记录操作符。</li><li>返回token</li></ol><p>详细扫描逻辑，如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Lexer <span class="keyword">struct</span> &#123;</span><br><span class="line">Formula <span class="keyword">string</span></span><br><span class="line">Char    <span class="keyword">byte</span></span><br><span class="line">Pos     <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Token <span class="keyword">struct</span> &#123;</span><br><span class="line">Str   <span class="keyword">string</span></span><br><span class="line">Type  <span class="keyword">int</span></span><br><span class="line">Start <span class="keyword">int</span></span><br><span class="line">End   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Lexer)</span> <span class="title">Lex</span><span class="params">()</span> <span class="params">([]*Token, error)</span></span> &#123;</span><br><span class="line">tokens := <span class="built_in">make</span>([]*Token, <span class="number">0</span>)</span><br><span class="line">r.Char = r.Formula[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> r.Pos &lt; <span class="built_in">len</span>(r.Formula) &#123;</span><br><span class="line">token := r.Scan()</span><br><span class="line"><span class="keyword">if</span> token.Type == enums.ILLEGAL &#123;</span><br><span class="line"><span class="keyword">return</span> []*Token&#123;&#125;, fmt.Errorf(<span class="string">"'%s' is not supported"</span>, token.Str)</span><br><span class="line">&#125;</span><br><span class="line">tokens = <span class="built_in">append</span>(tokens, token)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tokens, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Lexer)</span> <span class="title">Scan</span><span class="params">()</span> *<span class="title">Token</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> token *Token</span><br><span class="line">pos := r.Pos</span><br><span class="line"><span class="keyword">switch</span> r.Char &#123;</span><br><span class="line"><span class="keyword">case</span></span><br><span class="line"><span class="string">'0'</span>,</span><br><span class="line"><span class="string">'1'</span>,</span><br><span class="line"><span class="string">'2'</span>,</span><br><span class="line"><span class="string">'3'</span>,</span><br><span class="line"><span class="string">'4'</span>,</span><br><span class="line"><span class="string">'5'</span>,</span><br><span class="line"><span class="string">'6'</span>,</span><br><span class="line"><span class="string">'7'</span>,</span><br><span class="line"><span class="string">'8'</span>,</span><br><span class="line"><span class="string">'9'</span>:</span><br><span class="line"><span class="keyword">for</span> r.IsDigit() &#123;</span><br><span class="line"><span class="keyword">if</span> !r.NextChar() &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">token = &amp;Token&#123;</span><br><span class="line">Str:   <span class="keyword">string</span>(r.Formula[pos:r.Pos]),</span><br><span class="line">Type:  enums.NUMBER,</span><br><span class="line">Start: pos,</span><br><span class="line">End:   r.Pos,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">token = &amp;Token&#123;</span><br><span class="line">Str:   <span class="keyword">string</span>(r.Char),</span><br><span class="line">Type:  enums.ADD,</span><br><span class="line">Start: pos,</span><br><span class="line">End:   pos,</span><br><span class="line">&#125;</span><br><span class="line">r.NextChar()</span><br><span class="line"><span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">token = &amp;Token&#123;</span><br><span class="line">Str:   <span class="keyword">string</span>(r.Char),</span><br><span class="line">Type:  enums.SUB,</span><br><span class="line">Start: pos,</span><br><span class="line">End:   pos,</span><br><span class="line">&#125;</span><br><span class="line">r.NextChar()</span><br><span class="line"><span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">token = &amp;Token&#123;</span><br><span class="line">Str:   <span class="keyword">string</span>(r.Char),</span><br><span class="line">Type:  enums.MUL,</span><br><span class="line">Start: pos,</span><br><span class="line">End:   pos,</span><br><span class="line">&#125;</span><br><span class="line">r.NextChar()</span><br><span class="line"><span class="keyword">if</span> r.Char == <span class="string">'*'</span> &#123;</span><br><span class="line">token = &amp;Token&#123;</span><br><span class="line">Str:   <span class="string">"**"</span>,</span><br><span class="line">Type:  enums.XOR,</span><br><span class="line">Start: pos,</span><br><span class="line">End:   pos,</span><br><span class="line">&#125;</span><br><span class="line">r.NextChar()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">token = &amp;Token&#123;</span><br><span class="line">Str:   <span class="keyword">string</span>(r.Char),</span><br><span class="line">Type:  enums.QUO,</span><br><span class="line">Start: pos,</span><br><span class="line">End:   pos,</span><br><span class="line">&#125;</span><br><span class="line">r.NextChar()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">token = &amp;Token&#123;</span><br><span class="line">Str:   <span class="keyword">string</span>(r.Char),</span><br><span class="line">Type:  enums.ILLEGAL,</span><br><span class="line">Start: pos,</span><br><span class="line">End:   r.Pos,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> token</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，我们调用词法分析器解析<code>1+2+3</code><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lexer := lexer.Lexer&#123;</span><br><span class="line">Formula: <span class="string">"1+2+3"</span>,</span><br><span class="line">&#125;</span><br><span class="line">tokens, err := lexer.Lex()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, token := <span class="keyword">range</span> tokens &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%+v \n"</span>, token)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &amp;&#123;Str:1 Type:9 Start:0 End:0&#125;</span></span><br><span class="line"><span class="comment">// &amp;&#123;Str:+ Type:10 Start:1 End:1&#125;</span></span><br><span class="line"><span class="comment">// &amp;&#123;Str:2 Type:9 Start:2 End:2&#125;</span></span><br><span class="line"><span class="comment">// &amp;&#123;Str:+ Type:10 Start:3 End:3&#125;</span></span><br><span class="line"><span class="comment">// &amp;&#123;Str:3 Type:9 Start:4 End:4&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>生成tokens是第一步，这一串token又要怎样去解析呢？</p><p>已知+-*/均属于二元运算，二元运算三元素：运算符、左变量、右变量。所以我们需要的结构大概是这样：Number{1} Op{+} Number{2} Op{+} Number{3}，用二叉树来表示：</p><p><img src="/assets/ast/binary-tree.png" alt="drawing"></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先定义一个语法分析器</span></span><br><span class="line"><span class="keyword">type</span> Parser <span class="keyword">struct</span> &#123;</span><br><span class="line">Tokens   []*lexer.Token <span class="comment">// tokens</span></span><br><span class="line">CurToken *lexer.Token <span class="comment">// 当前token</span></span><br><span class="line">Index      <span class="keyword">int</span><span class="comment">// 下标</span></span><br><span class="line">Err      error<span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数值结构</span></span><br><span class="line"><span class="keyword">type</span> Number <span class="keyword">struct</span> &#123;</span><br><span class="line">Val <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元运算结构</span></span><br><span class="line"><span class="keyword">type</span> Stmt <span class="keyword">struct</span> &#123;</span><br><span class="line">Type  <span class="keyword">int</span></span><br><span class="line">Left  Node</span><br><span class="line">Right Node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理逻辑如下：</p><ol><li>顺序取出一个token。</li><li>ParseExpr()判定token类型，返回对应结构，下标+1（处理下一个token，应当是运算符token）。<br>&nbsp;&nbsp;&nbsp;&nbsp;1. 如果是数值类型，则直接返回Number{}结构。<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 如果是运算符类型，则递归处理返回Stmt{}结构。</li><li>ParseRight()处理右侧变量，把左侧变量传入函数。</li><li>根据运算符判断变量优先级问题，如果当前运算符小于传入变量优先级，则直接返回传入变量，处理结束。</li><li>记录当前运算符（类型），下标+1，处理当前操作符右侧变量（步骤2）。</li><li>再次判断传入变量优先级是否低于当前运算符。<br>&nbsp;&nbsp;&nbsp;&nbsp;1. 是，则把右侧变量（步骤4）当成左侧变量传入递归处理。<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 不是，则构造二元运算表达式Stmt{Type: 运算符类型, Left: 左侧变量, Right: 右侧变量}。</li><li>当前循环结束，回到步骤4。</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Parser)</span> <span class="title">Parse</span><span class="params">()</span> <span class="params">(Node, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(r.Tokens) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"the token list is empty"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r.CurToken == <span class="literal">nil</span> &#123;</span><br><span class="line">r.CurToken = r.Tokens[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r.Compile(), r.Err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Parser)</span> <span class="title">Compile</span><span class="params">()</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">left := r.ParseExpr()</span><br><span class="line">right := r.ParseRight(<span class="number">1</span>, left)</span><br><span class="line"><span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Parser)</span> <span class="title">ParseExpr</span><span class="params">()</span> <span class="title">Node</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> r.CurToken.Type &#123;</span><br><span class="line"><span class="keyword">case</span> enums.NUMBER:</span><br><span class="line"><span class="keyword">return</span> r.ParseNumber()</span><br><span class="line"><span class="keyword">case</span> enums.ADD:</span><br><span class="line"><span class="keyword">return</span> r.ParseNumber()</span><br><span class="line"><span class="keyword">case</span> enums.SUB:</span><br><span class="line"><span class="keyword">if</span> t := r.NextToken(); t.Type == enums.EOF &#123;</span><br><span class="line">r.Err = errors.New(<span class="string">"expects to be number, eof given"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;Stmt&#123;</span><br><span class="line">Type:  enums.SUB,</span><br><span class="line">Left:  &amp;Number&#123;&#125;,</span><br><span class="line">Right: r.ParseExpr(),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> enums.MUL:</span><br><span class="line"><span class="keyword">return</span> r.ParseNumber()</span><br><span class="line"><span class="keyword">case</span> enums.QUO:</span><br><span class="line"><span class="keyword">return</span> r.ParseNumber()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">r.Err = fmt.Errorf(<span class="string">"expects to be number, '%s' given"</span>, r.CurToken.Str)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Parser)</span> <span class="title">ParseRight</span><span class="params">(precedence <span class="keyword">int</span>, left Node)</span> <span class="title">Node</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">curPrec := r.Precedence()</span><br><span class="line"><span class="keyword">if</span> curPrec &lt; precedence &#123;</span><br><span class="line"><span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br><span class="line">tokenType := r.CurToken.Type</span><br><span class="line">r.NextToken()</span><br><span class="line">right := r.ParseExpr()</span><br><span class="line"><span class="keyword">if</span> right == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> curPrec &lt; r.Precedence() &#123;</span><br><span class="line">right = r.ParseRight(curPrec, right)</span><br><span class="line"><span class="keyword">if</span> right == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">left = &amp;Stmt&#123;</span><br><span class="line">Type:  tokenType,</span><br><span class="line">Left:  left,</span><br><span class="line">Right: right,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Parser)</span> <span class="title">ParseNumber</span><span class="params">()</span> *<span class="title">Number</span></span> &#123;</span><br><span class="line">f, err := strconv.ParseFloat(r.CurToken.Str, <span class="number">64</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Number&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">node := &amp;Number&#123;</span><br><span class="line">Val: f,</span><br><span class="line">&#125;</span><br><span class="line">r.NextToken()</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Parser)</span> <span class="title">Precedence</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> r.CurToken.Type &#123;</span><br><span class="line"><span class="keyword">case</span> enums.ADD, enums.SUB:</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> enums.MUL, enums.QUO:</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看效果：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">lexer := lexer.Lexer&#123;</span><br><span class="line">Formula: <span class="string">"1+2-3*4"</span>,</span><br><span class="line">&#125;</span><br><span class="line">tokens, err := lexer.Lex()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">p := &amp;parser.Parser&#123;</span><br><span class="line">Tokens: tokens,</span><br><span class="line">&#125;</span><br><span class="line">ast, err := p.Parse()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%+v \n"</span>, ast)</span><br><span class="line"><span class="comment">// &#123;Type: 10, Left: &#123;Type: 10, Left: &#123;Type: 9, Val: 1&#125;, Right: &#123;Type: 9, Val: 2&#125;&#125;, Right: &#123;Type: 9, Val: 3&#125;&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>有了AST结构，我们就可以开始进行计算啦～这样一个支持+-*/的小程序就完成了！计算逻辑相对比较简单，这里直接贴代码:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Number)</span> <span class="title">Evaluate</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.Val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元运算类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Stmt)</span> <span class="title">Evaluate</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">left := r.Left.Evaluate()</span><br><span class="line">right := r.Right.Evaluate()</span><br><span class="line"><span class="keyword">switch</span> r.Type &#123;</span><br><span class="line"><span class="keyword">case</span> enums.ADD:</span><br><span class="line"><span class="keyword">return</span> left + right</span><br><span class="line"><span class="keyword">case</span> enums.SUB:</span><br><span class="line"><span class="keyword">return</span> left - right</span><br><span class="line"><span class="keyword">case</span> enums.MUL:</span><br><span class="line"><span class="keyword">return</span> left * right</span><br><span class="line"><span class="keyword">case</span> enums.QUO:</span><br><span class="line"><span class="keyword">if</span> right == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"expr[%g/%g]exception, division by zero \n"</span>, left, right)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left / right</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>附上完整代码：<a href="https://github.com/xupin/example/blob/main/math/main.go" target="_blank" rel="noopener">math/main.go</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;AST（Abstract syntax tree）抽象语法树，用于表示编程语言源代码的一种抽象语法的结构，树的每个节点都对应源代码中的一个结构。&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;计算机如何生成AST结构？一般来说顺序如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;词法分析&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;扫描源代码，生成标记（token）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;语法分析&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;解析tokens，构造AST结构&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="data structures" scheme="http://xupin.im/tags/data-structures/"/>
    
    <category term="algorithms" scheme="http://xupin.im/tags/algorithms/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 - Tire Tree</title>
    <link href="http://xupin.im/2022/12/11/data-structures-algorithms-tire/"/>
    <id>http://xupin.im/2022/12/11/data-structures-algorithms-tire/</id>
    <published>2022-12-10T16:00:00.000Z</published>
    <updated>2022-12-14T08:40:54.390Z</updated>
    
    <content type="html"><![CDATA[<p>Tire树又称单词查找树、前缀树，是一种哈希树变种的树形结构。核心思想是空间换时间，利用字符串的公共前缀来提高查询效率，常常被应用字符统计、检索等场景，比如搜索引擎的词频统计和提示等</p><p><img src="/assets/tire/suggestion.jpeg" alt="drawing" width="400" height="200"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>前缀树的存储原理很简单，即合并字符串相同的字符前缀进行存储。</p><p>比如，存储<code>dog</code>、<code>cat</code>、<code>doing</code>三个字符串的树结构：</p><a id="more"></a><p><img src="/assets/tire/tire.png" width="150" height="250"></p><p>需要注意：<code>前缀树不是二叉树，而是多叉树</code>。</p><p>前缀树的特征：</p><ol><li>根结点不存储任何内容。</li><li>每个节点只存储1个字符。</li><li>根节点到任意子节点是为存储的字符串。</li><li>写入和查询操作的时间复杂度均为O(N)。</li></ol><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>一般可以通过以下两种方式来实现，</p><ol><li>单向链表（本文采用方式）</li><li>二维数组</li></ol><ul><li>存储</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义根结点</span></span><br><span class="line"><span class="keyword">type</span> Tire <span class="keyword">struct</span> &#123;</span><br><span class="line">Root *Node</span><br><span class="line">Size <span class="keyword">int</span> <span class="comment">// 总共存储多少个字符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义存储字符的节点</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">Char   <span class="keyword">string</span>         <span class="comment">// 当前节点存储的字符</span></span><br><span class="line">Count  <span class="keyword">int</span>            <span class="comment">// 出现过多少次</span></span><br><span class="line">IsWord <span class="keyword">bool</span>           <span class="comment">// 是否是完整的单词（字符串结尾）</span></span><br><span class="line">Next   <span class="keyword">map</span>[<span class="keyword">rune</span>]*Node <span class="comment">// 存储下一个字符的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结构可以看出，其实前缀树就是把字符串按字符顺序存储。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Tire)</span> <span class="title">Append</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.Find(s, <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">node := r.Root</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">v, ok := node.Next[c] <span class="comment">// 是否存在该字符，如果不存在则进行存储，反之取下一个字符</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">v = &amp;Node&#123;</span><br><span class="line">Char:   <span class="keyword">string</span>(c),</span><br><span class="line">IsWord: <span class="literal">false</span>,</span><br><span class="line">Count:  <span class="number">1</span>,</span><br><span class="line">Next:   <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">rune</span>]*Node, <span class="number">0</span>),</span><br><span class="line">&#125;</span><br><span class="line">node.Next[c] = v</span><br><span class="line">r.Size += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">v.Count += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">node = v</span><br><span class="line">&#125;</span><br><span class="line">node.IsWord = <span class="literal">true</span> <span class="comment">// 最后一个字符把IsWord标记为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查找</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Tire)</span> <span class="title">Find</span><span class="params">(s <span class="keyword">string</span>, isFullMatch <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">node := r.Root</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">v, ok := node.Next[c] <span class="comment">// 是否存在该字符，如果不存在则直接返回false，反之继续查找下一个字符</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">node = v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (!isFullMatch &amp;&amp; !node.IsWord) || node.IsWord</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><p>删除是前缀树中稍复杂一点的操作，如果字符被其他字符串使用，不能直接删除。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Tire)</span> <span class="title">Remove</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !r.Find(s, <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">node := r.Root</span><br><span class="line">prev := r.Root</span><br><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">node = node.Next[c]</span><br><span class="line">node.Count -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> node.Count == <span class="number">0</span> &#123;</span><br><span class="line">r.Size -= (<span class="built_in">len</span>(s) - i)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">prev = node</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> node.Count == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(prev.Next, <span class="keyword">rune</span>(node.Char[<span class="number">0</span>]))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node.IsWord = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>附上完整代码：<a href="https://github.com/xupin/example/blob/main/tire/main.go" target="_blank" rel="noopener">tire/main.go</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Tire树又称单词查找树、前缀树，是一种哈希树变种的树形结构。核心思想是空间换时间，利用字符串的公共前缀来提高查询效率，常常被应用字符统计、检索等场景，比如搜索引擎的词频统计和提示等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/tire/suggestion.jpeg&quot; alt=&quot;drawing&quot; width=&quot;400&quot; height=&quot;200&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;前缀树的存储原理很简单，即合并字符串相同的字符前缀进行存储。&lt;/p&gt;
&lt;p&gt;比如，存储&lt;code&gt;dog&lt;/code&gt;、&lt;code&gt;cat&lt;/code&gt;、&lt;code&gt;doing&lt;/code&gt;三个字符串的树结构：&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="data structures" scheme="http://xupin.im/tags/data-structures/"/>
    
    <category term="algorithms" scheme="http://xupin.im/tags/algorithms/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 - AOI</title>
    <link href="http://xupin.im/2022/10/08/data-structures-algorithms-aoi/"/>
    <id>http://xupin.im/2022/10/08/data-structures-algorithms-aoi/</id>
    <published>2022-10-07T16:00:00.000Z</published>
    <updated>2022-12-15T04:13:48.976Z</updated>
    
    <content type="html"><![CDATA[<p>AOI（Area Of Interest）翻译过来称为“感兴趣的区域”，用于计算玩家与玩家（或其他Entity）之间彼此进入、离开、移动视野的算法。通俗的解释比如，玩家离开某个地图时，计算出需要通知的其他玩家。</p><p>AOI模块是多人联机游戏服务器中很重要的功能模块之一，AOI模块的“好”与“坏”会很大程度上影响服务器的运行效率。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>当一个玩家进入场景后，首先要计算出场景中的其他所有玩家并放进对象集合（又称观察者集合），之后该玩家的进入、移动、离开或其他AOI行为都将会一一通知该集合内的玩家，并且每个玩家都需要维护这样一个对象集合。</p><blockquote><p>Watchers 观察者集合，即能够看到我的其他玩家或实体。</p></blockquote><p>需要注意的是，<code>该对象集合内的玩家列表会随着玩家的AOI行为发生变化，在玩家离开场景后清空对象集合</code>。</p><a id="more"></a><h3 id="全场景同步"><a href="#全场景同步" class="headerlink" title="全场景同步"></a>全场景同步</h3><p>即每个玩家都能看到进入该场景的所有玩家，那么所有进入该场景的玩家发生AOI行为，AOI场景管理器都会通知其他玩家。比如，我从地图0,0移动至地图10,10这样的行为。</p><ul><li><p>进入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">玩家[pp]进入地图 0,0 </span><br><span class="line">玩家[wl]进入地图 2,20</span><br><span class="line">       通知玩家[pp]进入视野</span><br><span class="line">玩家[sd]进入地图 0,4 </span><br><span class="line">       通知玩家[pp]进入视野</span><br><span class="line">       通知玩家[wl]进入视野</span><br></pre></td></tr></table></figure></li><li><p>移动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">玩家[sd]进行移动 0,4 -&gt; 0,5</span><br><span class="line">       通知玩家[pp]进行移动</span><br><span class="line">       通知玩家[wl]进行移动</span><br></pre></td></tr></table></figure></li><li><p>离开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">玩家[sd]离开地图</span><br><span class="line">       通知玩家[pp]离开地图</span><br><span class="line">       通知玩家[wl]离开地图</span><br></pre></td></tr></table></figure></li></ul><p>但如果地图场景大、玩家数量多的场景下问题就凸显出来，服务器通信量将会十分巨大（玩家与玩家之间）。比如，在一款叫《绝地求生》的游戏中最大的地图是8km*8km，假如两个玩家相距6km，这两个玩家彼此之间还需要通信吗？</p><h3 id="限制玩家视野"><a href="#限制玩家视野" class="headerlink" title="限制玩家视野"></a>限制玩家视野</h3><p>为了提高服务器运行效率，所以需要对玩家的可视范围（视野）进行一定限制，从而减少通信量。即每个玩家都只能看到视野内的其他玩家，当发生行为时也只会同步信息给这些玩家。</p><p>比如，当每个玩家都只有5视野单位时：</p><ul><li><p>进入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">玩家[pp]进入地图 0,0 </span><br><span class="line">玩家[wl]进入地图 2,20</span><br><span class="line">玩家[sd]进入地图 0,4</span><br><span class="line">       通知玩家[pp]进入视野</span><br></pre></td></tr></table></figure></li><li><p>移动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">玩家[sd]进行移动 0,4 -&gt; 1,20</span><br><span class="line">       通知玩家[pp]离开视野</span><br><span class="line">       通知玩家[wl]进入视野</span><br></pre></td></tr></table></figure></li><li><p>离开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">玩家[sd]离开地图</span><br><span class="line">       通知玩家[wl]离开地图</span><br></pre></td></tr></table></figure></li></ul><p>对玩家进行了视野限制后，消息量会大幅下降。但因为会对场景内所有玩家进行暴力查找，所以检索效率并不高。</p><h3 id="网格化"><a href="#网格化" class="headerlink" title="网格化"></a>网格化</h3><p>把玩家视野也进行网格化，类似的优化算法有：九宫格、灯塔、十字链表、六边形等</p><ul><li>九宫格</li></ul><p>把地图网格化后，限制玩家的视野范围为9个格子。如图：</p><p><img src="/assets/aoi/grid9.png" alt="drawing" width="160" height="160"></p><p>一般设计是玩家的手机屏幕显示为4/9格子，但真实视野为1 ～ 9网格，所以服务器只需要同步消息给玩家可视范围内的9个网格其他玩家。</p><ul><li>灯塔</li></ul><p>灯塔是在九宫格的基础上进行优化，在把地图网格化的基础上划分区域（比如4个网格组成一个区域），每个区域有一个管理者：灯塔，这个管理者知晓当前区域的全部玩家。如图：</p><p><img src="/assets/aoi/tower.png" alt="drawing" width="240" height="240"></p><p>每个灯塔维护两个对象集合：Watchers（观察者集合）、Markers（被观察者集合）。</p><ul><li>进入</li></ul><ol><li><p>根据玩家坐标计算出灯塔，把玩家加入到灯塔的Markers。</p></li><li><p>通知该灯塔所有Watchers，有玩家进入场景。</p></li><li><p>找出该玩家视野内所有灯塔，把玩家加入到灯塔的Watchers，同时把这些Watchers和玩家互相加进对方的视野列表。</p></li></ol><ul><li>移动</li></ul><ol><li><p>灯塔无变化，仅通知移动行为给玩家视野列表内的玩家。</p></li><li><p>灯塔有变化，对灯塔列表差集进行交集、并集运算。</p><ol><li>并集，从离开灯塔的Watchers、Markers移除该玩家，新进入灯塔的Watchers、Markers添加该玩家。</li><li>交集，仅通知移动行为。</li></ol></li><li>对移动前后灯塔的Watchers进行交集、并集运算。<ol><li>并集，从离开的Watchers互相从对方的视野列表内移除，新进入的Watchers互相加进对方的视野列表。</li></ol></li></ol><ul><li>离开</li></ul><ol><li><p>根据玩家坐标计算出灯塔，把玩家从该灯塔的Markers中移除。</p></li><li><p>通知该灯塔所有Watchers，有玩家离开场景。</p></li><li><p>找出该玩家视野内所有灯塔，把玩家从这些灯塔的Watchers中移除，同时把该玩家和视野列表内的所有玩家互相把对方从视野列表内移除。</p></li></ol><p><code>十字链表及云风大神提出的六边形场景适用性和实现细节有待商榷，暂时不讨论</code></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>一般设计上灯塔坐标是需要转换的，类似于Redis Cluster的slot机制，通过转换玩家坐标来判断灯塔归属。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Aoi)</span> <span class="title">transPos</span><span class="params">(x, y <span class="keyword">uint</span>)</span> <span class="params">(<span class="keyword">uint</span>, <span class="keyword">uint</span>)</span></span> &#123;</span><br><span class="line">x = <span class="keyword">uint</span>(math.Floor(<span class="keyword">float64</span>(x) / <span class="keyword">float64</span>(r.TowerWidth)))</span><br><span class="line">y = <span class="keyword">uint</span>(math.Floor(<span class="keyword">float64</span>(y) / <span class="keyword">float64</span>(r.TowerHeight)))</span><br><span class="line"><span class="keyword">return</span> x, y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Aoi)</span> <span class="title">getTower</span><span class="params">(x, y <span class="keyword">uint</span>)</span> *<span class="title">Tower</span></span> &#123;</span><br><span class="line">x, y = r.transPos(x, y)</span><br><span class="line">tower, ok := r.Towers[x][y]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"灯塔[异常]不存在的灯塔: %d,%d \n"</span>, x, y)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tower</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码:</p><p><a href="https://github.com/xupin/example/blob/main/aoi/grid/main.go" target="_blank" rel="noopener">grid/main.go</a></p><p><a href="https://github.com/xupin/example/blob/main/aoi/tower/main.go" target="_blank" rel="noopener">tower/main.go</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;AOI（Area Of Interest）翻译过来称为“感兴趣的区域”，用于计算玩家与玩家（或其他Entity）之间彼此进入、离开、移动视野的算法。通俗的解释比如，玩家离开某个地图时，计算出需要通知的其他玩家。&lt;/p&gt;
&lt;p&gt;AOI模块是多人联机游戏服务器中很重要的功能模块之一，AOI模块的“好”与“坏”会很大程度上影响服务器的运行效率。&lt;/p&gt;
&lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h3&gt;&lt;p&gt;当一个玩家进入场景后，首先要计算出场景中的其他所有玩家并放进对象集合（又称观察者集合），之后该玩家的进入、移动、离开或其他AOI行为都将会一一通知该集合内的玩家，并且每个玩家都需要维护这样一个对象集合。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Watchers 观察者集合，即能够看到我的其他玩家或实体。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;该对象集合内的玩家列表会随着玩家的AOI行为发生变化，在玩家离开场景后清空对象集合&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="data structures" scheme="http://xupin.im/tags/data-structures/"/>
    
    <category term="algorithms" scheme="http://xupin.im/tags/algorithms/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 - BitMap</title>
    <link href="http://xupin.im/2022/08/24/data-structures-algorithms-bitmap/"/>
    <id>http://xupin.im/2022/08/24/data-structures-algorithms-bitmap/</id>
    <published>2022-08-23T16:00:00.000Z</published>
    <updated>2022-08-25T12:40:30.084Z</updated>
    
    <content type="html"><![CDATA[<p>BitMap（位图）是一种以bit方式存储数据的数据结构，以此来提高空间利用率。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>BitMap，通过字面意思理解利用bit映射数据的存储结构。所以它应该有Key、Value，Key是bit、Value是要存储的具体的值。核心思想是通过bit来记录数据是否存储：0不存在、1存在。</p><p>定义一个长度为8的bit数组，从0 ～ 7分别映射对应的整型数值。<br><img src="/assets/bitmap/byte.png" alt="drawing" width="400" height="80"></p><p>当整数4存储时，则改变对应bit的状态（值）。<br><img src="/assets/bitmap/byte-4.png" alt="drawing" width="400" height="80"></p><p>这样做带来的好处，同样一个整数在数组中存储需要4byte*8bit=32bit空间，在BitMap中只需要1bit空间。</p><a id="more"></a><h3 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h3><p>定义一个可以存储0 ～ 32的BitMap<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bits := <span class="built_in">make</span>([]<span class="keyword">byte</span>, (<span class="number">32</span>&gt;&gt;<span class="number">3</span>)+<span class="number">1</span>) <span class="comment">// 32 &gt;&gt; 3 等价于 floor(32 / 8)</span></span><br><span class="line"><span class="comment">// fmt.Printf("%08b\n", bits)</span></span><br><span class="line"><span class="comment">// [00000000 00000000 00000000 00000000 00000000]</span></span><br></pre></td></tr></table></figure></p><p>把31存储进BitMap，利用按位或操作改变bit值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bits[<span class="number">31</span>&gt;&gt;<span class="number">3</span>] |= <span class="number">1</span> &lt;&lt; (<span class="number">31</span> % <span class="number">8</span>) </span><br><span class="line"><span class="comment">// 拆解逻辑</span></span><br><span class="line"><span class="comment">// bits[3] = 00000000 | 10000000</span></span><br></pre></td></tr></table></figure></p><p>遇见数据去重，判断31是不是已存在<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bits[<span class="number">31</span>&gt;&gt;<span class="number">3</span>]&amp;<span class="number">1</span>&lt;&lt;(<span class="number">31</span>%<span class="number">8</span>) == <span class="number">0</span> </span><br><span class="line"><span class="comment">// 拆解逻辑</span></span><br><span class="line"><span class="comment">// 10000000 &amp; 10000000</span></span><br></pre></td></tr></table></figure></p><p>从BitMap删除指定数据<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bits[<span class="number">31</span>&gt;&gt;<span class="number">3</span>] &amp;^= <span class="number">1</span> &lt;&lt; (<span class="number">31</span> % <span class="number">8</span>) </span><br><span class="line"><span class="comment">// 拆解逻辑</span></span><br><span class="line"><span class="comment">// 10000000 &amp; 10000000 = 10000000</span></span><br><span class="line"><span class="comment">// 10000000 ^ 10000000 = 00000000</span></span><br></pre></td></tr></table></figure></p><p>完整代码：<a href="https://github.com/xupin/example/blob/main/bitmap/main.go" target="_blank" rel="noopener">bitmap/main.go</a></p><h3 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h3><p>BitMap通过位操作去实现，所以温习以下操作符：</p><ul><li><p>按位与：&amp;</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将操作符左右两侧数值的bit进行对应 &amp;&amp; 运算</span></span><br><span class="line"><span class="number">4</span> &amp; <span class="number">5</span> = <span class="number">4</span></span><br><span class="line"><span class="number">00000100</span> &amp; <span class="number">00000101</span> = <span class="number">00000100</span></span><br></pre></td></tr></table></figure></li><li><p>按位或：|</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将操作符左右两侧数值的bit进行对应 || 运算</span></span><br><span class="line"><span class="number">4</span> | <span class="number">5</span> = <span class="number">5</span></span><br><span class="line"><span class="number">00000100</span> | <span class="number">00000101</span> = <span class="number">00000101</span></span><br></pre></td></tr></table></figure></li><li><p>按位异或：^</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将操作符左右两侧数值的bit进行逻辑预算，规则如下：1 ^ 1 = 0、1 ^ 0 = 1、0 ^ 1 = 1、0 ^ 0 = 0</span></span><br><span class="line"><span class="number">4</span> ^ <span class="number">5</span> = <span class="number">1</span></span><br><span class="line"><span class="number">00000100</span> ^ <span class="number">00000101</span> = <span class="number">00000001</span></span><br></pre></td></tr></table></figure></li><li><p>按位取反：^</p></li></ul><p><code>其他语言一般是 ~，Go语言是 ^</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将操作符右侧数值的bit进行取反，0 -&gt; 1、1 -&gt; 0</span></span><br><span class="line">^<span class="number">4</span> = <span class="number">-5</span></span><br><span class="line">-(<span class="number">00000100</span> + <span class="number">00000001</span>) = <span class="number">-0000101</span> = <span class="number">10000101</span></span><br></pre></td></tr></table></figure><ul><li><p>左移：&lt;&lt;</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将操作符左侧数值的bit按照右侧数值进行左移（溢出位则舍弃）</span></span><br><span class="line"><span class="number">4</span> &lt;&lt; <span class="number">5</span> = <span class="number">128</span></span><br><span class="line">[<span class="number">00000</span>]<span class="number">100</span> &lt;&lt; <span class="number">5</span> = <span class="number">100</span>[<span class="number">00000</span>] <span class="comment">// 左侧舍弃的位在右侧进行补位</span></span><br></pre></td></tr></table></figure></li><li><p>右移：&gt;&gt;<br>和左移同理，只不过方向相反</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;BitMap（位图）是一种以bit方式存储数据的数据结构，以此来提高空间利用率。&lt;/p&gt;
&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;BitMap，通过字面意思理解利用bit映射数据的存储结构。所以它应该有Key、Value，Key是bit、Value是要存储的具体的值。核心思想是通过bit来记录数据是否存储：0不存在、1存在。&lt;/p&gt;
&lt;p&gt;定义一个长度为8的bit数组，从0 ～ 7分别映射对应的整型数值。&lt;br&gt;&lt;img src=&quot;/assets/bitmap/byte.png&quot; alt=&quot;drawing&quot; width=&quot;400&quot; height=&quot;80&quot;&gt;&lt;/p&gt;
&lt;p&gt;当整数4存储时，则改变对应bit的状态（值）。&lt;br&gt;&lt;img src=&quot;/assets/bitmap/byte-4.png&quot; alt=&quot;drawing&quot; width=&quot;400&quot; height=&quot;80&quot;&gt;&lt;/p&gt;
&lt;p&gt;这样做带来的好处，同样一个整数在数组中存储需要4byte*8bit=32bit空间，在BitMap中只需要1bit空间。&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="data structures" scheme="http://xupin.im/tags/data-structures/"/>
    
    <category term="algorithms" scheme="http://xupin.im/tags/algorithms/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 - JPS</title>
    <link href="http://xupin.im/2022/08/12/data-structures-algorithms-jps/"/>
    <id>http://xupin.im/2022/08/12/data-structures-algorithms-jps/</id>
    <published>2022-08-11T16:00:00.000Z</published>
    <updated>2022-12-15T04:13:52.704Z</updated>
    
    <content type="html"><![CDATA[<p>JPS寻路算法是基于A*计算过程中查找节点冗余、效率较低等问题优化的一种算法。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>A*是比较常见的寻路算法，但存在一个较为明显的问题，当移动到新的节点总是会把相邻节点（4、8）加入到待查找列表。这样带来两个问题</p><ol><li><p>在多条移动路径成本相同时，冗余查找。</p></li><li><p>待查找节点过多，内存使用率过高。</p></li></ol><a id="more"></a><h3 id="JPS"><a href="#JPS" class="headerlink" title="JPS"></a>JPS</h3><p>JPS全称“Jump search point”，又称“跳点搜索”、“拐点搜索”，由两位澳大利亚教授2011年提出（<a href="https://ojs.aaai.org/index.php/AAAI/article/view/7994" target="_blank" rel="noopener">论文</a>）。</p><p>JPS寻路算法保留A*的主体逻辑，不一样的是JPS只会把感兴趣的节点加入到待查找列表，怎样计算出感兴趣的节点呢？以下2个概念眼熟一下</p><ol><li><p>强迫邻居</p></li><li><p>跳点（拐点）</p></li></ol><p>通过有没有强迫邻居判断当前节点是否跳点，也就是感兴趣的节点。</p><h3 id="强迫邻居"><a href="#强迫邻居" class="headerlink" title="强迫邻居"></a>强迫邻居</h3><p>强迫邻居的定义：</p><blockquote><p>节点 x 的8个邻居中有障碍，且 x 的父节点 p 经过x 到达 n 的距离代价比不经过 x 到达的 n 的任意路径的距离代价小，则称 n 是 x 的强迫邻居。</p></blockquote><p>允许对角移动的情况下，检索方向强迫邻居节点的方式分为3种：对角、垂直、水平。</p><ul><li>对角移动 </li></ul><p><img src="/assets/jps/forced-neighbour/diagonal.jpg" alt="drawing" width="300" height="300"></p><ul><li>垂直移动</li></ul><p><img src="/assets/jps/forced-neighbour/vertical.jpg" alt="drawing" width="300" height="300"></p><ol><li>水平移动</li></ol><p><img src="/assets/jps/forced-neighbour/horizontal.jpg" alt="drawing" width="300" height="300"></p><p>绿色是<code>父节点</code>，红色是<code>障碍物</code>，x是<code>当前节点</code>，n是<code>强迫邻居</code>。</p><p>通俗的解释就是，在指定移动方向上“强迫”当前节点改变移动方向的节点就是当前节点的强迫邻居，同时当前节点也是跳点，跳点和强迫邻居都相邻障碍节点。</p><h3 id="跳点（拐点）"><a href="#跳点（拐点）" class="headerlink" title="跳点（拐点）"></a>跳点（拐点）</h3><p>知道如果有强迫邻居改变当前节点移动方向，那么当前节点就被视为跳点，这是判断跳点的条件之一。判断当前节点是否跳点的任一条件：</p><ol><li><p>当前节点是起点或终点。</p></li><li><p>当前节点拥有强迫邻居。</p></li><li><p>如果移动方向是对角移动，当前节点的垂直、水平方向上的节点满足条件1或条件2，当前节点一样被视为跳点。</p></li></ol><p>条件3可能有些难理解，示意图:</p><p><img src="/assets/jps/jump-point.jpg" alt="drawing" width="400" height="250"></p><p>黄色网格1、2、3都是<code>跳点</code>，网格1因为满足“当前节点的垂直、水平方向上的节点满足条件1或条件2，当前节点一样被视为跳点”条件（网格2是跳点），所以也是跳点。</p><h3 id="寻路思路"><a href="#寻路思路" class="headerlink" title="寻路思路"></a>寻路思路</h3><ol><li><p>把起点放进待查找节点列表。</p></li><li><p>从待查找节点列表里面取出一个，判断该节点是否是终点，如果不是则查找该节点的相邻节点。</p></li><li><p>遍历相邻节点，判断节点是否已查找过，否则对相邻节点进行跳点查找并对跳点进行估价，同时把当前节点设为跳点到父节点，如果跳点是终点则返回，否则把跳点加入到待查找节点列表。</p></li><li><p>对待查找节点列表按 <code>f</code> 值进行排序，取最小值。重复2、3、4步骤，直至找到终点坐标（最终的跳点）。</p></li></ol><p>完整的寻路过程：</p><p><img src="/assets/jps/full.jpg" alt="drawing" width="400" height="250"></p><p>以上寻路过程，JPS和A*寻路过程的区别在于跳点查找：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳点函数</span></span><br><span class="line"><span class="comment">// 判断当前点是否满足跳点条件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Jps)</span> <span class="title">jump</span><span class="params">(node, parent *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line"><span class="comment">// 是终点，直接返回</span></span><br><span class="line"><span class="keyword">if</span> r.isEnd(node) &#123;</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line">x, y := node.X, node.Y</span><br><span class="line">dx, dy := r.direction(node, parent)</span><br><span class="line"><span class="comment">// 对角移动</span></span><br><span class="line"><span class="keyword">if</span> dx != <span class="number">0</span> &amp;&amp; dy != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// [左|右]不能走 &amp;&amp; [左上|左下|右上|右下]能走</span></span><br><span class="line"><span class="keyword">if</span> !r.isWalkable(x-dx, y) &amp;&amp; r.isWalkable(x-dx, y+dy) &#123;</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [上|下]不能走 &amp;&amp; [左上|右上|左下|右下]能走</span></span><br><span class="line"><span class="keyword">if</span> !r.isWalkable(x, y-dy) &amp;&amp; r.isWalkable(x+dx, y-dy) &#123;</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归查找方向[上|下]继续查找</span></span><br><span class="line"><span class="keyword">if</span> r.isWalkable(x+dx, y) &amp;&amp; r.jump(r.nodes[x+dx][y], node) != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归查找方向[左|右]继续查找</span></span><br><span class="line"><span class="keyword">if</span> r.isWalkable(x, y+dy) &amp;&amp; r.jump(r.nodes[x][y+dy], node) != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> dx == <span class="number">0</span> &#123; <span class="comment">// 垂直移动</span></span><br><span class="line"><span class="comment">// 右不能走 &amp;&amp; [右下|右上]能走</span></span><br><span class="line"><span class="keyword">if</span> !r.isWalkable(x+<span class="number">1</span>, y) &amp;&amp; r.isWalkable(x+<span class="number">1</span>, y+dy) &#123;</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左不能走 &amp;&amp; [左上|左下]能走</span></span><br><span class="line"><span class="keyword">if</span> !r.isWalkable(x<span class="number">-1</span>, y) &amp;&amp; r.isWalkable(x<span class="number">-1</span>, y+dy) &#123;</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 水平移动</span></span><br><span class="line"><span class="comment">// 下不能走 &amp;&amp; [左下|右下]能走</span></span><br><span class="line"><span class="keyword">if</span> !r.isWalkable(x, y+<span class="number">1</span>) &amp;&amp; r.isWalkable(x+dx, y+<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上不能走 &amp;&amp; [左上|右上]能走</span></span><br><span class="line"><span class="keyword">if</span> !r.isWalkable(x, y<span class="number">-1</span>) &amp;&amp; r.isWalkable(x+dx, y<span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归查找方向[左上|左下|右上|右下]继续查找</span></span><br><span class="line"><span class="keyword">if</span> r.isWalkable(x+dx, y+dy) &#123;</span><br><span class="line"><span class="keyword">if</span> next := r.jump(r.nodes[x+dx][y+dy], node); next != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无强迫邻居（当前节点不是跳点）或到达边界</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同时，为了减少查找不必要的节点，查找相邻节点的函数也有优化<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找相邻节点位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Jps)</span> <span class="title">findNeighbors</span><span class="params">(node *Node)</span> []*<span class="title">Node</span></span> &#123;</span><br><span class="line">neighbors := <span class="built_in">make</span>([]*Node, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 第一次移动</span></span><br><span class="line"><span class="keyword">if</span> node.Parent == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> r.neighborPos &#123;</span><br><span class="line">x, y := node.X+v[<span class="number">0</span>], node.Y+v[<span class="number">1</span>]</span><br><span class="line"><span class="comment">// 检测节点是否非法</span></span><br><span class="line"><span class="keyword">if</span> !r.isWalkable(x, y) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">neighbors = <span class="built_in">append</span>(neighbors, r.nodes[x][y])</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 计算当前节点位于父节点的方向：水平、垂直和对角方向</span></span><br><span class="line">x, y := node.X, node.Y</span><br><span class="line">dx, dy := r.direction(node, node.Parent)</span><br><span class="line"><span class="comment">// 移动方向上的下一个</span></span><br><span class="line"><span class="keyword">if</span> r.isWalkable(x+dx, y+dy) &#123;</span><br><span class="line">neighbors = <span class="built_in">append</span>(neighbors, r.nodes[x+dx][y+dy])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对角移动</span></span><br><span class="line"><span class="keyword">if</span> dx != <span class="number">0</span> &amp;&amp; dy != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// [左|右]能走</span></span><br><span class="line"><span class="keyword">if</span> r.isWalkable(x+dx, y) &#123;</span><br><span class="line">neighbors = <span class="built_in">append</span>(neighbors, r.nodes[x+dx][y])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [上|下]能走</span></span><br><span class="line"><span class="keyword">if</span> r.isWalkable(x, y+dy) &#123;</span><br><span class="line">neighbors = <span class="built_in">append</span>(neighbors, r.nodes[x][y+dy])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [左|右]不能走 &amp;&amp; [左上|左下|右上|右下]能走</span></span><br><span class="line"><span class="keyword">if</span> !r.isWalkable(x-dx, y) &amp;&amp; r.isWalkable(x-dx, y+dy) &#123;</span><br><span class="line">neighbors = <span class="built_in">append</span>(neighbors, r.nodes[x-dx][y+dy])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [上|下]不能走 &amp;&amp; [左上|右上|左下|右下]能走</span></span><br><span class="line"><span class="keyword">if</span> !r.isWalkable(x, y-dy) &amp;&amp; r.isWalkable(x+dx, y-dy) &#123;</span><br><span class="line">neighbors = <span class="built_in">append</span>(neighbors, r.nodes[x+dx][y-dy])</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> dx == <span class="number">0</span> &#123; <span class="comment">// 垂直移动</span></span><br><span class="line"><span class="comment">// 右不能走 &amp;&amp; [右下|右上]能走</span></span><br><span class="line"><span class="keyword">if</span> !r.isWalkable(x+<span class="number">1</span>, y) &amp;&amp; r.isWalkable(x+<span class="number">1</span>, y+dy) &#123;</span><br><span class="line">neighbors = <span class="built_in">append</span>(neighbors, r.nodes[x+<span class="number">1</span>][y+dy])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左不能走 &amp;&amp; [左上|左下]能走</span></span><br><span class="line"><span class="keyword">if</span> !r.isWalkable(x<span class="number">-1</span>, y) &amp;&amp; r.isWalkable(x<span class="number">-1</span>, y+dy) &#123;</span><br><span class="line">neighbors = <span class="built_in">append</span>(neighbors, r.nodes[x<span class="number">-1</span>][y+dy])</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 水平移动</span></span><br><span class="line"><span class="comment">// 下不能走 &amp;&amp; [左下|右下]能走</span></span><br><span class="line"><span class="keyword">if</span> !r.isWalkable(x, y+<span class="number">1</span>) &amp;&amp; r.isWalkable(x+dx, y+<span class="number">1</span>) &#123;</span><br><span class="line">neighbors = <span class="built_in">append</span>(neighbors, r.nodes[x+dx][y+<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上不能走 &amp;&amp; [左上|右上]能走</span></span><br><span class="line"><span class="keyword">if</span> !r.isWalkable(x, y<span class="number">-1</span>) &amp;&amp; r.isWalkable(x+dx, y<span class="number">-1</span>) &#123;</span><br><span class="line">neighbors = <span class="built_in">append</span>(neighbors, r.nodes[x+dx][y<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> neighbors</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>完整代码：<a href="https://github.com/xupin/example/blob/main/jps/main.go" target="_blank" rel="noopener">jps/main.go</a></p><h3 id="关于其他优化点"><a href="#关于其他优化点" class="headerlink" title="关于其他优化点"></a>关于其他优化点</h3><p>有很多值得优化的细节，</p><ol><li><p>因为是网格寻路，客户端角色走路会出现拐直角的表现（平滑路径，比如：弗洛伊德算法）。</p></li><li><p>待查找节点列表可以用二叉堆实现，插入和弹出效率都很高。</p></li><li><p>地图节点使用数组存储，检索效率较高。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;JPS寻路算法是基于A*计算过程中查找节点冗余、效率较低等问题优化的一种算法。&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;A*是比较常见的寻路算法，但存在一个较为明显的问题，当移动到新的节点总是会把相邻节点（4、8）加入到待查找列表。这样带来两个问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在多条移动路径成本相同时，冗余查找。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;待查找节点过多，内存使用率过高。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="data structures" scheme="http://xupin.im/tags/data-structures/"/>
    
    <category term="algorithms" scheme="http://xupin.im/tags/algorithms/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 - AStar(A*)</title>
    <link href="http://xupin.im/2022/08/01/data-structures-algorithms-astar/"/>
    <id>http://xupin.im/2022/08/01/data-structures-algorithms-astar/</id>
    <published>2022-07-31T16:00:00.000Z</published>
    <updated>2022-12-15T04:13:50.907Z</updated>
    
    <content type="html"><![CDATA[<p>寻路算法是游戏比较重要的组成部分之一，尤其在国内游戏很常见的自动寻路系统，比如操纵角色从A点到B点的移动。计算最短路径有很多不同的算法，比如：Dijkstra、AStar（A*）、NavMesh（多边形算法）、RVO动态避障等等</p><h3 id="A-寻路算法"><a href="#A-寻路算法" class="headerlink" title="A*寻路算法"></a>A*寻路算法</h3><p>寻路算法的移动路径核心有2点：最短、可移动。</p><p>所以首先需要确定起点坐标的相邻节点（4方向、8方向），然后通过计算最靠近终点坐标的相邻坐标（不考虑障碍物）确认检索方向，再去计算“相邻坐标”移动的下一个坐标（距离终点坐标最近 &amp; 可移动），重复计算这个过程直至找到终点坐标，这就是A*算法</p><p>A*算法是一类基于网格的寻路算法，也就是把地图看作一个由网格组成的矩阵，每个坐标就是一个网格。</p><p>一张3x3地图</p><a id="more"></a><p><img src="/assets/astar/grid.png" alt="drawing" width="90" height="90"></p><h3 id="启发函数"><a href="#启发函数" class="headerlink" title="启发函数"></a>启发函数</h3><p>从起点移动到终点坐标可能会产生多条移动路径，所以还需要计算出哪条移动路径最短，不然越走越远就演变成《论述如何帮助玩家刷微信步数》的尴尬情况。</p><p>在网格地图中肯定是经过越少的网格路径就越短，但我们不可能把每条可能的路径都走一遍再选出哪条路径最短，所以需要进行评估接下来走哪个网格最近。</p><p>假设我们把网格直线（水平、垂直）移动成本设为1、对角移动成本设为：1.4。然后把移动路径上的坐标的成本进行相加取出最小值即可能是当前最佳移动路径。</p><p>这也叫启发式算法，即优先检索可能是成本最低的网格。</p><h3 id="估价公式"><a href="#估价公式" class="headerlink" title="估价公式"></a>估价公式</h3><p>我们不可能把每条可能的路径都走一遍，所以通过估价公式：<code>f = g + h</code>，来评估接下来走哪一个网格。</p><ul><li>g</li></ul><blockquote><p>从起点坐标移动到当前坐标的移动成本（网格数）</p></blockquote><ul><li>h</li></ul><blockquote><p>从当前坐标移动到终点坐标的移动成本</p></blockquote><ul><li>f</li></ul><blockquote><p>当前坐标的移动成本</p></blockquote><p>通过这样一个网格移动成本的评估公式，可以大概计算出从起点网格移动至终点网格的路径中，下一步走哪一个网格可能路径最短。</p><h3 id="移动成本"><a href="#移动成本" class="headerlink" title="移动成本"></a>移动成本</h3><p>怎么计算移动成本？使用距离算法作为估价函数对网格进行估价。比如以下的距离算法（不仅限于）：</p><ol><li>欧氏距离</li><li>曼哈顿距离</li><li>切比雪夫距离</li><li>45度角计算（Octile）</li></ol><p>不同的距离算法在不同的场景上表现不一，比如说在静态网格地图场景中</p><ul><li><a href="https://zh.wikipedia.org/wiki/欧几里得距离" target="_blank" rel="noopener">欧氏距离</a></li></ul><p>优点：</p><blockquote><p>计算直线距离，移动路径最短。</p></blockquote><p>缺点：</p><blockquote><p>计算过程中伴随着平方与开根号运算，并且需要使用浮点数，性能差。</p><p>因为是网格所以基本不能按照直线进行移动，精确度不够。</p></blockquote><ul><li><a href="https://zh.wikipedia.org/wiki/曼哈顿距离" target="_blank" rel="noopener">曼哈顿距离</a></li></ul><p>优点：</p><blockquote><p>计算过程不存在浮点数，性能较高。</p></blockquote><p>缺点：</p><blockquote><p>只可以垂直或者水平移动。</p></blockquote><p>所以在对4方向、8方向又或者6方向上的算法选择是不一样的。比如4方向移动<code>上下左右</code>使用曼哈顿距离来进行估价就完全足够，但如果是8方向移动就不可以（可以对角移动）。</p><p>所以，如果是8方向移动的场景通常会采用曼哈顿+对角计算的距离算法。</p><h3 id="寻路思路"><a href="#寻路思路" class="headerlink" title="寻路思路"></a>寻路思路</h3><p>示例：3x3 &amp; 无障碍的地图</p><p><img src="/assets/astar/3x3.png" alt="drawing" width="300" height="300"></p><p>绿色是<code>起点</code>，蓝色是<code>终点</code></p><ol><li><p>把起点放进待查找节点列表。</p></li><li><p>从待查找节点列表里面取出一个，判断该节点是否是终点，如果不是则查找该节点的相邻节点，找到3个节点分别是右、右下、下。</p></li><li><p>遍历相邻节点，判断节点是否已查找过，否则对3个相邻节点的进行估价（因为使用曼哈顿算法所以把浮点数放大<code>10倍</code>），并把绿色节点设为3个相邻节点的父节点，如果某一相邻节点是终点则返回，否则把相邻节点加入到待查找节点列表。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 右</span><br><span class="line">    起点距离该节点水平移动一个网格，所以g = <span class="number">10</span>。该节点到终点对角移动一个网格，所以h = <span class="number">14</span>。最终该节点的移动成本：<span class="number">14</span>（f = g + h ）。</span><br><span class="line"><span class="number">2.</span> 右下</span><br><span class="line">    起点距离该节点对角移动一个网格，所以g = <span class="number">14</span>。该节点到终点垂直移动一个网格，所以h = <span class="number">10</span>。最终该节点的移动成本：<span class="number">14</span>（f = g + h ）。</span><br><span class="line"><span class="number">3.</span> 下</span><br><span class="line">    起点距离该节点垂直移动一个网格，所以g = <span class="number">10</span>。该节点到终点水平移动两个网格，所以h = <span class="number">20</span>。最终该节点的移动成本：<span class="number">30</span>（f = g + h ）。</span><br></pre></td></tr></table></figure></li><li><p>对待查找节点列表按 <code>f</code> 值进行排序，取最小值。重复2、3、4步骤，直至找到终点坐标。</p></li></ol><h3 id="代码实现（附上完整代码）"><a href="#代码实现（附上完整代码）" class="headerlink" title="代码实现（附上完整代码）"></a>代码实现（附上完整代码）</h3><p>首先最基础的是把地图进行网格化。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">地图从左上角开始，水平x 垂直y</span></span><br><span class="line"><span class="comment">  y</span></span><br><span class="line"><span class="comment">x 0,0 1,0 2,0</span></span><br><span class="line"><span class="comment">  0,1 1,1 2,1</span></span><br><span class="line"><span class="comment">  0,2 1,2 2,2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 0是可移动节点、1是障碍节点</span></span><br><span class="line">mapData := [][]<span class="keyword">int</span>&#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个节点（网格）对应一个坐标，因为估价需要同时每个节点还存储着f、g、h值。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 坐标</span></span><br><span class="line">X <span class="keyword">int</span></span><br><span class="line">Y <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 成本</span></span><br><span class="line">F <span class="keyword">int</span></span><br><span class="line">G <span class="keyword">int</span></span><br><span class="line">H <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 父节点</span></span><br><span class="line">Parent *Node</span><br><span class="line"><span class="comment">// 类型</span></span><br><span class="line">Type <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 状态</span></span><br><span class="line">State <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有了节点，那么还需要定义每个节点有哪些邻居（这里是8方向）<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不允许对角移动，去除对角坐标</span></span><br><span class="line">neighborPos = [][]<span class="keyword">int</span>&#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,  <span class="comment">// 上</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;,  <span class="comment">// 右上</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,   <span class="comment">// 右</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,   <span class="comment">// 右下</span></span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,   <span class="comment">// 下</span></span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;,  <span class="comment">// 左下</span></span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;,  <span class="comment">// 左</span></span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;, <span class="comment">// 左上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>并不是所有节点都需要查找，所以还需要定义待查找节点列表、已查找节点列表（已查找过的节点会被忽略）。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> openList, closeList []*Node</span><br></pre></td></tr></table></figure></p><p>最后，查找节点的逻辑（这里偷懒，直接贴上封装过的逻辑）<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AStar <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 启发算法</span></span><br><span class="line">Heuristic <span class="function"><span class="keyword">func</span><span class="params">(node, end *Node)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 地图大小</span></span><br><span class="line">Rows <span class="keyword">int</span> <span class="comment">// y</span></span><br><span class="line">Cols <span class="keyword">int</span> <span class="comment">// x</span></span><br><span class="line"><span class="comment">// 地图节点</span></span><br><span class="line">nodes [][]*Node</span><br><span class="line">start *Node</span><br><span class="line">end   *Node</span><br><span class="line"><span class="comment">// 开放、关闭列表</span></span><br><span class="line">openList  []*Node</span><br><span class="line">closeList []*Node</span><br><span class="line"><span class="comment">// 相邻节点坐标</span></span><br><span class="line">neighborPos [][]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *AStar)</span> <span class="title">FindPath</span><span class="params">(start, end *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">r.start = r.nodes[start.X][start.Y]</span><br><span class="line">r.end = r.nodes[end.X][end.Y]</span><br><span class="line"><span class="comment">// 如果起止点是障碍物</span></span><br><span class="line"><span class="keyword">if</span> !r.start.isWalkable() || !r.end.isWalkable() &#123;</span><br><span class="line">fmt.Println(<span class="string">"障碍物不可移动"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先把开始节点放进开放列表</span></span><br><span class="line">r.openListAppend(start)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(r.openList) &gt; <span class="number">0</span> &#123;</span><br><span class="line">node := r.openListPop()</span><br><span class="line"><span class="comment">// 判断当前节点是否是终点</span></span><br><span class="line"><span class="keyword">if</span> r.isEnd(node) &#123;</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找开放列表的第一个节点的相邻节点</span></span><br><span class="line">neighbors := r.findNeighbors(node)</span><br><span class="line"><span class="keyword">for</span> _, neighbor := <span class="keyword">range</span> neighbors &#123;</span><br><span class="line"><span class="comment">// 是否在关闭列表</span></span><br><span class="line"><span class="keyword">if</span> neighbor.isClosed() &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开始节点移动至当前节点的成本</span></span><br><span class="line"><span class="comment">// 相邻节点的坐标x,y</span></span><br><span class="line"><span class="comment">// 开始节点移动至相邻节点的成本</span></span><br><span class="line">g, x, y := node.G, neighbor.X, neighbor.Y</span><br><span class="line"><span class="comment">// 判断移动方式是水平（或垂直）、对角，计算成本</span></span><br><span class="line"><span class="keyword">if</span> x == node.X || y == node.Y &#123;</span><br><span class="line">g += COST_STRAIGHT</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">g += COST_DIAGONAL</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !neighbor.isOpened() || g &lt; neighbor.G &#123;</span><br><span class="line">neighbor.G = g</span><br><span class="line">neighbor.H = r.Heuristic(neighbor, end)</span><br><span class="line">neighbor.F = neighbor.G + neighbor.H</span><br><span class="line">neighbor.Parent = node</span><br><span class="line"><span class="comment">// 优化逻辑，相邻节点是否是终点</span></span><br><span class="line"><span class="comment">// if r.isEnd(neighbor) &#123;</span></span><br><span class="line"><span class="comment">// return neighbor</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">if</span> !neighbor.isOpened() &#123;</span><br><span class="line">r.openListAppend(neighbor)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前节点放进关闭列表</span></span><br><span class="line">r.closeListAppend(node)</span><br><span class="line"><span class="comment">// 更新开放列表顺序</span></span><br><span class="line">r.openListSort()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为什么要给节点定义父节点？</p><blockquote><p>这里使用链表记录移动路径，即通过终点节点不断迭代父节点打印出完整路径。</p></blockquote><p>完整代码：<a href="https://github.com/xupin/example/blob/main/astar/main.go" target="_blank" rel="noopener">astar/main.go</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;寻路算法是游戏比较重要的组成部分之一，尤其在国内游戏很常见的自动寻路系统，比如操纵角色从A点到B点的移动。计算最短路径有很多不同的算法，比如：Dijkstra、AStar（A*）、NavMesh（多边形算法）、RVO动态避障等等&lt;/p&gt;
&lt;h3 id=&quot;A-寻路算法&quot;&gt;&lt;a href=&quot;#A-寻路算法&quot; class=&quot;headerlink&quot; title=&quot;A*寻路算法&quot;&gt;&lt;/a&gt;A*寻路算法&lt;/h3&gt;&lt;p&gt;寻路算法的移动路径核心有2点：最短、可移动。&lt;/p&gt;
&lt;p&gt;所以首先需要确定起点坐标的相邻节点（4方向、8方向），然后通过计算最靠近终点坐标的相邻坐标（不考虑障碍物）确认检索方向，再去计算“相邻坐标”移动的下一个坐标（距离终点坐标最近 &amp;amp; 可移动），重复计算这个过程直至找到终点坐标，这就是A*算法&lt;/p&gt;
&lt;p&gt;A*算法是一类基于网格的寻路算法，也就是把地图看作一个由网格组成的矩阵，每个坐标就是一个网格。&lt;/p&gt;
&lt;p&gt;一张3x3地图&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="data structures" scheme="http://xupin.im/tags/data-structures/"/>
    
    <category term="algorithms" scheme="http://xupin.im/tags/algorithms/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 - Linked list</title>
    <link href="http://xupin.im/2022/07/19/data-structures-algorithms-linked-list/"/>
    <id>http://xupin.im/2022/07/19/data-structures-algorithms-linked-list/</id>
    <published>2022-07-18T16:00:00.000Z</published>
    <updated>2022-12-15T04:17:53.810Z</updated>
    
    <content type="html"><![CDATA[<p>链表是一种不需要连续空间存储的线性数据结构，通过指针把数据节点链接起来。数据节点的逻辑顺序取决于链表指针链接的先后顺序，同时，链表也有：单链表、双链表、循环链表等多类。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>链表是由一系列节点组成，除此之外链表还有几个基本概念：</p><ul><li>数据节点<blockquote><p>一般由两块组成：数据域、指针域。</p></blockquote></li><li>首元节点<blockquote><p>链表的第一个数据节点。</p></blockquote></li><li>头节点<blockquote><p>非必要节点，放在第一个数据节点前。一般用于存储链表的信息（比如说链表长度等）和保证数据节点操作的统一性。</p></blockquote></li><li>头指针<blockquote><p>指向第一个节点的指针，如果有头节点则指向头节点，否则指向首元节点。</p></blockquote></li></ul><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>最简单的一种链表，只支持一个遍历方向：链头 -&gt; 链尾。两部分组成：当前节点的数据、指向后置节点的指针（尾节点指针指向nil）。</p><a id="more"></a><p>例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">V    <span class="keyword">string</span></span><br><span class="line">Next *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 头节点</span></span><br><span class="line">head := &amp;Node&#123;</span><br><span class="line">V: <span class="string">"head node"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点1</span></span><br><span class="line">node := &amp;Node&#123;</span><br><span class="line">V: <span class="string">"node1"</span>,</span><br><span class="line">&#125;</span><br><span class="line">head.Next = node</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点2</span></span><br><span class="line">node2 := &amp;Node&#123;</span><br><span class="line">V: <span class="string">"node2"</span>,</span><br><span class="line">&#125;</span><br><span class="line">node.Next = node2</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点3</span></span><br><span class="line">node3 := &amp;Node&#123;</span><br><span class="line">V: <span class="string">"node3"</span>,</span><br><span class="line">&#125;</span><br><span class="line">node2.Next = node3</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头指针 -&gt; 头节点</span></span><br><span class="line">linkedList := head</span><br><span class="line"><span class="keyword">for</span> linkedList.Next != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 打印下一个节点值（这块就体现出头节点的好处，首元节点和其他数据节点的操作一致）</span></span><br><span class="line">fmt.Println(linkedList.Next.V)</span><br><span class="line">linkedList = linkedList.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上是单链表的简单实现，其中添加节点的操作也被称为：<code>尾插法</code>，封装一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">V    <span class="keyword">string</span></span><br><span class="line">Next *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">Head *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">list := &amp;List&#123;&#125;</span><br><span class="line">n1 := &amp;Node&#123;V: <span class="string">"node1"</span>&#125;</span><br><span class="line">n2 := &amp;Node&#123;V: <span class="string">"node2"</span>&#125;</span><br><span class="line">n3 := &amp;Node&#123;V: <span class="string">"node3"</span>&#125;</span><br><span class="line">list.Append(n1)</span><br><span class="line">list.Append(n2)</span><br><span class="line">list.Append(n3)</span><br><span class="line">list.Traverse() <span class="comment">// 输出结果：node1-&gt;node2-&gt;node3-&gt;nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾插法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">Append</span><span class="params">(node *Node)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> l.Head == <span class="literal">nil</span> &#123;</span><br><span class="line">l.Head = node</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">now := l.Head</span><br><span class="line"><span class="keyword">for</span> now.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">now = now.Next</span><br><span class="line">&#125;</span><br><span class="line">now.Next = node</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">Traverse</span><span class="params">()</span></span> &#123;</span><br><span class="line">now := l.Head</span><br><span class="line"><span class="keyword">for</span> now != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> now.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(now.V, <span class="string">"-&gt;"</span>, <span class="string">"nil"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(now.V, <span class="string">"-&gt;"</span>)</span><br><span class="line">&#125;</span><br><span class="line">now = now.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有数据节点想要插队，怎么办？<code>头插法</code>，思路就是：把头节点作为新增节点的后置节点，新增节点作为新的头节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">Insert</span><span class="params">(node *Node)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> l.Head == <span class="literal">nil</span> &#123;</span><br><span class="line">l.Head = node</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node.Next = l.Head</span><br><span class="line">l.Head = node</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还想把链表反转，数据节点逆序呢？有很多种方式，比如：利用双指针迭代、递归等等</p><p>迭代，思路和头插法一致。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">Reverse</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> l.Head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明一个头节点</span></span><br><span class="line"><span class="keyword">var</span> head *Node</span><br><span class="line"><span class="comment">// 开始遍历链表，</span></span><br><span class="line"><span class="comment">// 第一次，head：node1 -&gt; nil</span></span><br><span class="line"><span class="comment">// 第一次，now：node2 -&gt; node3 -&gt; nil</span></span><br><span class="line"><span class="comment">// 第二次，head：node2 -&gt; node1 -&gt; nil</span></span><br><span class="line"><span class="comment">// 第二次，now：node3 -&gt; nil</span></span><br><span class="line"><span class="comment">// 第三次，head：node3 -&gt; node2 -&gt; node1 -&gt; nil</span></span><br><span class="line"><span class="comment">// 第三次，now：nil</span></span><br><span class="line">now := l.Head</span><br><span class="line"><span class="keyword">for</span> now != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 记录当前节点的后置节点</span></span><br><span class="line">next := now.Next</span><br><span class="line"><span class="comment">// 当前节点的后置节点变为头节点，当前节点变为新的头节点。这个操作和插入节点的逻辑一致，把头节点作为当前节点的后置节点，当前节点作为新的头节点。</span></span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">now.Next = <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">now.Next = head</span><br><span class="line">&#125;</span><br><span class="line">head = now</span><br><span class="line"><span class="comment">// 指针后移</span></span><br><span class="line">now = next</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法糖版本</span></span><br><span class="line"><span class="comment">// now, now.Next, head = now.Next, head, now // 语法糖版本，拆解如下</span></span><br><span class="line"><span class="comment">// now = now.Next</span></span><br><span class="line"><span class="comment">// now.Next = head</span></span><br><span class="line"><span class="comment">// head = now</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// printNode(head)</span></span><br><span class="line"><span class="comment">// printNode(now)</span></span><br><span class="line">&#125;</span><br><span class="line">l.Head = head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNode</span><span class="params">(node *Node)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"nil"</span>)</span><br><span class="line">&#125;</span><br><span class="line">now := node</span><br><span class="line"><span class="keyword">for</span> now != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> now.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(now.V, <span class="string">"-&gt;"</span>, <span class="string">"nil"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(now.V, <span class="string">"-&gt;"</span>)</span><br><span class="line">&#125;</span><br><span class="line">now = now.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>删除操作:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">Delete</span><span class="params">(node *Node)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> l.Head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果是尾节点，则需要找出删除节点的前置节点</span></span><br><span class="line"><span class="keyword">if</span> node.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">prev := l.Head</span><br><span class="line"><span class="keyword">for</span> prev.Next != node &#123;</span><br><span class="line">prev = prev.Next</span><br><span class="line">&#125;</span><br><span class="line">prev.Next = <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果不是尾节点，把删除节点的后置节点数据直接覆盖删除节点。</span></span><br><span class="line">*node = *node.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>单链表的实现比较简单，可以很轻松的查询到指定节点的后置节点，但如果想要查询前置节点则需要遍历一遍才可以，所以这就需要<code>双链表</code>了</p><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>双链表通俗的讲，就是每个数据节点既可以找到它前一个节点也找的到它后一个节点。三部分组成：前值节点的指针，节点数据，后置节点的指针（尾节点指针指向nil）。</p><p>直接上代码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">V    <span class="keyword">string</span></span><br><span class="line">Prev *Node</span><br><span class="line">Next *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">Head *Node</span><br><span class="line">Tail *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">list := &amp;List&#123;&#125;</span><br><span class="line">n1 := &amp;Node&#123;V: <span class="string">"node1"</span>&#125;</span><br><span class="line">n2 := &amp;Node&#123;V: <span class="string">"node2"</span>&#125;</span><br><span class="line">n3 := &amp;Node&#123;V: <span class="string">"node3"</span>&#125;</span><br><span class="line">list.Append(n1)</span><br><span class="line">list.Append(n2)</span><br><span class="line">list.Append(n3)</span><br><span class="line">list.Traverse() <span class="comment">// 输出结果：node1&lt;-&gt;node2&lt;-&gt;node3-&gt;nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">Append</span><span class="params">(node *Node)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> l.Head == <span class="literal">nil</span> &#123;</span><br><span class="line">l.Head = node</span><br><span class="line">l.Tail = node</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 尾节点</span></span><br><span class="line">prev := l.Tail</span><br><span class="line"><span class="comment">// 尾节点设为当前节点的前置节点</span></span><br><span class="line">node.Prev = prev</span><br><span class="line"><span class="comment">// 当前节点设为尾节点的后置节点</span></span><br><span class="line">prev.Next = node</span><br><span class="line"><span class="comment">// 当前节点变为尾节点</span></span><br><span class="line">l.Tail = node</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">Delete</span><span class="params">(node *Node)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> l.Head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除节点的前置节点</span></span><br><span class="line">prev := node.Prev</span><br><span class="line"><span class="comment">// 删除节点的后置节点设为前置节点的后置节点</span></span><br><span class="line">prev.Next = node.Next</span><br><span class="line"><span class="comment">// 删除节点的前置节点设为后置节点的前置节点</span></span><br><span class="line">node.Next.Prev = node.Prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">Traverse</span><span class="params">()</span></span> &#123;</span><br><span class="line">now := l.Head</span><br><span class="line"><span class="keyword">for</span> now != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> now.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(now.V, <span class="string">"-&gt;"</span>, <span class="string">"nil"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(now.V, <span class="string">"&lt;-&gt;"</span>)</span><br><span class="line">&#125;</span><br><span class="line">now = now.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>双链表较单链表的不同比较明显，双链表可以很轻松的查找到指定节点的前置和后置节点，遍历方向也可以是从头到尾或者从尾到头。同时，双链表节点操作比较复杂，占用空间也更大。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>顾名思义，循环链表是一个环状的链表。循环链表又分为：单向循环链表、双向循环链表，实现上就是把尾节点和头节点进行链接。</p><p>单向循环链表：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">V    <span class="keyword">string</span></span><br><span class="line">Next *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">Head *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">list := &amp;List&#123;&#125;</span><br><span class="line">n1 := &amp;Node&#123;V: <span class="string">"node1"</span>&#125;</span><br><span class="line">n2 := &amp;Node&#123;V: <span class="string">"node2"</span>&#125;</span><br><span class="line">n3 := &amp;Node&#123;V: <span class="string">"node3"</span>&#125;</span><br><span class="line">list.Append(n1)</span><br><span class="line">list.Append(n2)</span><br><span class="line">list.Append(n3)</span><br><span class="line">list.Traverse() <span class="comment">// 输出结果：node1-&gt;node2-&gt;node3-&gt;node1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">Append</span><span class="params">(node *Node)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> l.Head == <span class="literal">nil</span> &#123;</span><br><span class="line">l.Head = node</span><br><span class="line">node.Next = l.Head</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">now := l.Head</span><br><span class="line"><span class="keyword">for</span> now.Next != l.Head &#123;</span><br><span class="line">now = now.Next</span><br><span class="line">&#125;</span><br><span class="line">now.Next = node</span><br><span class="line">node.Next = l.Head</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">Traverse</span><span class="params">()</span></span> &#123;</span><br><span class="line">now := l.Head</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> now.Next == l.Head &#123;</span><br><span class="line"><span class="built_in">print</span>(now.V, <span class="string">"-&gt;"</span>, l.Head.V)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(now.V, <span class="string">"-&gt;"</span>)</span><br><span class="line">&#125;</span><br><span class="line">now = now.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>链表是最基础且很常用的一种数据结构，可以解决很多算法问题，也可以用于构建其他的数据结构。比如说解决<code>约瑟夫环问题</code>和实现堆栈、队列等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;链表是一种不需要连续空间存储的线性数据结构，通过指针把数据节点链接起来。数据节点的逻辑顺序取决于链表指针链接的先后顺序，同时，链表也有：单链表、双链表、循环链表等多类。&lt;/p&gt;
&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;链表是由一系列节点组成，除此之外链表还有几个基本概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据节点&lt;blockquote&gt;
&lt;p&gt;一般由两块组成：数据域、指针域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;首元节点&lt;blockquote&gt;
&lt;p&gt;链表的第一个数据节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;头节点&lt;blockquote&gt;
&lt;p&gt;非必要节点，放在第一个数据节点前。一般用于存储链表的信息（比如说链表长度等）和保证数据节点操作的统一性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;头指针&lt;blockquote&gt;
&lt;p&gt;指向第一个节点的指针，如果有头节点则指向头节点，否则指向首元节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;单链表&quot;&gt;&lt;a href=&quot;#单链表&quot; class=&quot;headerlink&quot; title=&quot;单链表&quot;&gt;&lt;/a&gt;单链表&lt;/h3&gt;&lt;p&gt;最简单的一种链表，只支持一个遍历方向：链头 -&amp;gt; 链尾。两部分组成：当前节点的数据、指向后置节点的指针（尾节点指针指向nil）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="data structures" scheme="http://xupin.im/tags/data-structures/"/>
    
    <category term="algorithms" scheme="http://xupin.im/tags/algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Go学习笔记 - 泛型</title>
    <link href="http://xupin.im/2022/07/14/go-generic/"/>
    <id>http://xupin.im/2022/07/14/go-generic/</id>
    <published>2022-07-13T16:00:00.000Z</published>
    <updated>2022-07-15T02:30:58.145Z</updated>
    
    <content type="html"><![CDATA[<p>2009年Go语言首次发布后，支持泛型一直以来呼声最高的功能之一。十年磨一剑！Go官方终于在2022年03月15日发布go1.18 stable正式支持<code>泛型</code></p><h3 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h3><p>泛型的核心是把<code>类型参数化</code>，通俗的来说就是允许使用时才指定类型的一种设计。</p><p>假设有个两变量相加的需求，且这俩变量可能是int或者string，简单粗暴就直接定义两个函数分别支持int、string<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt</span><span class="params">(arg1, arg2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> arg1 + arg2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddString</span><span class="params">(arg1, arg2 <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> arg1 + arg2</span><br><span class="line">&#125;</span><br><span class="line">AddInt(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">AddString(<span class="string">"a"</span>, <span class="string">"b"</span>)</span><br></pre></td></tr></table></figure></p><p>那如果使用泛型来定义呢，它的写法大概是这样的</p><a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型写法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span>[<span class="title">type</span>] <span class="params">(var1, var2)</span> <span class="title">type</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> var1 + var2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用时再指定数据类型</span></span><br><span class="line">Add[<span class="keyword">int</span>](<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Add[<span class="keyword">string</span>](<span class="string">"a"</span>,<span class="string">"b"</span>)</span><br></pre></td></tr></table></figure><p>好处显而易见，至少可以少拷贝一个函数。当然这不足以体现出泛型的优点，毕竟这种通用函数通过<code>interface</code>一样可以实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(var1, var2 <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">r := reflect.TypeOf(var1)</span><br><span class="line"><span class="keyword">switch</span> r.Kind() &#123;</span><br><span class="line"><span class="keyword">case</span> reflect.Int:</span><br><span class="line"><span class="keyword">return</span> var1.(<span class="keyword">int</span>) + var2.(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">case</span> reflect.String:</span><br><span class="line"><span class="keyword">return</span> var1.(<span class="keyword">string</span>) + var2.(<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">Add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Add(<span class="string">"a"</span>,<span class="string">"b"</span>)</span><br></pre></td></tr></table></figure><p>既然通过<code>interface</code>也可以实现，那么为什么泛型还备受推崇呢？</p><ol><li>便利性 &amp; 效率<blockquote><p>使用interface实现则需要使用断言或者反射来处理类型问题，同时Go语言中反射性能十分低下（见下图）。</p></blockquote></li><li>安全性<blockquote><p>interface极易引发类型异常问题，编译器在编译过程中不能发现类型问题。</p></blockquote></li></ol><p><img src="/assets/go-generic/reflect-slow.png" alt="drawing" width="400" height="300"></p><h3 id="Go的泛型"><a href="#Go的泛型" class="headerlink" title="Go的泛型"></a>Go的泛型</h3><p>在Go语言中如何使用泛型，先了解一下泛型的3个概念：</p><ol><li>泛型参数</li><li>泛型参数类型约束</li><li>泛型参数列表</li></ol><p>Go泛型的代码风格和其他语言基本类似，比如定义一个只支持int和string两值相加的泛型函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span>[<span class="title">T</span> <span class="title">int</span> | <span class="title">string</span>]<span class="params">(var1, var2 T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> var1 + var2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上函数，</p><ul><li><p>T 泛型参数，可以是任意字母且不区分大小写（但通常使用大写字母）。</p></li><li><p>int | string 泛型参数类型约束，用于声明和约束泛型参数T支持的数据类型。比如</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Add[T <span class="keyword">float64</span>] <span class="comment">// 只支持float64类型</span></span><br><span class="line">Add[T any] <span class="comment">// 支持任何类型，any等价于interface&#123;&#125;</span></span><br><span class="line">Add[T comparable] <span class="comment">// golang新增的内置接口，任何可进行比较的类型（!=、==、&amp;&amp;、||）</span></span><br><span class="line">Add[T ~<span class="keyword">int</span>] <span class="comment">// 任何底层类型为int的类型，~是新增的操作符。</span></span><br></pre></td></tr></table></figure><ul><li>[] 中括号内是泛型参数列表，支持任意个泛型参数，使用逗号分隔。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Add[T <span class="keyword">int64</span>, T2 <span class="keyword">float64</span>](var1, var2 T, var3 T2)</span><br></pre></td></tr></table></figure><p>如果泛型仅仅能在函数上使用好像有点“鸡肋”。它还可以这样去使用，<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型结构体</span></span><br><span class="line"><span class="keyword">type</span> Resp[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">Code <span class="keyword">int</span></span><br><span class="line">Msg  <span class="keyword">string</span></span><br><span class="line">Data T</span><br><span class="line">&#125;</span><br><span class="line">resp := &amp;Resp[<span class="keyword">string</span>]&#123;</span><br><span class="line">    Code: <span class="number">200</span>,</span><br><span class="line">    Msg:  <span class="string">"OK"</span>,</span><br><span class="line">    Data: <span class="string">""</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型管道</span></span><br><span class="line"><span class="keyword">type</span> MyChan[T <span class="keyword">int</span> | <span class="keyword">bool</span>] <span class="keyword">chan</span> T</span><br><span class="line">ch := <span class="built_in">make</span>(MyChan[<span class="keyword">bool</span>], <span class="number">1</span>)</span><br><span class="line">ch &lt;- <span class="literal">true</span></span><br><span class="line">&lt;-ch</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型Map</span></span><br><span class="line"><span class="keyword">type</span> MyMap[T <span class="keyword">int</span> | <span class="keyword">string</span>, T1 any] <span class="keyword">map</span>[T]T1</span><br><span class="line">m := MyMap[<span class="keyword">string</span>, <span class="keyword">string</span>]&#123;</span><br><span class="line">    <span class="string">"key"</span>: <span class="string">"val"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型接口</span></span><br><span class="line"><span class="keyword">type</span> Personer[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">Say(age T)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Male <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Male)</span> <span class="title">Say</span><span class="params">(age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> m Personer[<span class="keyword">int</span>] = &amp;Male&#123;&#125;</span><br><span class="line">m.Say(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Female <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Female)</span> <span class="title">Say</span><span class="params">(age <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f Personer[<span class="keyword">string</span>] = &amp;Female&#123;&#125;</span><br><span class="line">f.Say(<span class="string">"secret"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型类型</span></span><br><span class="line"><span class="keyword">type</span> MyType <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="keyword">int</span> | <span class="keyword">string</span> | <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span>[<span class="title">T</span> <span class="title">MyType</span>]<span class="params">(var1, var2 T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> var1 + var2   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上只是简单列举，还支持一些列“套娃”行为。值的注意的是，Go新增的操作符<code>~</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyType <span class="keyword">interface</span> &#123;</span><br><span class="line">~<span class="keyword">int</span> | <span class="keyword">string</span> | <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span>[<span class="title">T</span> <span class="title">MyType</span>]<span class="params">(var1, var2 T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> var1 + var2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a, b MyInt = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">Add(a, b)</span><br></pre></td></tr></table></figure></p><p>使用操作符~，意味不仅支持该操作符后的基本类型，同时还支持任意底层类型是该类型的数据。</p><blockquote><p>以上内容参考来源：<a href="https://tip.golang.org/doc/go1.18" target="_blank" rel="noopener">https://tip.golang.org/doc/go1.18</a></p></blockquote><h3 id="什么时候使用泛型"><a href="#什么时候使用泛型" class="headerlink" title="什么时候使用泛型"></a>什么时候使用泛型</h3><p>当你要为不同数据类型做着同样的处理逻辑时，可以考虑使用泛型。泛型是把双刃剑，既可以提高编码效率、提升代码美学，同样也可以让代码可读性变的很差。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2009年Go语言首次发布后，支持泛型一直以来呼声最高的功能之一。十年磨一剑！Go官方终于在2022年03月15日发布go1.18 stable正式支持&lt;code&gt;泛型&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是泛型&quot;&gt;&lt;a href=&quot;#什么是泛型&quot; class=&quot;headerlink&quot; title=&quot;什么是泛型&quot;&gt;&lt;/a&gt;什么是泛型&lt;/h3&gt;&lt;p&gt;泛型的核心是把&lt;code&gt;类型参数化&lt;/code&gt;，通俗的来说就是允许使用时才指定类型的一种设计。&lt;/p&gt;
&lt;p&gt;假设有个两变量相加的需求，且这俩变量可能是int或者string，简单粗暴就直接定义两个函数分别支持int、string&lt;br&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 传统写法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AddInt&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(arg1, arg2 &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arg1 + arg2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AddString&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(arg1, arg2 &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;string&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arg1 + arg2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AddInt(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AddString(&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;那如果使用泛型来定义呢，它的写法大概是这样的&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="golang" scheme="http://xupin.im/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go学习笔记 - init函数</title>
    <link href="http://xupin.im/2022/03/08/go-init/"/>
    <id>http://xupin.im/2022/03/08/go-init/</id>
    <published>2022-03-07T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.751Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Golang中的特殊函数，会先于main函数执行且不能被调用。该函数无入参、返回值，同时支持选择性定义。也可以选择定义多个init函数，但建议只定义一个。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"init1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"init2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"main"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// init1</span></span><br><span class="line"><span class="comment">// init3</span></span><br><span class="line"><span class="comment">// main</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>init函数实现了sync.Once锁，只会被执行一次。</p><ul><li><p>my/my.go</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> my</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"a.init"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"a.Test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>main.go</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"test/my"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">my.Test()</span><br><span class="line">my.Test()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a.init</span></span><br><span class="line"><span class="comment">// a.Test</span></span><br><span class="line"><span class="comment">// a.Test</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h3><p>在package内部<code>变量赋值 &gt; init() &gt; main()</code>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">string</span> = sayHello()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"init"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"main"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"sayHello"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">"hi"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sayHello</span></span><br><span class="line"><span class="comment">// init</span></span><br><span class="line"><span class="comment">// main</span></span><br></pre></td></tr></table></figure><p>多个package调用时的初始化顺序，则取决于依赖顺序。</p><ul><li><p>my.go</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> my</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"test/your"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"a.init"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"a.Test"</span>)</span><br><span class="line">your.Test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>your.go</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> your</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"your.init"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"your.Test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>main.go</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"test/my"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">my.Test()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// your.init</span></span><br><span class="line"><span class="comment">// a.init</span></span><br><span class="line"><span class="comment">// a.Test</span></span><br><span class="line"><span class="comment">// your.Test</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>当package内定义多个init函数，它的执行顺序？</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;Golang中的特殊函数，会先于main函数执行且不能被调用。该函数无入参、返回值，同时支持选择性定义。也可以选择定义多个init函数，但建议只定义一个。&lt;br&gt;&lt;figure class=&quot;highlight golang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;init1&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;init2&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;main&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// init1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// init3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// main&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="golang" scheme="http://xupin.im/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>ClickHouse学习笔记 - MergeTree存储结构</title>
    <link href="http://xupin.im/2022/01/26/clickhouse-mergetree/"/>
    <id>http://xupin.im/2022/01/26/clickhouse-mergetree/</id>
    <published>2022-01-25T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.749Z</updated>
    
    <content type="html"><![CDATA[<p>ClickHouse是这两年备受瞩目的开源列式数据库，主要应用场景是OLAP（在线数据分析处理）场景。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>之前因为遇见一些小问题，所以想通过存储结构和索引方式两个方面搞清楚它为什么可以这么快。</p><p>ClickHouse是OLAP型的列式数据库，官方称比较行式数据库查询效率提升至少100倍，<a href="https://clickhouse.com/benchmark/dbms/#[%22100000000%22,[%22ClickHouse%22,%22Vertica%22,%22MySQL%22,%22PostgreSQL%22],[%221%22,%222%22]]" target="_blank" rel="noopener">DB Benchmark</a>显示ClickHouse比Mysql快800倍！</p><a id="more"></a><h3 id="什么是OLAP型列式数据库"><a href="#什么是OLAP型列式数据库" class="headerlink" title="什么是OLAP型列式数据库"></a>什么是OLAP型列式数据库</h3><p>OLAP业务场景一般具有以下特征：</p><ol><li>多数是查询请求，但请求不密集。</li><li>数据写入不频繁，或者单次大批量写入数据。</li><li>尽量不更新或少更新历史数据。</li><li>数据表列比较多（宽表），但每列存储数据较小。</li><li>对数据一致性要求较低，不依赖事务。</li><li>查询请求目标数据表比较独立，或者除目标表外其他需要关联的表的数据量相对很少。</li><li>查询结果集数据量远远小于源数据表，至少服务器内存不会溢出。</li><li>简单的查询，毫秒级别的响应。</li><li>单次查询高吞吐量。</li></ol><h3 id="列式和行式数据库的区别"><a href="#列式和行式数据库的区别" class="headerlink" title="列式和行式数据库的区别"></a>列式和行式数据库的区别</h3><p>存储方式</p><ul><li>行式</li></ul><table><thead><tr><th>Row</th><th>WatchID</th><th>JavaEnable</th><th>Title</th><th>GoodEvent</th><th>EventTime</th></tr></thead><tbody><tr><td>#0</td><td>89354350662</td><td>1</td><td>Investor Relations</td><td>1</td><td>2016-05-18 05:19:20</td></tr><tr><td>#1</td><td>90329509958</td><td>0</td><td>Contact us</td><td>1</td><td>2016-05-18 08:10:20</td></tr><tr><td>#2</td><td>89953706054</td><td>1</td><td>Mission</td><td>1</td><td>2016-05-18 07:38:00</td></tr><tr><td>#N</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><ul><li>列式</li></ul><table><thead><tr><th>Row:</th><th>#0</th><th>#1</th><th>#2</th><th>#N</th></tr></thead><tbody><tr><td>WatchID:</td><td>89354350662</td><td>90329509958</td><td>89953706054</td><td>…</td></tr><tr><td>JavaEnable:</td><td>1</td><td>0</td><td>1</td><td>…</td></tr><tr><td>Title:</td><td>Investor Relations</td><td>Contact us</td><td>Mission</td><td>…</td></tr><tr><td>GoodEvent:</td><td>1</td><td>1</td><td>1</td><td>…</td></tr><tr><td>EventTime:</td><td>2016-05-18 05:19:20</td><td>2016-05-18 08:10:20</td><td>2016-05-18 07:38:00</td><td>…</td></tr></tbody></table><p>检索方式（通过两张图感受一下）</p><ul><li><p>行式：<br><img src="https://clickhouse.com/docs/en/images/row-oriented.gif" alt></p></li><li><p>列式：<br><img src="https://clickhouse.com/docs/en/images/column-oriented.gif" alt></p></li></ul><p>列式数据库的优势</p><ol><li>查询请求时只读取需要的列，而不是像行式数据库需要读取符合条件的所有block（即使是行式数据库也不是按行读取数据而是块，有些数据库也称页）。需要读取数据量的减少，意味着IO操作会更快。</li><li>同一列的数据类型一致，可以使用最适用的压缩算法（更高的压缩比），节省存储空间。</li></ol><h3 id="ClickHouse的优缺点"><a href="#ClickHouse的优缺点" class="headerlink" title="ClickHouse的优缺点"></a>ClickHouse的优缺点</h3><ul><li>优点</li></ul><ol><li>支持SQL语法，不像ES的DSL那样晦涩难懂。</li><li>可以保证数据一致性（最终）。</li><li>压榨性能极限，多核心处理使用机器一切可用资源。</li><li>高效的磁盘IO，数据都是有序存储。</li><li>查询不需要遵守索引<code>最左原则</code>。</li><li>批量写入速度快。</li></ol><ul><li>缺点</li></ul><ol><li>部分SQL语法不支持，但无伤大雅。</li><li>更新和删除操作支持不好。</li><li>不支持事务。</li><li>不支持高并发，官方默认QPS：100（可以通过配置修改）</li></ol><p>简单的列举了优缺点，这只是冰山一角。实际上ClickHouse值得深入探讨的太多太多。</p><h3 id="MergeTree的特性"><a href="#MergeTree的特性" class="headerlink" title="MergeTree的特性"></a>MergeTree的特性</h3><p>ClickHouse是真正的列式存储数据库，不同于内存计算引擎（比如SparkSQL、Presto），它有自己的数据存储机制和索引方式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db.]table_name [<span class="keyword">ON</span> CLUSTER cluster]</span><br><span class="line">(</span><br><span class="line">    name1 [type1] [<span class="keyword">DEFAULT</span>|<span class="keyword">MATERIALIZED</span>|<span class="keyword">ALIAS</span> expr1] [TTL expr1],</span><br><span class="line">    name2 [type2] [<span class="keyword">DEFAULT</span>|<span class="keyword">MATERIALIZED</span>|<span class="keyword">ALIAS</span> expr2] [TTL expr2],</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">INDEX</span> index_name1 expr1 <span class="keyword">TYPE</span> type1(...) GRANULARITY value1,</span><br><span class="line">    <span class="keyword">INDEX</span> index_name2 expr2 <span class="keyword">TYPE</span> type2(...) GRANULARITY value2</span><br><span class="line">) <span class="keyword">ENGINE</span> = MergeTree()</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> expr</span><br><span class="line">[<span class="keyword">PARTITION</span> <span class="keyword">BY</span> expr]</span><br><span class="line">[PRIMARY <span class="keyword">KEY</span> expr]</span><br><span class="line">[<span class="keyword">SAMPLE</span> <span class="keyword">BY</span> expr]</span><br><span class="line">[TTL expr [<span class="keyword">DELETE</span>|<span class="keyword">TO</span> DISK <span class="string">'xxx'</span>|<span class="keyword">TO</span> VOLUME <span class="string">'xxx'</span>], ...]</span><br><span class="line">[<span class="keyword">SETTINGS</span> <span class="keyword">name</span>=<span class="keyword">value</span>, ...]</span><br></pre></td></tr></table></figure><ul><li><p>ORDER BY</p><blockquote><p>排序字段，数据存储时按照排序字段（排序字段可以是一个字段，也可以是元组）进行有序存储。</p></blockquote></li><li><p>PARTITION BY</p><blockquote><p>ClickHouse支持按列值进行数据分区，也支持以表达式进行分区（比如<code>toYear(date)</code>），分区字段值不可以过多，否则会报错（比如按照user_id分区）。主要作用是分区裁剪，过滤非必要的查询数据。</p></blockquote></li><li><p>PRIMARY KEY</p><blockquote><p>ClickHouse的MergeTree引擎可以定义主键，但不同于行式数据库。主键不做唯一约束，可以是多个字段。默认不定义主键，会将排序键作为主键。如果定义主键（排序键过大，为了控制主键文件大小），则尽量保证是排序键的前部分键。</p></blockquote></li><li><p>SAMPLE BY</p><blockquote><p>ClickHouse提供的抽样表达式机制，查询请求时通过采样子句进行数据采样功能。<br>建表时需要声明采样表达式（通过哪个字段采样），该字段必须是<code>UInt类型</code>且必须出现在主键或排序键中（如果不是UInt类型可以声明，但使用会报错）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> example</span><br><span class="line">(</span><br><span class="line">    user_id UInt64,</span><br><span class="line">    <span class="keyword">name</span> <span class="keyword">String</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> intHash32(user_id)</span><br><span class="line"><span class="keyword">SAMPLE</span> <span class="keyword">BY</span> intHash32(user_id)</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>查询请求时，通过<code>sample</code>关键字进行伪随机数据采样。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> example <span class="keyword">sample</span> <span class="number">1</span>/<span class="number">10</span> <span class="comment"># 数据的10%</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> example <span class="keyword">sample</span> <span class="number">10</span> <span class="comment"># 10行数据</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> example <span class="keyword">sample</span> <span class="number">1</span>/<span class="number">10</span> <span class="keyword">offset</span> <span class="number">1</span>/<span class="number">2</span> <span class="comment"># 从数据表50%部分中取出10%的数据</span></span><br></pre></td></tr></table></figure></p><p>可以通过字段<code>_sample_factor</code>查询采样系数，该字段是虚拟的。</p></blockquote><ul><li>TTL<blockquote><p>ClickHouse原生支持的数据生命周期管理的机制，在MergeTree中可以为列、表2个级别设置TTL，当时间到期后触发相应级别的数据删除操作。<br>无论是哪种级别的TTL，字段必须为<code>Datetime</code>或<code>Date</code>类型，因为依赖INTERVAL设置生命周期。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> example</span><br><span class="line">(</span><br><span class="line">    <span class="built_in">date</span> <span class="built_in">Date</span>,</span><br><span class="line">    login_ip <span class="keyword">String</span> TTL <span class="built_in">date</span> + <span class="built_in">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span></span><br><span class="line">)</span><br><span class="line">TTL <span class="built_in">date</span> + <span class="built_in">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span> <span class="comment"># [DELETE,TO VOLUME,TO DISK] 默认值: DELETE</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><ol><li>当列级TTL触发时，会把对应值修改为列类型的默认值，如果该列数据全部过期则会<code>删除该列</code>。</li><li>当表级TTL触发时，会删除所有符合过期条件的数据行。</li><li>当同时设置列级、表级TTL，以先到期的为准。</li></ol></blockquote><ul><li>SETTINGS<blockquote><p>控制 MergeTree 行为的额外参数，可选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index_granularity <span class="comment"># 索引粒度。索引中相邻的『标记』间的数据行数。默认值8192 。</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><p>其他更多参数，可以查阅<a href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/#mergetree-query-clauses" target="_blank" rel="noopener">官方文档</a><code>SETTINGS</code>部分。</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>使用MergeTree引擎，一张数据表会分成N个数据分区，每个数据分区对应一个文件目录。<br>可以通过SQL查询到分区信息：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> system.parts <span class="keyword">WHERE</span> <span class="string">`table`</span> = <span class="string">'&#123;table&#125;'</span> <span class="comment">-- path字段是数据分区的存储位置</span></span><br></pre></td></tr></table></figure></p><p>或者在ClickHouse数据存储目录查看<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /data/clickhouse/data</span><br><span class="line">$ tree -d</span><br><span class="line">.</span><br><span class="line">├── default</span><br><span class="line">│   ├── test_a -&gt; /data/clickhouse/store/adf/adf66eb8-4f34-4a9c-adf6-6eb84f346a9c/</span><br><span class="line">│   └── test_b -&gt; /data/clickhouse/store/ed9/ed96975a-4048-4846-ad96-975a40484846/</span><br><span class="line">└── system</span><br><span class="line">    ├── asynchronous_metric_log -&gt; /data/clickhouse/store/507/5075436a-cb6c-4fac-9075-436acb6ccfac/</span><br><span class="line">    ├── metric_log -&gt; /data/clickhouse/store/86c/86cd831c-1bd4-4df2-86cd-831c1bd43df2/</span><br><span class="line">    ├── query_log -&gt; /data/clickhouse/store/986/9860fbbb-e965-476f-9860-fbbbe965776f/</span><br><span class="line">    ├── query_thread_log -&gt; /data/clickhouse/store/c1b/c1b39615-68ee-4fb7-81b3-961568eeafb7/</span><br><span class="line">    └── trace_log -&gt; /data/clickhouse/store/b6d/b6d34f2c-1580-411b-b6d3-4f2c1580911b/</span><br><span class="line">$ <span class="built_in">cd</span> /data/clickhouse/store/adf/adf66eb8-4f34-4a9c-adf6-6eb84f346a9c/</span><br><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── 20220101_1_3_0</span><br><span class="line">│   ├── checksums.txt</span><br><span class="line">│   ├── columns.txt </span><br><span class="line">│   ├── &#123;column&#125;.bin</span><br><span class="line">│   ├── &#123;column&#125;.mrk</span><br><span class="line">│   ├── count.txt</span><br><span class="line">│   ├── primary.idx</span><br><span class="line">│   ├── partition.dat</span><br><span class="line">│   ├── minmax_&#123;column&#125;.idx</span><br><span class="line">│   ├── skp_idx_&#123;column&#125;.idx</span><br><span class="line">│   └── skp_idx_&#123;column&#125;.mrk</span><br><span class="line">├── detached</span><br><span class="line">├── format_version.txt</span><br><span class="line">└── mutation_&#123;key&#125;.txt</span><br></pre></td></tr></table></figure></p><ul><li>20220101_1_3_0<blockquote><p>数据分区的名称，由4部分组成。</p></blockquote></li></ul><ol><li>名称：20220101</li><li>最小数据块编号：1</li><li>最大数据块编号：3</li><li>数据块级别：0（即在由块组成的合并树中，该块在树中的深度）</li></ol><ul><li><p>checksums.txt</p><blockquote><p>校验文件，使用二进制存储数据目录的文件信息，保证安全性和完整性。</p></blockquote></li><li><p>columns.txt</p><blockquote><p>明文存储列信息（列名，列类型）</p></blockquote></li><li><p>{column}.bin</p><blockquote><p>核心数据文件（二进制存储），分区字段<code>part_type</code>为<code>Wide</code>时会为每列创建对应的数据文件，如果是<code>Compact</code>则所有列存储在一个数据文件。该值受配置<code>min_bytes_for_wide_part</code>、<code>min_rows_for_wide_part</code>影响。<br>该文件的内容以数据Block存储（也称页），数据是否压缩受配置<code>max_compress_block_size</code>、<code>min_compress_block_size</code>影响。默认压缩格式：<a href="https://github.com/lz4/lz4#lz4---extremely-fast-compression" target="_blank" rel="noopener">lz4</a>。<br>Block数据块分为两部分：头信息和数据。头信息固定占9字节：压缩方式1字节、压缩后大小4字节、压缩前大小4字节。</p></blockquote></li><li><p>{column}.mrk</p><blockquote><p>列字段标记文件（二进制存储），文件中记录{column}.bin文件中数据Block的偏移量。</p></blockquote></li><li><p>count.txt</p><blockquote><p>该数据分区的数据行数。</p></blockquote></li><li><p>primary.idx</p><blockquote><p>主键索引文件（二进制存储），每<code>index_granularity</code>行取主键值作为稀疏索引。</p></blockquote></li><li><p>partition.dat</p><blockquote><p>当前数据分区的编号。</p></blockquote></li><li><p>minmax_{column}.idx</p><blockquote><p>列索引文件，存储列的最大值和最小值。</p></blockquote></li><li><p>skp<em>idx</em>{column}.idx</p><blockquote><p>跳数索引（又称二级索引）文件，受<code>allow_experimental_data_skipping_indices</code>参数控制，默认不开启。</p></blockquote></li><li><p>skp<em>idx</em>{column}.mrk</p><blockquote><p>跳数索引标记文件。</p></blockquote></li><li><p>detached</p><blockquote><p>执行<code>ALTER TABLE table_name DETACH PARTITION|PART partition_expr</code>命令后，会将对应的数据分离至该目录并“遗忘”。</p></blockquote></li><li><p>format_version.txt</p><blockquote><p>记录存储的格式。</p></blockquote></li><li><p>mutation_{key}.txt</p><blockquote><p>不同于行式数据库，ClickHouse对于mutation操作（Update、Delete）是异步执行的，同时会生成<code>mutation_{key}.txt</code>文件记录操作和生成新的数据目录<code>20220101_1_3_0_{key}</code>。可以通过SQL查询:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> system.mutations <span class="keyword">WHERE</span> <span class="string">`table`</span>  = <span class="string">'&#123;table&#125;'</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><p>因为使用类LSM架构，该类操作尽量少执行（埋个坑，后面再去研究）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ClickHouse是这两年备受瞩目的开源列式数据库，主要应用场景是OLAP（在线数据分析处理）场景。&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;之前因为遇见一些小问题，所以想通过存储结构和索引方式两个方面搞清楚它为什么可以这么快。&lt;/p&gt;
&lt;p&gt;ClickHouse是OLAP型的列式数据库，官方称比较行式数据库查询效率提升至少100倍，&lt;a href=&quot;https://clickhouse.com/benchmark/dbms/#[%22100000000%22,[%22ClickHouse%22,%22Vertica%22,%22MySQL%22,%22PostgreSQL%22],[%221%22,%222%22]]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DB Benchmark&lt;/a&gt;显示ClickHouse比Mysql快800倍！&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="clickhouse" scheme="http://xupin.im/tags/clickhouse/"/>
    
  </entry>
  
  <entry>
    <title>函数 - 闭包函数、匿名函数及lambda“函数”有什么关系</title>
    <link href="http://xupin.im/2022/01/19/func-closure-lambda-diff/"/>
    <id>http://xupin.im/2022/01/19/func-closure-lambda-diff/</id>
    <published>2022-01-18T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.749Z</updated>
    
    <content type="html"><![CDATA[<p>经常在技术博客中看到匿名函数、闭包函数和lambda表达式这样名词，但一直傻傻分不清他们之间究竟有什么区别，所以想一探究竟。</p><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>一个函数的定义，一般会包含：函数名、函数的参数、函数的主体（代码块）、函数的返回类型/值。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Hello, "</span> + name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="闭包函数"><a href="#闭包函数" class="headerlink" title="闭包函数"></a>闭包函数</h3><p>通过字面意思理解，即定义在内部的函数。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := test()</span><br><span class="line">t()</span><br><span class="line">t()</span><br><span class="line">t()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="number">0</span></span><br><span class="line">fmt.Println(<span class="string">"test()"</span>, x, &amp;x)</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">x += <span class="number">1</span></span><br><span class="line">fmt.Println(<span class="string">"closure()"</span>, x, &amp;x)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行程序输出以下内容</span></span><br><span class="line"><span class="comment">// test() 0 0xc000016098</span></span><br><span class="line"><span class="comment">// closure() 1 0xc000016098</span></span><br><span class="line"><span class="comment">// closure() 2 0xc000016098</span></span><br><span class="line"><span class="comment">// closure() 3 0xc000016098</span></span><br></pre></td></tr></table></figure></p><ol><li>执行test()函数返回闭包函数。</li><li>执行闭包函数发现可以使用x变量，但不用声明x变量。</li><li>再次执行闭包函数仍旧可以使用x变量，说明闭包函数自身在“维护”x变量。</li><li>通过内存地址可以看出闭包函数和test()函数的x变量是同一个变量。</li></ol><blockquote><p>是不是可以理解为：<code>函数创建时获取所需外部状态，即使外部状态关闭，函数中的状态还会存在。这个过程就是“闭包”，或许闭包函数解决的是变量作用域的问题？</code></p></blockquote><p>引用JavaScript MDN对闭包函数的一句解释：</p><blockquote><p>A closure is the combination of a function and the lexical environment within which that function was declared.</p></blockquote><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>匿名函数，即“无名”函数。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">lam := <span class="function"><span class="keyword">func</span><span class="params">(x, y, z <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line">x := lam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>匿名函数可以直接定义在代码块中。匿名函数可以减少函数暴露，防止被外部代码调用执行（避免数据污染）。</p><h3 id="lambda“函数”"><a href="#lambda“函数”" class="headerlink" title="lambda“函数”"></a>lambda“函数”</h3><p>lambda“函数”，严格来说应该叫lambda表达式。它是一个可以接受N个参数但只返回单个表达式值的“函数”，可以理解为它是匿名函数的一种代码风格或者语法糖。</p><p>lambda会使代码看起来比较简洁，很适用于这个函数“只用一次”的场景。比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">print(<span class="string">"square()"</span>, list(map(square, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"lambda"</span>, list(map(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># square() [1, 4, 9, 16, 25]</span></span><br><span class="line"><span class="comment"># lambda [1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure></p><p>lambda表达式带来代码简洁的同时也有副作用，lambda可读性较差，不适用于很长很复杂的逻辑，所以不要为了写lambda而写lambda。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func = <span class="keyword">lambda</span> x, y, z: x + y + z</span><br><span class="line">x = func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码被自动转换</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, y, z)</span>:</span> <span class="keyword">return</span> x + y + z</span><br><span class="line">x = func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure></p><p>在<code>Visual Studio Code</code>中编辑保存这段代码会被自动转换，在<code>PyCharm</code>中则会直接给出警告<code>PEP 8: E731 do not assign a lambda expression, use a def</code><a href="https://pypi.org/project/autopep8/#features" target="_blank" rel="noopener">autopep8</a></p><p>至于为什么这种书写方式称之为lambda表达式，则是有原因的：</p><blockquote><p>Alonzo Church在30年代发明的<a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank" rel="noopener">Lambda Calculus</a>，你可以在其中做的一件事就是λ运算。</p></blockquote><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>猜猜以下这段代码执行后会输出什么？<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">i := v</span><br><span class="line">fmt.Printf(<span class="string">"for v:%d i:%d\n"</span>, v, i)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Printf(<span class="string">"func v:%d i:%d\n"</span>, v, i)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;经常在技术博客中看到匿名函数、闭包函数和lambda表达式这样名词，但一直傻傻分不清他们之间究竟有什么区别，所以想一探究竟。&lt;/p&gt;
&lt;h3 id=&quot;函数定义&quot;&gt;&lt;a href=&quot;#函数定义&quot; class=&quot;headerlink&quot; title=&quot;函数定义&quot;&gt;&lt;/a&gt;函数定义&lt;/h3&gt;&lt;p&gt;一个函数的定义，一般会包含：函数名、函数的参数、函数的主体（代码块）、函数的返回类型/值。&lt;br&gt;&lt;figure class=&quot;highlight golang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;string&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Hello, &quot;&lt;/span&gt; + name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="lambda" scheme="http://xupin.im/tags/lambda/"/>
    
    <category term="closure" scheme="http://xupin.im/tags/closure/"/>
    
    <category term="function" scheme="http://xupin.im/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>ClickHouse学习笔记 - 数据引擎</title>
    <link href="http://xupin.im/2022/01/16/clickhouse-engines/"/>
    <id>http://xupin.im/2022/01/16/clickhouse-engines/</id>
    <published>2022-01-15T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.749Z</updated>
    
    <content type="html"><![CDATA[<p>ClickHouse是个由老毛子国内市场使用率第一的搜索引擎Yandex开源的OLAP型列式数据库。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>之前因为业务接触到ClickHouse，但因为没有系统的了解过导致遇见个很小的问题、花了大量的时间、用了很挫的方式来解决问题，痛定思痛的情况下决心系统的逐步学习一下。ClickHouse无论是存储还是使用方式都不同程度的异于我们常用的Mysql，PostgreSql，Mssql等行式数据库，但它支持绝大部分的SQL语法。</p><a id="more"></a><h3 id="数据引擎"><a href="#数据引擎" class="headerlink" title="数据引擎"></a>数据引擎</h3><p>ClickHouse（基于v21.7）的引擎分为数据库引擎和表引擎。</p><ul><li><p>数据库引擎</p><ol><li>MySQL<blockquote><p>顾名思义，和Mysql数据库有关系。该引擎允许连接远程Mysql数据库并且执行Sql交换数据。但是仅支持部分操作（读写）。</p></blockquote></li><li>MaterializeMySQL<blockquote><p>v20.8新增的引擎，这是一个处在<code>实验阶段的引擎</code>，通过名称可以看出来也是和Mysql相关的引擎，该引擎通过binlog日志进行全量（第一次）和增量实时物化（可以理解为同步？）Mysql数据，原本Mysql的DDL和DML操作都可以通过ClickHouse执行。</p></blockquote></li><li>Lazy<blockquote><p>在最后一次操作该表之后，仅在固定秒数内将表保留在运存中，该秒数通过<code>expiration_time_in_seconds</code>参数控制。</p></blockquote></li><li>Atomic<blockquote><p>新版本默认的数据库引擎，支持对表非阻塞的<code>drop</code>、<code>rename</code>操作以及原子操作交换两张表。</p></blockquote></li><li>PostgreSQL<blockquote><p>该引擎的特性和<code>MySQL</code>引擎大致相同，只不过是对PostgreSql的支持。</p></blockquote></li><li>MaterializedPostgreSQL<blockquote><p>与<code>MaterializeMySQL</code>一样，是<code>实验阶段的引擎</code>。作为PostgreSql数据表的副本进行后台同步。</p></blockquote></li><li>Replicated<blockquote><p>基于<code>Atomic</code>引擎，通过将DDL操作日志写入ZK并在数据库的所有副本上执行的元数据复制（复制数据库）。可以同时运行和更新多个复制的数据库。但是同一个复制的数据库不能有多个副本。</p></blockquote></li></ol></li><li><p>表引擎（表引擎比数据库引擎稍微复杂一些，表引擎又分为四大系列）</p><ol><li>MergeTree系列</li><li>Log系列</li><li>Integrations系列</li><li>Special类</li></ol></li></ul><h3 id="MergeTree系列"><a href="#MergeTree系列" class="headerlink" title="MergeTree系列"></a>MergeTree系列</h3><p>MergeTree系列的表引擎比较常用，它支持主键、数据分区、数据副本和数据采样等特性，同时支持重要的<code>alter</code>操作语句。</p><ul><li>ReplacingMergeTree<blockquote><p>清洗数据，去除重复数据。当数据重复时数据去重策略有两种：通过<code>ReplacingMergeTree({version})</code>建立version字段则保留version字段最大值，否则则保留最后一行。</p></blockquote></li><li>SummingMergeTree<blockquote><p>按照预先定义的聚合条件汇总数据</p></blockquote></li><li>AggregatingMergeTree<blockquote><p><code>SummingMergeTree</code>引擎的进阶版。能够在合并分区时，按照预先定义的聚合条件汇总数据。</p></blockquote></li><li>CollapsingMergeTree<blockquote><p>支持行级数据的更新和删除，通过指定字段<code>CollapsingMergeTree({sign})</code>标记数据行的状态（状态值：1，-1）。分区合并时，同一个数据分区内sign值为1的数据行会和下一行sign值为-1的抵消删除。如果并发写入时则会导致乱序问题，即sign值1和-1的数据行并不相临的问题。</p></blockquote></li><li>VersionedCollapsingMergeTree<blockquote><p><code>CollapsingMergeTree</code>引擎的进阶版。通过<code>VersionedCollapsingMergeTree({sign},{version})</code>新增version字段解决乱序问题。</p></blockquote></li><li>GraphiteMergeTree<blockquote><p>存储时序数据库Graphite的数据。</p></blockquote></li></ul><h3 id="Log系列"><a href="#Log系列" class="headerlink" title="Log系列"></a>Log系列</h3><p>Log引擎面向的应用场景一般是：小数据量、多写少查、单次查询数据较大。</p><ul><li>StripLog<blockquote><p>支持多线程并发读取文件（data.bin），数据写入时会将所有数据列存储在同一个文件中。</p></blockquote></li><li>TinyLog<blockquote><p>数据写入时每个数据列存储在不同的文件（{column}.bin），但不支持多线程并发读取文件。</p></blockquote></li><li>Log<blockquote><p>支持多线程并发读取文件，写入时每个数据列单独存储文件。</p></blockquote></li></ul><h3 id="Integrations系列"><a href="#Integrations系列" class="headerlink" title="Integrations系列"></a>Integrations系列</h3><p>该类引擎提供多种方式与外部系统集成（外部表），支持包括但不仅限于：</p><ol><li>ODBC</li><li>JDBC</li><li>Mysql</li><li>MongoDB</li><li>HDFS</li><li>S3</li><li>Kafka</li><li>EmbeddedRocksDB</li><li>RabbitMQ</li><li>PostgreSQL</li><li>SQLite</li><li>Hive</li></ol><h3 id="Special类"><a href="#Special类" class="headerlink" title="Special类"></a>Special类</h3><p>这个分类下的引擎适用于定制化的业务场景。</p><ul><li>内存类<ol><li>Memory<blockquote><p>将数据存储在内存中，但不提供持久化操作，重启数据就跑丢了。</p></blockquote></li><li>Set<blockquote><p>适用于集合类型的查询操作，比如：in。</p></blockquote></li><li>Join<blockquote><p>望文生义，为了连表查询。</p></blockquote></li><li>Buffer<blockquote><p>通俗的说像是数据脏页设置一个刷新阈值，达到即刷新到磁盘中。</p></blockquote></li></ol></li><li>中间件类<ol><li>Distributed<blockquote><p>自动分片、自动写入和查询数据。</p></blockquote></li><li>Dictionary<blockquote><p>自动为数据字典创建数据表。</p></blockquote></li><li>Merge<blockquote><p>合并多个相同表结构的查询结果。</p></blockquote></li></ol></li><li>其他<ol><li>Null<blockquote><p>写入的数据会被丢弃 … 暂时不懂什么用途，官方的描述是适用于视图展示。</p></blockquote></li><li>Url<blockquote><p>配合RESTful接口，操作会转化为：insert =&gt; post、select =&gt; get。</p></blockquote></li><li>Live View<blockquote><p><code>实验阶段的引擎</code>，对事件监听进行实时数据计算。适用场景比如：证券网站。</p></blockquote></li></ol></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单的浏览了ClickHouse不同的数据引擎，接下来会学习存储结构和索引方式（搞清楚为什么查询这么快）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ClickHouse是个由老毛子国内市场使用率第一的搜索引擎Yandex开源的OLAP型列式数据库。&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;之前因为业务接触到ClickHouse，但因为没有系统的了解过导致遇见个很小的问题、花了大量的时间、用了很挫的方式来解决问题，痛定思痛的情况下决心系统的逐步学习一下。ClickHouse无论是存储还是使用方式都不同程度的异于我们常用的Mysql，PostgreSql，Mssql等行式数据库，但它支持绝大部分的SQL语法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="clickhouse" scheme="http://xupin.im/tags/clickhouse/"/>
    
  </entry>
  
  <entry>
    <title>ClickHouse学习笔记 - 数组拆分再分组</title>
    <link href="http://xupin.im/2022/01/14/clickhouse-array-split-group/"/>
    <id>http://xupin.im/2022/01/14/clickhouse-array-split-group/</id>
    <published>2022-01-13T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.749Z</updated>
    
    <content type="html"><![CDATA[<p>ClickHouse是个由老毛子国内市场使用率第一的搜索引擎Yandex开源的OLAP型列式数据库。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近，数据分析项目要做一个广告素材推广成效分析功能。需求评审下来大概是通过给广告素材打标签进行分类，然后按标签纬度进行分析数据。</p><h3 id="数据库选型"><a href="#数据库选型" class="headerlink" title="数据库选型"></a>数据库选型</h3><p>该项目之前的数据是存放在Elasticsearch，但总是感觉ES的DSL语句过于繁琐不利于阅读且学习成本较高，内部针对该问题讨论之后选用了在大数据处理上同样出色的ClickHouse作为新功能的数据仓库（试点功能233）。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>因为是列式数据库，所以不需要遵守<code>数据库三大范式</code>。</p><a id="more"></a><p>伪表结构：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> creative_daily_summary</span><br><span class="line">(</span><br><span class="line">    <span class="string">`date`</span> <span class="built_in">Date</span>,</span><br><span class="line">    <span class="string">`creative_id`</span> <span class="keyword">String</span>,</span><br><span class="line">    <span class="string">`tags`</span> <span class="built_in">Array</span>(<span class="keyword">String</span>),</span><br><span class="line">    <span class="string">`revenue`</span> Float64,</span><br><span class="line">    <span class="string">`cost`</span> Float64,</span><br><span class="line">    <span class="string">`impressions`</span> Int64,</span><br><span class="line">    <span class="string">`clicks`</span> Int64,</span><br><span class="line">    <span class="string">`installs`</span> Int64</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ENGINE</span> = MergeTree</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">date</span></span><br><span class="line"><span class="keyword">SETTINGS</span> index_granularity = <span class="number">8192</span></span><br></pre></td></tr></table></figure></p><p>这里因为考虑数据冗余的问题，标签存储为数组类型（所以也就出现了这篇笔记）。</p><p>存储一些数据：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> creative_daily_summary (<span class="string">`date`</span>,creative_id,tags,revenue,<span class="keyword">cost</span>,impressions,clicks,installs) <span class="keyword">VALUES</span> (<span class="string">'2022-01-07'</span>,<span class="string">'1721'</span>,[<span class="string">'代入/代入角色/屏幕外角色'</span>,<span class="string">'玩法/装修/修理'</span>,<span class="string">'玩法/模拟经营/建筑升级'</span>,<span class="string">'玩法/小游戏/情景选择(废除)'</span>,<span class="string">'元素/其他/人手'</span>,<span class="string">'元素/其他/表情包'</span>,<span class="string">'元素/场景/农场'</span>],<span class="number">0.0</span>,<span class="number">2.41</span>,<span class="number">2204</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> creative_daily_summary (<span class="string">`date`</span>,creative_id,tags,revenue,<span class="keyword">cost</span>,impressions,clicks,installs) <span class="keyword">VALUES</span> (<span class="string">'2022-01-07'</span>,<span class="string">'1721'</span>,[<span class="string">'代入/代入角色/屏幕外角色'</span>,<span class="string">'玩法/装修/修理'</span>,<span class="string">'玩法/模拟经营/建筑升级'</span>,<span class="string">'玩法/小游戏/情景选择(废除)'</span>,<span class="string">'元素/其他/人手'</span>,<span class="string">'元素/其他/表情包'</span>,<span class="string">'元素/场景/农场'</span>],<span class="number">0.0</span>,<span class="number">0.05</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> creative_daily_summary (<span class="string">`date`</span>,creative_id,tags,revenue,<span class="keyword">cost</span>,impressions,clicks,installs) <span class="keyword">VALUES</span> (<span class="string">'2022-01-08'</span>,<span class="string">'1788'</span>,[<span class="string">'代入/视角镜头/第一人称'</span>,<span class="string">'剧情/情感共鸣/育儿'</span>,<span class="string">'剧情/援助/解救'</span>,<span class="string">'剧情/困境/自然灾害'</span>,<span class="string">'玩法/模拟经营/摘果'</span>,<span class="string">'玩法/模拟经营/引水'</span>,<span class="string">'玩法/模拟经营/建筑升级'</span>,<span class="string">'玩法/改变地形/挖河道'</span>],<span class="number">0.0</span>,<span class="number">130.64</span>,<span class="number">31868</span>,<span class="number">63</span>,<span class="number">7</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> creative_daily_summary (<span class="string">`date`</span>,creative_id,tags,revenue,<span class="keyword">cost</span>,impressions,clicks,installs) <span class="keyword">VALUES</span> (<span class="string">'2022-01-09'</span>,<span class="string">'1788'</span>,[<span class="string">'代入/视角镜头/第一人称'</span>,<span class="string">'剧情/情感共鸣/育儿'</span>,<span class="string">'剧情/援助/解救'</span>,<span class="string">'剧情/困境/自然灾害'</span>,<span class="string">'玩法/模拟经营/摘果'</span>,<span class="string">'玩法/模拟经营/引水'</span>,<span class="string">'玩法/模拟经营/建筑升级'</span>,<span class="string">'玩法/改变地形/挖河道'</span>],<span class="number">0.0</span>,<span class="number">0.04</span>,<span class="number">76</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> creative_daily_summary (<span class="string">`date`</span>,creative_id,tags,revenue,<span class="keyword">cost</span>,impressions,clicks,installs) <span class="keyword">VALUES</span> (<span class="string">'2022-01-10'</span>,<span class="string">'2124'</span>,[<span class="string">'代入/代入角色/固定角色-女性'</span>,<span class="string">'剧情/情感共鸣/购物焦虑'</span>,<span class="string">'目的/目的/拉新'</span>,<span class="string">'形式/技术形式/3D'</span>,<span class="string">'元素/场景/城市街道'</span>,<span class="string">'元素/场景/室内公共场所'</span>],<span class="number">0.0</span>,<span class="number">0.02</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>date</th><th>creative_id</th><th>tags</th><th>revenue</th><th>cost</th><th>impressions</th><th>clicks</th><th>installs</th></tr></thead><tbody><tr><td>2022-01-07</td><td>1721</td><td>[‘代入/代入角色/屏幕外角色’,’玩法/装修/修理’,’玩法/模拟经营/建筑升级’,’玩法/小游戏/情景选择(废除)’,’元素/其他/人手’,’元素/其他/表情包’,’元素/场景/农场’]</td><td>0.0</td><td>2.41</td><td>2204</td><td>0</td><td>0</td></tr><tr><td>2022-01-07</td><td>1721</td><td>[‘代入/代入角色/屏幕外角色’,’玩法/装修/修理’,’玩法/模拟经营/建筑升级’,’玩法/小游戏/情景选择(废除)’,’元素/其他/人手’,’元素/其他/表情包’,’元素/场景/农场’]</td><td>0.0</td><td>0.05</td><td>9</td><td>1</td><td>0</td></tr><tr><td>2022-01-08</td><td>1788</td><td>[‘代入/视角镜头/第一人称’,’剧情/情感共鸣/育儿’,’剧情/援助/解救’,’剧情/困境/自然灾害’,’玩法/模拟经营/摘果’,’玩法/模拟经营/引水’,’玩法/模拟经营/建筑升级’,’玩法/改变地形/挖河道’]</td><td>0.0</td><td>130.64</td><td>31868</td><td>63</td><td>7</td></tr><tr><td>2022-01-09</td><td>1788</td><td>[‘代入/视角镜头/第一人称’,’剧情/情感共鸣/育儿’,’剧情/援助/解救’,’剧情/困境/自然灾害’,’玩法/模拟经营/摘果’,’玩法/模拟经营/引水’,’玩法/模拟经营/建筑升级’,’玩法/改变地形/挖河道’]</td><td>0.0</td><td>0.04</td><td>76</td><td>0</td><td>0</td></tr><tr><td>2022-01-10</td><td>2124</td><td>[‘代入/代入角色/固定角色-女性’,’剧情/情感共鸣/购物焦虑’,’目的/目的/拉新’,’形式/技术形式/3D’,’元素/场景/城市街道’,’元素/场景/室内公共场所’]</td><td>0.0</td><td>0.02</td><td>5</td><td>0</td><td>0</td></tr></tbody></table><h3 id="检索效果"><a href="#检索效果" class="headerlink" title="检索效果"></a>检索效果</h3><p>产品期望实现的需求是统计“标签”的数据，但这个“标签”并不是完整的标签（代入/代入角色/屏幕外角色），而是标签的一部分（比如代入、代入角色、屏幕外角色等，拆分开来的），同时一个广告素材如果满足多个标签即拆分成多条数据。</p><ul><li>思路1</li></ul><p>利用子查询再分组，这样会有数据重复的问题，所以需要再套一层查询去重。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="built_in">date</span>,</span><br><span class="line">tag,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">as</span> <span class="keyword">cost</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="built_in">date</span>,</span><br><span class="line">tag,</span><br><span class="line">creative_id,</span><br><span class="line">sumDistinct(<span class="keyword">cost</span>) <span class="keyword">as</span> <span class="keyword">cost</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="built_in">date</span>,</span><br><span class="line">arrayJoin(tags) <span class="keyword">as</span> t,</span><br><span class="line"><span class="keyword">concat</span>(arrayElement(splitByChar(<span class="string">'/'</span>,t),<span class="number">1</span>),<span class="string">'/'</span>,arrayElement(splitByChar(<span class="string">'/'</span>,t),<span class="number">2</span>)) <span class="keyword">as</span> tag,</span><br><span class="line">creative_id,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">as</span> <span class="keyword">cost</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">creative_daily_summary</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">tag <span class="keyword">in</span> (<span class="string">'代入/代入角色'</span>,<span class="string">'玩法/模拟经营'</span>)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">t,</span><br><span class="line">creative_id,</span><br><span class="line"><span class="built_in">date</span>)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">tag,</span><br><span class="line">creative_id,</span><br><span class="line"><span class="built_in">date</span>)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">tag,</span><br><span class="line"><span class="built_in">date</span></span><br></pre></td></tr></table></figure></p><table><thead><tr><th>date</th><th>tag</th><th>cost</th></tr></thead><tbody><tr><td>2022-01-08</td><td>玩法/模拟经营</td><td>130.64</td></tr><tr><td>2022-01-07</td><td>代入/代入角色</td><td>2.46</td></tr><tr><td>2022-01-10</td><td>代入/代入角色</td><td>0.02</td></tr><tr><td>2022-01-09</td><td>玩法/模拟经营</td><td>0.04</td></tr><tr><td>2022-01-07</td><td>玩法/模拟经营</td><td>2.46</td></tr></tbody></table><ul><li>思路2</li></ul><p>因为深感第一种方式太挫，效率不高且毫无美感（最重要的是总感觉解决的方向不对）。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="built_in">date</span>,</span><br><span class="line">arrayJoin(arrayDistinct(arrayMap(tag -&gt; <span class="keyword">concat</span>(arrayElement(splitByChar(<span class="string">'/'</span>,tag),<span class="number">1</span>),<span class="string">'/'</span>,arrayElement(splitByChar(<span class="string">'/'</span>,tag),<span class="number">2</span>)),tags))) <span class="keyword">as</span> tag,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">as</span> <span class="keyword">cost</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">creative_daily_summary</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line"> tag <span class="keyword">in</span>(<span class="string">'代入/代入角色'</span>,<span class="string">'玩法/模拟经营'</span>)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line"><span class="built_in">date</span>,</span><br><span class="line">tag</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>date</th><th>tag</th><th>cost</th></tr></thead><tbody><tr><td>2022-01-10</td><td>代入/代入角色</td><td>0.02</td></tr><tr><td>2022-01-07</td><td>代入/代入角色</td><td>2.46</td></tr><tr><td>2022-01-08</td><td>玩法/模拟经营</td><td>130.64</td></tr><tr><td>2022-01-07</td><td>玩法/模拟经营</td><td>2.46</td></tr><tr><td>2022-01-09</td><td>玩法/模拟经营</td><td>0.04</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>接触新的事物还是要抱着谦逊的态度先系统的了解一下优势和缺点，不然解决问题时总会陷入定式思维的怪圈（在错误的方向浪费时间和精力）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ClickHouse是个由老毛子国内市场使用率第一的搜索引擎Yandex开源的OLAP型列式数据库。&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;最近，数据分析项目要做一个广告素材推广成效分析功能。需求评审下来大概是通过给广告素材打标签进行分类，然后按标签纬度进行分析数据。&lt;/p&gt;
&lt;h3 id=&quot;数据库选型&quot;&gt;&lt;a href=&quot;#数据库选型&quot; class=&quot;headerlink&quot; title=&quot;数据库选型&quot;&gt;&lt;/a&gt;数据库选型&lt;/h3&gt;&lt;p&gt;该项目之前的数据是存放在Elasticsearch，但总是感觉ES的DSL语句过于繁琐不利于阅读且学习成本较高，内部针对该问题讨论之后选用了在大数据处理上同样出色的ClickHouse作为新功能的数据仓库（试点功能233）。&lt;/p&gt;
&lt;h3 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h3&gt;&lt;p&gt;因为是列式数据库，所以不需要遵守&lt;code&gt;数据库三大范式&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="clickhouse" scheme="http://xupin.im/tags/clickhouse/"/>
    
  </entry>
  
  <entry>
    <title>Go学习笔记 - 控制协程数量</title>
    <link href="http://xupin.im/2021/12/03/go-coroutine-number/"/>
    <id>http://xupin.im/2021/12/03/go-coroutine-number/</id>
    <published>2021-12-02T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.750Z</updated>
    
    <content type="html"><![CDATA[<p>之前因为需要并发同步单张数据表的脚本，因为设置协程数量太多连接数过高导致服务宕机 … 得不偿失，所以想怎么控制一下协程数量</p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>利用channel阻塞，上代码：</p><a id="more"></a><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 允许最大协程数</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">ch &lt;- i <span class="comment">// ch长度等于5时，阻塞等待</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(<span class="string">"记录执行 "</span>, i)</span><br><span class="line">time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="string">"执行完毕 "</span>, &lt;-ch)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理就是利用<code>channel</code>通道的特性，当通道满的时候继续向通道丢数据会阻塞代码执行。</p><p>封装一下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">ch <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">wg *sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 允许最大协程数</span></span><br><span class="line">worker := NewWorker(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">worker.Run(i)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"记录执行 "</span>, i)</span><br><span class="line">time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">key := worker.Done()</span><br><span class="line">fmt.Println(<span class="string">"执行完毕 "</span>, key)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">worker.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorker</span><span class="params">(size <span class="keyword">int</span>)</span> *<span class="title">Worker</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Worker&#123;</span><br><span class="line">ch: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, size),</span><br><span class="line">wg: &amp;sync.WaitGroup&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">Run</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">w.ch &lt;- key</span><br><span class="line">w.wg.Add(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">Done</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">key := &lt;-w.ch</span><br><span class="line">w.wg.Done()</span><br><span class="line"><span class="keyword">return</span> key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">w.wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Goroutine-Pool"><a href="#Goroutine-Pool" class="headerlink" title="Goroutine Pool"></a>Goroutine Pool</h3><p>感觉Duck不必 … 日后再谈</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前因为需要并发同步单张数据表的脚本，因为设置协程数量太多连接数过高导致服务宕机 … 得不偿失，所以想怎么控制一下协程数量&lt;/p&gt;
&lt;h3 id=&quot;Channel&quot;&gt;&lt;a href=&quot;#Channel&quot; class=&quot;headerlink&quot; title=&quot;Channel&quot;&gt;&lt;/a&gt;Channel&lt;/h3&gt;&lt;p&gt;利用channel阻塞，上代码：&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="golang" scheme="http://xupin.im/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go学习笔记 - 并发查询单表</title>
    <link href="http://xupin.im/2021/12/02/go-coroutine-query/"/>
    <id>http://xupin.im/2021/12/02/go-coroutine-query/</id>
    <published>2021-12-01T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.750Z</updated>
    
    <content type="html"><![CDATA[<p>最近接触一个项目，需要每天定时把PgSql一张数据量超大的数据表同步到ClickHouse 思考这种场景下怎么提高同步速度。</p><h3 id="按主键分页"><a href="#按主键分页" class="headerlink" title="按主键分页"></a>按主键分页</h3><p>思路</p><blockquote><p>按照主键排序分区间查询</p></blockquote><a id="more"></a><p>代码<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">maxId := <span class="number">203202</span></span><br><span class="line">pageNum := <span class="number">1500</span></span><br><span class="line">num, _ := strconv.ParseFloat(fmt.Sprintf(<span class="string">"%.2f"</span>, <span class="keyword">float64</span>(maxId)/<span class="keyword">float64</span>(pageNum)), <span class="number">64</span>)</span><br><span class="line">maxPage := <span class="keyword">int</span>(math.Ceil(num))</span><br><span class="line"></span><br><span class="line">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxPage; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">startId := (i * pageNum)</span><br><span class="line">endId := startId + pageNum</span><br><span class="line"><span class="keyword">if</span> endId &gt; maxId &#123;</span><br><span class="line">endId = maxId</span><br><span class="line">&#125;</span><br><span class="line">sql := fmt.Sprintf(<span class="string">"select * from logs where id &gt;= %d and id &lt;= %d"</span>, startId, endId)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"第 %d 页 SQL: %s\n"</span>, i+<span class="number">1</span>, sql)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>优点</p><blockquote><p>命中索引查询</p></blockquote></li><li><p>缺点</p><blockquote><p>PgSql设置主键会影响插入和查询速度，这也是为什么PgSql数据表一般不设置主键的原因</p></blockquote></li></ul><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>思路</p><blockquote><p>多个协程获取同一个游标的数据</p></blockquote><p>代码<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"project/postgresql"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// pgSql client</span></span><br><span class="line">cli := postgresql.GetClient()</span><br><span class="line"></span><br><span class="line"><span class="comment">// trx</span></span><br><span class="line">tx, err := cli.Begin()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算多少个coroutine</span></span><br><span class="line">cnt := <span class="number">0</span></span><br><span class="line">cli.QueryRow(<span class="string">"select count(*) from logs"</span>).Scan(&amp;cnt)</span><br><span class="line">pageNum := <span class="number">1500</span></span><br><span class="line">num, _ := strconv.ParseFloat(fmt.Sprintf(<span class="string">"%.2f"</span>, <span class="keyword">float64</span>(cnt)/<span class="keyword">float64</span>(pageNum)), <span class="number">64</span>)</span><br><span class="line">maxPage := <span class="keyword">int</span>(math.Ceil(num))</span><br><span class="line"></span><br><span class="line"><span class="comment">// cursor</span></span><br><span class="line">cursorName := <span class="string">"cursor_name"</span></span><br><span class="line">cursorQuery := <span class="string">"select * from logs"</span></span><br><span class="line">tx.Query(<span class="string">"DECLARE "</span> + cursorName + <span class="string">" CURSOR FOR "</span> + cursorQuery)</span><br><span class="line"></span><br><span class="line">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">lock := &amp;sync.Mutex&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= maxPage; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁</span></span><br><span class="line">lock.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次取&#123;pageNum&#125;条</span></span><br><span class="line">rows, err := tx.Query(<span class="string">"FETCH FORWARD "</span> + strconv.Itoa(pageNum) + <span class="string">" FROM "</span> + cursorName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理迭代逻辑</span></span><br><span class="line"><span class="comment">// for rows.Next() &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">fmt.Printf(<span class="string">"第 %d 页 结果: %v\n"</span>, i, rows)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="comment">// TODO 一定要迭代完成后再解锁</span></span><br><span class="line">lock.Unlock()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">tx.Commit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>优点</p><blockquote><p>能保证数据的完整，可靠性较高</p></blockquote></li><li><p>缺点</p><blockquote><p>必须等待结果集迭代完成后才能处理下一个</p></blockquote></li></ul><h3 id="为啥不用-offset-limit"><a href="#为啥不用-offset-limit" class="headerlink" title="为啥不用 offset, limit"></a>为啥不用 offset, limit</h3><p>因为<code>offset, limit</code>会扫全表 233</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近接触一个项目，需要每天定时把PgSql一张数据量超大的数据表同步到ClickHouse 思考这种场景下怎么提高同步速度。&lt;/p&gt;
&lt;h3 id=&quot;按主键分页&quot;&gt;&lt;a href=&quot;#按主键分页&quot; class=&quot;headerlink&quot; title=&quot;按主键分页&quot;&gt;&lt;/a&gt;按主键分页&lt;/h3&gt;&lt;p&gt;思路&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;按照主键排序分区间查询&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="golang" scheme="http://xupin.im/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记 - yield</title>
    <link href="http://xupin.im/2021/11/22/python-yield/"/>
    <id>http://xupin.im/2021/11/22/python-yield/</id>
    <published>2021-11-21T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.755Z</updated>
    
    <content type="html"><![CDATA[<p>在程序中除了迭代器还有生成器均是可迭代对象，迭代器是通过移动游标来遍历数据，那生成器呢</p><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>生成器创建方式（python）</p><ul><li>(表达式)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">generator = (i <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) // 这里有区别于 [i <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line">print(generator)  <span class="comment"># &lt;generator object &lt;genexpr&gt; at 0x10c312870&gt;</span></span><br><span class="line">print(next(generator))  <span class="comment"># 1</span></span><br><span class="line">print(next(generator))  <span class="comment"># 2</span></span><br><span class="line">print(next(generator))  <span class="comment"># 3</span></span><br><span class="line">print(next(generator))  <span class="comment"># raise StopIteration</span></span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li>yield<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getGenerator</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]: </span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">    print(<span class="string">"done"</span>)</span><br><span class="line"></span><br><span class="line">generator = getGenerator()</span><br><span class="line">print(generator)  <span class="comment"># &lt;generator object getGenerator at 0x10c3128c0&gt;</span></span><br><span class="line">print(next(generator))  <span class="comment"># 1</span></span><br><span class="line">print(next(generator))  <span class="comment"># 2</span></span><br><span class="line">print(next(generator))  <span class="comment"># 3</span></span><br><span class="line">print(next(generator))  <span class="comment"># done &amp; raise StopIteration</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当<code>yield</code>出现在函数中（yield只能定义在函数中），那么调用时不会直接运行函数而是返回一个生成器对象，生成器也是一个特殊的迭代器（实现了迭代器协议的对象）。</p><ul><li>第一次调用<code>next()</code>函数，遇见<code>yield</code>停下返回yield后面的内容</li><li>再次调用<code>next()</code>函数，从上次yield语句处恢复，如果还存在<code>yield</code>则正常执行，否则函数体执行完毕抛出<code>StopIteration</code>异常<blockquote><p>通俗的来说：yield相当于return，但yield会记住这个返回位置，再次执行会从这个位置开始。</p></blockquote></li></ul><p>生成器中<code>send()</code>是和<code>next()</code>一样能让生成器恢复执行的函数，不同的是<code>send(arg)</code>函数可以传递参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getGenerator</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">        print(<span class="string">"before: "</span>, i)</span><br><span class="line">        t = <span class="keyword">yield</span> i</span><br><span class="line">        print(<span class="string">"after: "</span>, i, t)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">generator = getGenerator()</span><br><span class="line">print(generator)  <span class="comment"># &lt;generator object getGenerator at 0x10c3128c0&gt;</span></span><br><span class="line">generator.send(<span class="literal">None</span>)  <span class="comment"># before:  1</span></span><br><span class="line">next(generator)  <span class="comment"># after:  1 None &amp; before:  2</span></span><br><span class="line">generator.send(<span class="number">22</span>)  <span class="comment"># after:  2 22 &amp; before:  3</span></span><br><span class="line">generator.send(<span class="number">33</span>)  <span class="comment"># after:  3 33 &amp; raise StopIteration</span></span><br></pre></td></tr></table></figure></p><p>注意第一次调用生成器不可以直接传递非None参数，因为yield还未准备好（无返回值），可以<code>generator.send(None)</code>或<code>next(generator)</code>。具体可以参考python源码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char *msg = <span class="string">"can't send non-None value to a "</span></span><br><span class="line">                              <span class="string">"just-started generator"</span>;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/python/cpython/blob/3.9/Objects/genobject.c#L181" target="_blank" rel="noopener">https://github.com/python/cpython/blob/3.9/Objects/genobject.c#L181</a></p><h3 id="迭代协议"><a href="#迭代协议" class="headerlink" title="迭代协议"></a>迭代协议</h3><p>什么是可迭代协议？</p><blockquote><p>当处理迭代时首先调用<code>可迭代对象.__iter__()</code>，返回迭代器。然后通过<code>迭代器.__next__()</code>获取迭代器的元素，直至抛出<code>StopIteration</code>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomGenerator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"look at me"</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.index &lt; len(self.data):</span><br><span class="line">            val = self.data[self.index]</span><br><span class="line">            self.index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">generator = CustomGenerator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">print(generator)  <span class="comment"># &lt;__main__.CustomGenerator object at 0x1047161f0&gt;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> generator:</span><br><span class="line">    print(x)</span><br><span class="line"><span class="comment"># look at me</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">print(next(generator))  <span class="comment"># raise StopIteration</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在程序中除了迭代器还有生成器均是可迭代对象，迭代器是通过移动游标来遍历数据，那生成器呢&lt;/p&gt;
&lt;h3 id=&quot;生成器&quot;&gt;&lt;a href=&quot;#生成器&quot; class=&quot;headerlink&quot; title=&quot;生成器&quot;&gt;&lt;/a&gt;生成器&lt;/h3&gt;&lt;p&gt;生成器创建方式（python）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(表达式)&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;generator = (i &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]) // 这里有区别于 [i &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(generator)  &lt;span class=&quot;comment&quot;&gt;# &amp;lt;generator object &amp;lt;genexpr&amp;gt; at 0x10c312870&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(next(generator))  &lt;span class=&quot;comment&quot;&gt;# 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(next(generator))  &lt;span class=&quot;comment&quot;&gt;# 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(next(generator))  &lt;span class=&quot;comment&quot;&gt;# 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(next(generator))  &lt;span class=&quot;comment&quot;&gt;# raise StopIteration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="python" scheme="http://xupin.im/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Mysql学习笔记 - cursor</title>
    <link href="http://xupin.im/2021/11/18/mysql-cursor/"/>
    <id>http://xupin.im/2021/11/18/mysql-cursor/</id>
    <published>2021-11-17T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.752Z</updated>
    
    <content type="html"><![CDATA[<p>游标（cursor）是可以从数据库检索结果集中每次提取一行记录的机制，游标的作用就是对结果集进行遍历，方便对记录进行操作。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>三种特性：</p><ul><li>只读<blockquote><p>不能更新它</p></blockquote></li><li>非滚动<blockquote><p>根据SQL语句确定顺序，不能向后获取记录和跳过记录</p></blockquote></li><li>敏感/不敏感<blockquote><p>敏感游标指向的是数据表，不敏感游标指向的则是临时数据表。（Mysql使用的是敏感游标）</p></blockquote></li></ul><h3 id="声明游标"><a href="#声明游标" class="headerlink" title="声明游标"></a>声明游标</h3><p>游标使用的变量必须在声明游标之前声明</p><a id="more"></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Mysql</span><br><span class="line">// 不同于其他数据库，Mysql的游标必须声明在存储过程/函数中。</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> cur_func()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> &#123;...VARs&#125; // e.g. <span class="keyword">declare</span> email <span class="built_in">varchar</span>(<span class="number">50</span>)</span><br><span class="line">    <span class="keyword">declare</span> &#123;CUR_NAME&#125; <span class="keyword">cursor</span> <span class="keyword">for</span> &#123;<span class="keyword">STATEMENT</span>&#125;;</span><br><span class="line">    open &#123;CUR_NAME&#125;;</span><br><span class="line">    fetch &#123;CUR_NAME&#125; into &#123;...VARs&#125; // e.g. fetch cur1 into email,name // 取出1行记录 &amp; 把值赋给变量email、name</span><br><span class="line">    close &#123;CUR_NAME&#125;;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">// PgSql</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> &#123;CUR_NAME&#125; <span class="keyword">cursor</span> <span class="keyword">for</span> &#123;<span class="keyword">STATEMENT</span>&#125;;</span><br><span class="line">    fetch &#123;STATEMENT&#125; from &#123;CUR_NAME&#125; // e.g. fetch forward 10 from cur1 取出10行记录</span><br><span class="line">    close &#123;CUR_NAME&#125;;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>游标有着类似指针的作用，它是遍历容器的一套接口（迭代器），简单实现（golang）:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomArray []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Iterator <span class="keyword">struct</span> &#123;</span><br><span class="line">data  CustomArray</span><br><span class="line">index <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cusArr := CustomArray&#123;<span class="string">"1_1"</span>, <span class="number">22</span>, <span class="number">3.3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> iter := cusArr.iterator(); iter.hasNext(); &#123;</span><br><span class="line">fmt.Println(iter.key(), iter.next())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arr CustomArray)</span> <span class="title">iterator</span><span class="params">()</span> *<span class="title">Iterator</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Iterator&#123;</span><br><span class="line">data:  arr,</span><br><span class="line">index: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游标</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iter *Iterator)</span> <span class="title">key</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> iter.index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下一个元素是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iter *Iterator)</span> <span class="title">hasNext</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> iter.index &lt; <span class="built_in">len</span>(iter.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出数据&amp;移动游标</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iter *Iterator)</span> <span class="title">next</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">val := iter.data[iter.index]</span><br><span class="line">iter.index += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的说：游标返回一个数据集合迭代器，当你取一行记录同时游标指向下一个元素。</p><p>举例使用游标的DB库，以下：<br><a href="https://github.com/PyMySQL/PyMySQL/blob/46d17402af/pymysql/cursors.py#L278" target="_blank" rel="noopener">https://github.com/PyMySQL/PyMySQL/blob/46d17402af/pymysql/cursors.py#L278</a><br><a href="https://github.com/golang/go/blob/master/src/database/sql/sql.go#L2983" target="_blank" rel="noopener">https://github.com/golang/go/blob/master/src/database/sql/sql.go#L2983</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;游标（cursor）是可以从数据库检索结果集中每次提取一行记录的机制，游标的作用就是对结果集进行遍历，方便对记录进行操作。&lt;/p&gt;
&lt;h3 id=&quot;特性&quot;&gt;&lt;a href=&quot;#特性&quot; class=&quot;headerlink&quot; title=&quot;特性&quot;&gt;&lt;/a&gt;特性&lt;/h3&gt;&lt;p&gt;三种特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只读&lt;blockquote&gt;
&lt;p&gt;不能更新它&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;非滚动&lt;blockquote&gt;
&lt;p&gt;根据SQL语句确定顺序，不能向后获取记录和跳过记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;敏感/不敏感&lt;blockquote&gt;
&lt;p&gt;敏感游标指向的是数据表，不敏感游标指向的则是临时数据表。（Mysql使用的是敏感游标）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;声明游标&quot;&gt;&lt;a href=&quot;#声明游标&quot; class=&quot;headerlink&quot; title=&quot;声明游标&quot;&gt;&lt;/a&gt;声明游标&lt;/h3&gt;&lt;p&gt;游标使用的变量必须在声明游标之前声明&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="mysql" scheme="http://xupin.im/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql学习笔记 - InnoDB并发死锁问题</title>
    <link href="http://xupin.im/2021/11/15/mysql-deadlock/"/>
    <id>http://xupin.im/2021/11/15/mysql-deadlock/</id>
    <published>2021-11-14T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.752Z</updated>
    
    <content type="html"><![CDATA[<p>项目中某个定时任务执行过程中出现死锁问题，具体错误如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error 1213: Deadlock found when trying to get lock; try restarting transaction</span><br></pre></td></tr></table></figure></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>检查一下表引擎 &amp; 事务隔离级别<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">'%storage_engine%'</span>;</span><br><span class="line">+---------------------------------+-----------+</span><br><span class="line">| Variable_name                   | Value     |</span><br><span class="line">+---------------------------------+-----------+</span><br><span class="line">| default_storage_engine          | InnoDB    |</span><br><span class="line">| default_tmp_storage_engine      | InnoDB    |</span><br><span class="line">| disabled_storage_engines        |           |</span><br><span class="line">| internal_tmp_mem_storage_engine | TempTable |</span><br><span class="line">+---------------------------------+-----------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@global.tx_isolation;</span><br><span class="line">ERROR 1193 (HY000): Unknown system variable <span class="string">'tx_isolation'</span> // Mysql8.0以后取消了该变量</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@transaction_isolation;</span><br><span class="line">+-------------------------+</span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+-------------------------+</span><br><span class="line">| REPEATABLE-READ         |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>默认使用的引擎是InnoDB，Insert、Update、Delete操作会触发排它锁（X锁）即行锁，所以怀疑是不是触发了共享锁（S锁）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status;</span><br><span class="line"></span><br><span class="line">=====================================</span><br><span class="line">2021-11-15 02:42:28 0x2b1f5b160700 INNODB MONITOR OUTPUT</span><br><span class="line">=====================================</span><br><span class="line">Per second averages calculated from the last 59 seconds</span><br><span class="line">...</span><br><span class="line">------------------------</span><br><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2021-11-12 14:21:02 0x2b204ca06700</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 3805455, ACTIVE 0 sec inserting</span><br><span class="line">mysql tables <span class="keyword">in</span> use 1, locked 1</span><br><span class="line">LOCK WAIT 4 lock struct(s), heap size 1136, 3 row lock(s), undo <span class="built_in">log</span> entries 1</span><br><span class="line">MySQL thread id 875327, OS thread handle 47411963238144, query id 20765167 10.85.62.212 dsc update</span><br><span class="line">INSERT INTO `user_tag_distributes` (`created_at`,`updated_at`,`deleted_at`,`app_id`,`tag_name`,`tag_value`,`account_num`) VALUES (<span class="string">'2021-11-12 14:21:02.386'</span>,<span class="string">'2021-11-12 14:21:02.386'</span>,NULL,<span class="string">'im'</span>,<span class="string">'churn_model_v2'</span>,<span class="string">'0.70709264'</span>,1)</span><br><span class="line"></span><br><span class="line">*** (1) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 334 page no 341 n bits 160 index PRIMARY of table `api`.`user_tag_distributes` trx id 3805455 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 89 PHYSICAL RECORD: n_fields 11; compact format; info bits 0</span><br><span class="line"> 0: len 8; hex 000000000002515d; asc       Q];;</span><br><span class="line"> 1: len 6; hex 0000003a110f; asc    :  ;;</span><br><span class="line"> 2: len 7; hex 81000001960110; asc        ;;</span><br><span class="line"> 3: len 7; hex 99ab18e5420f14; asc     B  ;;</span><br><span class="line"> 4: len 7; hex 99ab18e5420f14; asc     B  ;;</span><br><span class="line"> 5: SQL NULL;</span><br><span class="line"> 6: SQL NULL;</span><br><span class="line"> 7: len 2; hex 696d; asc im;;</span><br><span class="line"> 8: len 14; hex 636875726e5f6d6f64656c5f7632; asc churn_model_v2;;</span><br><span class="line"> 9: len 10; hex 302e3730373039323634; asc 0.70709264;;</span><br><span class="line"> 10: len 3; hex 800001; asc    ;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 334 page no 203 n bits 392 index tag of table `api`.`user_tag_distributes` trx id 3805455 lock mode S waiting</span><br><span class="line">Record lock, heap no 88 PHYSICAL RECORD: n_fields 3; compact format; info bits 32</span><br><span class="line"> 0: len 14; hex 636875726e5f6d6f64656c5f7632; asc churn_model_v2;;</span><br><span class="line"> 1: len 9; hex 302e37303730393735; asc 0.7070975;;</span><br><span class="line"> 2: len 8; hex 0000000000022d5f; asc       -_;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 3805441, ACTIVE 0 sec fetching rows</span><br><span class="line">mysql tables <span class="keyword">in</span> use 1, locked 1</span><br><span class="line">LOCK WAIT 89 lock struct(s), heap size 24784, 17767 row lock(s), undo <span class="built_in">log</span> entries 10247</span><br><span class="line">MySQL thread id 875354, OS thread handle 47415383693056, query id 20765093 10.85.62.212 dsc updating</span><br><span class="line">DELETE FROM `user_tag_distributes` WHERE app_id = <span class="string">'im'</span> and tag_name = <span class="string">'churn_model_v2'</span></span><br><span class="line"></span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 334 page no 203 n bits 392 index tag of table `api`.`user_tag_distributes` trx id 3805441 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 88 PHYSICAL RECORD: n_fields 3; compact format; info bits 32</span><br><span class="line"> 0: len 14; hex 636875726e5f6d6f64656c5f7632; asc churn_model_v2;;</span><br><span class="line"> 1: len 9; hex 302e37303730393735; asc 0.7070975;;</span><br><span class="line"> 2: len 8; hex 0000000000022d5f; asc       -_;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 334 page no 341 n bits 160 index PRIMARY of table `api`.`user_tag_distributes` trx id 3805441 lock_mode X waiting</span><br><span class="line">Record lock, heap no 89 PHYSICAL RECORD: n_fields 11; compact format; info bits 0</span><br><span class="line"> 0: len 8; hex 000000000002515d; asc       Q];;</span><br><span class="line"> 1: len 6; hex 0000003a110f; asc    :  ;;</span><br><span class="line"> 2: len 7; hex 81000001960110; asc        ;;</span><br><span class="line"> 3: len 7; hex 99ab18e5420f14; asc     B  ;;</span><br><span class="line"> 4: len 7; hex 99ab18e5420f14; asc     B  ;;</span><br><span class="line"> 5: SQL NULL;</span><br><span class="line"> 6: SQL NULL;</span><br><span class="line"> 7: len 2; hex 696d; asc im;;</span><br><span class="line"> 8: len 14; hex 636875726e5f6d6f64656c5f7632; asc churn_model_v2;;</span><br><span class="line"> 9: len 10; hex 302e3730373039323634; asc 0.70709264;;</span><br><span class="line"> 10: len 3; hex 800001; asc    ;;</span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (1)</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 3945122</span><br><span class="line">Purge <span class="keyword">done</span> <span class="keyword">for</span> trx<span class="string">'s n:o &lt; 3945122 undo n:o &lt; 0 state: running but idle</span></span><br><span class="line"><span class="string">History list length 3</span></span><br><span class="line"><span class="string">LIST OF TRANSACTIONS FOR EACH SESSION:</span></span><br><span class="line"><span class="string">---TRANSACTION 328886640459544, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 328886640456152, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 328886640455304, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 328886640457000, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 328886640448520, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 328886640447672, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 328886640452760, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 328886640458696, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 328886640446824, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 328886640453608, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 328886640457848, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 328886640451912, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 328886640451064, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 328886640454456, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 328886640450216, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 328886640449368, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 328886640445976, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 328886640445128, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">----------------------------</span></span><br><span class="line"><span class="string">END OF INNODB MONITOR OUTPUT</span></span><br><span class="line"><span class="string">============================</span></span><br></pre></td></tr></table></figure><p>通过以上信息确认是因为[事务1]Insert &amp; [事务2]Delete互相等待对方事务释放锁的问题造成死锁，最后[事务1]进行回滚。</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>review代码梳理一下业务逻辑，场景应该如下：</p><table><thead><tr><th>trx1</th><th>trx2</th></tr></thead><tbody><tr><td></td><td>BEGIN</td></tr><tr><td>BEGIN</td><td>DELETE FROM <code>user_tag_distributes</code> WHERE app_id = ‘im’ and tag_name = ‘churn_model_v2’</td></tr><tr><td>DELETE FROM <code>user_tag_distributes</code> WHERE app_id = ‘im’ and tag_name = ‘churn_model_v2’</td><td></td></tr><tr><td>INSERT INTO <code>user_tag_distributes</code> (<code>created_at</code>,<code>updated_at</code>,<code>deleted_at</code>,<code>app_id</code>,<code>tag_name</code>,<code>tag_value</code>,<code>account_num</code>) VALUES (‘2021-11-12 14:21:02.386’,’2021-11-12 14:21:02.386’,NULL,’im’,’churn_model_v2’,’0.70709264’,1)</td><td></td></tr><tr><td>ERROR 1213 (40001): Deadlock found when trying to get lock</td><td></td></tr><tr><td>ROLLBACK</td><td>…</td></tr><tr><td></td><td>COMMIT</td></tr></tbody></table><p>可以看出[事务1]进行Insert操作时发现[事务2]进行Delete操作且已申请X锁，[事务1]想要获取S锁则需要[事务2]提交，所以[事务1]、[事务2]在相互等待对方提交事务（释放锁）。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>目前想到的几种措施：</p><ul><li>尽量避免在并发程序中Delete &amp; Insert操作无缝执行</li><li>并发程序采用分布式锁控制</li><li>程序不允许并发执行</li></ul><p><a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-nutshell.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/mysql-nutshell.html</a><br><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;项目中某个定时任务执行过程中出现死锁问题，具体错误如下:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Error 1213: Deadlock found when trying to get lock; try restarting transaction&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h3&gt;&lt;p&gt;检查一下表引擎 &amp;amp; 事务隔离级别&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mysql&amp;gt; show variables like &lt;span class=&quot;string&quot;&gt;&#39;%storage_engine%&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+---------------------------------+-----------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| Variable_name                   | Value     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+---------------------------------+-----------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| default_storage_engine          | InnoDB    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| default_tmp_storage_engine      | InnoDB    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| disabled_storage_engines        |           |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| internal_tmp_mem_storage_engine | TempTable |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+---------------------------------+-----------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4 rows &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt; (0.00 sec)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysql&amp;gt; select @@global.tx_isolation;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ERROR 1193 (HY000): Unknown system variable &lt;span class=&quot;string&quot;&gt;&#39;tx_isolation&#39;&lt;/span&gt; // Mysql8.0以后取消了该变量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysql&amp;gt; select @@transaction_isolation;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+-------------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| @@transaction_isolation |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+-------------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| REPEATABLE-READ         |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+-------------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 row &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt; (0.00 sec)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="mysql" scheme="http://xupin.im/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql学习笔记 - 数据迁移</title>
    <link href="http://xupin.im/2021/11/12/mysql-migrate/"/>
    <id>http://xupin.im/2021/11/12/mysql-migrate/</id>
    <published>2021-11-11T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.753Z</updated>
    
    <content type="html"><![CDATA[<p>之前项目数据表有分表设计，现在因为业务量增长数据表数据量膨胀数倍导致单表性能不理想 … 所以希望在不影响用户使用的情况下扩展数据表（迁移）</p><h3 id="数据迁移方案"><a href="#数据迁移方案" class="headerlink" title="数据迁移方案"></a>数据迁移方案</h3><p>基本分为<code>热迁移</code>和<code>冷迁移</code>两种方式</p><ul><li>冷迁移</li></ul><p>通俗的来说就是停机迁移，比如某些游戏合服维护等</p><blockquote><p>优点: 操作可靠性高、数据一致性有保证、数据回滚方便</p><p>缺点: 用户体验差</p></blockquote><a id="more"></a><p><img src="/assets/migrate/cold-migrate.jpg" width="400" height="400"></p><ul><li>热迁移</li></ul><p>在不停机的情况下把数据表迁移，新旧表双写</p><blockquote><p>优点: 用户无感知</p><p>缺点: 容易丢失数据、数据一致性不好保证</p></blockquote><p><img src="/assets/migrate/hot-migrate.jpg" width="400" height="400"></p><p>这种热迁移方式是不依赖第三方服务，纯靠DB完成迁移，极端场景下可靠性不确定。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前项目数据表有分表设计，现在因为业务量增长数据表数据量膨胀数倍导致单表性能不理想 … 所以希望在不影响用户使用的情况下扩展数据表（迁移）&lt;/p&gt;
&lt;h3 id=&quot;数据迁移方案&quot;&gt;&lt;a href=&quot;#数据迁移方案&quot; class=&quot;headerlink&quot; title=&quot;数据迁移方案&quot;&gt;&lt;/a&gt;数据迁移方案&lt;/h3&gt;&lt;p&gt;基本分为&lt;code&gt;热迁移&lt;/code&gt;和&lt;code&gt;冷迁移&lt;/code&gt;两种方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;冷迁移&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通俗的来说就是停机迁移，比如某些游戏合服维护等&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;优点: 操作可靠性高、数据一致性有保证、数据回滚方便&lt;/p&gt;
&lt;p&gt;缺点: 用户体验差&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="mysql" scheme="http://xupin.im/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Git小知识 - depth</title>
    <link href="http://xupin.im/2021/11/01/git-depth/"/>
    <id>http://xupin.im/2021/11/01/git-depth/</id>
    <published>2021-10-31T16:00:00.000Z</published>
    <updated>2022-12-15T04:31:24.364Z</updated>
    
    <content type="html"><![CDATA[<p>有时候git项目比较大，git clone会因为各种原因中断，但是Git并不会断点续“传”再次clone又是重新来过,类似这种问题…让人很是苦恼<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ error: RPC failed; HTTP 504 curl 22 The requested URL returned error: 504 Gateway Time-out</span><br><span class="line">$ ...</span><br><span class="line">$ error: RPC failed; curl 18 transfer closed with outstanding <span class="built_in">read</span> data remaining</span><br></pre></td></tr></table></figure></p><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><ul><li><p>git配置流</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global http.lowSpeedLimit 0 // 最小速度</span><br><span class="line">$ git config --global http.lowSpeedTime 999999 // 最大速度</span><br><span class="line">$ git config --global http.postBuffer 524288000 // 文件大小</span><br><span class="line">$ git config --global compression 0 // 关闭压缩</span><br></pre></td></tr></table></figure></li><li><p>分块拉取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --depth=1 &#123;repo&#125; // 拉取最新的代码（最后一次commit）</span><br></pre></td></tr></table></figure></li></ul><p>但这样会带来其他的小问题，就是拉下来的代码默认分支既不是master也不是其他分支 … 需要拉取完整的项目<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch --unshallow // 拉取深层代码</span><br><span class="line">$ git config remote.origin.fetch <span class="string">"+refs/heads/*:refs/remotes/origin/*"</span> // 修正remote关系（修改之前: <span class="string">"fetch = +refs/heads/master:refs/remotes/origin/master"</span>）</span><br><span class="line">$ git fetch -pv // 拉取所有分支</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有时候git项目比较大，git clone会因为各种原因中断，但是Git并不会断点续“传”再次clone又是重新来过,类似这种问题…让人很是苦恼&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;</summary>
      
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="biscuits" scheme="http://xupin.im/tags/biscuits/"/>
    
    <category term="git" scheme="http://xupin.im/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 - 控制反转/依赖注入</title>
    <link href="http://xupin.im/2020/10/18/design-ioc-di/"/>
    <id>http://xupin.im/2020/10/18/design-ioc-di/</id>
    <published>2020-10-17T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.749Z</updated>
    
    <content type="html"><![CDATA[<p>Laravel框架中控制反转和依赖注入功能是怎么实现的？<br>其实控制反转和依赖注入是一种设计思想，它最早源于Java Spring框架设计中的机制，所以身边如果有做Java开发的小伙伴~简单聊聊就能明白许多。</p><h3 id="1-依赖注入"><a href="#1-依赖注入" class="headerlink" title="1.依赖注入"></a>1.依赖注入</h3><p>依赖注入（Dependency Injection），通俗的解释是当我们构建对象时需要的参数，只要不是手动创建而是以实例对象的形式注入都可以称为依赖注入。</p><p>举个例子，一个小游戏中玩家可以创建不同的职业。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 职业接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取职业名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dh</span> <span class="keyword">implements</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 职业名</span></span><br><span class="line">    <span class="keyword">protected</span> $name = <span class="string">'猎魔人'</span>;</span><br><span class="line">    <span class="comment">// 攻击成长</span></span><br><span class="line">    <span class="keyword">protected</span> $attack;</span><br><span class="line">    <span class="comment">// 速度成长</span></span><br><span class="line">    <span class="keyword">protected</span> $speed;</span><br><span class="line">    <span class="comment">// 气血成长</span></span><br><span class="line">    <span class="keyword">protected</span> $hp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($attack,$speed,$hp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;attack = $attack;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;speed = $speed;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;hp = $hp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 职业</span></span><br><span class="line">    <span class="keyword">protected</span> $role;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($role)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;role = $role;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 猎魔人</span></span><br><span class="line">$dh = <span class="keyword">new</span> Dh(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家1-&gt;猎魔人</span></span><br><span class="line">$player1 = <span class="keyword">new</span> Player($dh);</span><br></pre></td></tr></table></figure><a id="more"></a><p>以上是创建玩家角色的逻辑，创建角色<code>“player1”</code>时选择角色<code>“dh”</code>，那么这种方式其实就是依赖注入。</p><h3 id="2-控制反转（Ioc）"><a href="#2-控制反转（Ioc）" class="headerlink" title="2.控制反转（Ioc）"></a>2.控制反转（Ioc）</h3><p>控制反转（Inversion of Control），从字面意思来理解就是把控制权反转，那么究竟怎么反转呢？</p><p>之前创建玩家角色的逻辑，通过程序可以看出所有依赖对象都是程序主动去创建（职业对象，玩家对象）。那么如果我们想把所有需要的参数都提前准备好，怎么优化？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $binds;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> $instances;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bind</span><span class="params">($abstract, $concrete)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($concrete <span class="keyword">instanceof</span> Closure) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;binds[$abstract] = $concrete;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;instances[$abstract] = $concrete;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">make</span><span class="params">($abstract, $parameters = [])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;instances[$abstract])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;instances[$abstract];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        array_unshift($parameters, <span class="keyword">$this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> call_user_func_array(<span class="keyword">$this</span>-&gt;binds[$abstract], $parameters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$container = <span class="keyword">new</span> Container();</span><br><span class="line"></span><br><span class="line">$container-&gt;bind(<span class="string">'player'</span>, <span class="function"><span class="keyword">function</span><span class="params">($container, $role)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Player($container-&gt;make($role));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$container-&gt;bind(<span class="string">'dh'</span>, <span class="function"><span class="keyword">function</span><span class="params">($container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Dh(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家1-&gt;猎魔人</span></span><br><span class="line">$player1 = $container-&gt;make(<span class="string">'player'</span>, [<span class="string">'dh'</span>]);</span><br></pre></td></tr></table></figure><p>加入了一个名叫<code>“Container”</code>的类，里面存放提前设计好的对象，当程序需要某些依赖对象时<code>“Container”</code>自动帮你去寻找执行。这其实就是<br>Ioc设计思想中遵循“Don’t call us, we’ll call you”的原则，不需要程序去创建依赖，而是主动去帮程序寻找相应依赖。这也就是所说的控制反转，从狭义上讲依赖注入其实算是控制反转的一种实现。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>可能很多小伙伴会觉得控制反转的思想和工厂模式很相像，它们是不是就是同一个东西呢？有兴趣的小伙伴可以去看看<a href="https://stackoverflow.com/questions/557742/dependency-injection-vs-factory-pattern" target="_blank" rel="noopener">Dependency Injection vs Factory Pattern</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Laravel框架中控制反转和依赖注入功能是怎么实现的？&lt;br&gt;其实控制反转和依赖注入是一种设计思想，它最早源于Java Spring框架设计中的机制，所以身边如果有做Java开发的小伙伴~简单聊聊就能明白许多。&lt;/p&gt;
&lt;h3 id=&quot;1-依赖注入&quot;&gt;&lt;a href=&quot;#1-依赖注入&quot; class=&quot;headerlink&quot; title=&quot;1.依赖注入&quot;&gt;&lt;/a&gt;1.依赖注入&lt;/h3&gt;&lt;p&gt;依赖注入（Dependency Injection），通俗的解释是当我们构建对象时需要的参数，只要不是手动创建而是以实例对象的形式注入都可以称为依赖注入。&lt;/p&gt;
&lt;p&gt;举个例子，一个小游戏中玩家可以创建不同的职业。&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 职业接口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Role&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 获取职业名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Dh&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Role&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 职业名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; $name = &lt;span class=&quot;string&quot;&gt;&#39;猎魔人&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 攻击成长&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; $attack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 速度成长&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; $speed;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 气血成长&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; $hp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__construct&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;($attack,$speed,$hp)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;$this&lt;/span&gt;-&amp;gt;attack = $attack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;$this&lt;/span&gt;-&amp;gt;speed = $speed;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;$this&lt;/span&gt;-&amp;gt;hp = $hp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;$this&lt;/span&gt;-&amp;gt;name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 玩家类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Player&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 职业&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; $role;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__construct&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;($role)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;$this&lt;/span&gt;-&amp;gt;role = $role;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 猎魔人&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$dh = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Dh(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 玩家1-&amp;gt;猎魔人&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$player1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Player($dh);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="design" scheme="http://xupin.im/tags/design/"/>
    
  </entry>
  
  <entry>
    <title>Mysql学习笔记 - 聚簇索引和回表查询的关系</title>
    <link href="http://xupin.im/2020/08/12/mysql-clustered-index/"/>
    <id>http://xupin.im/2020/08/12/mysql-clustered-index/</id>
    <published>2020-08-11T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.752Z</updated>
    
    <content type="html"><![CDATA[<p>之前简单了解过Mysql的索引，今天来学习一下Mysql（InnoDB）的聚簇索引以及SQL为什么会产生回表查询？</p><h3 id="1-什么是回表查询？"><a href="#1-什么是回表查询？" class="headerlink" title="1. 什么是回表查询？"></a>1. 什么是回表查询？</h3><p>都知道Mysql存储的数据结构是B+Tree，所以当查询数据的时候能最快找到叶子节点的检索方式时是最快的。比如：主键直接定位行记录，而有些查询需要先检索索引树找到叶子节点的主键值，再通过主键值定位行记录这种扫描2次索引树的方式就叫做回表查询。</p><p>如何确定SQL语句会不会造成回表查询？如下表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`users`</span>  (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`user`</span> <span class="built_in">varchar</span>(<span class="number">125</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`status`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`created_at`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> <span class="string">`user`</span>(<span class="string">`user`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">INDEX</span> <span class="string">`name`</span>(<span class="string">`name`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span> AUTO_INCREMENT = <span class="number">1</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8mb4 <span class="keyword">COLLATE</span> = utf8mb4_unicode_ci ROW_FORMAT = <span class="keyword">Compact</span>;</span><br></pre></td></tr></table></figure></p><p>2种查询方式：</p><a id="more"></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 未回表查询</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'test1'</span>;</span><br><span class="line">+<span class="comment">------+-------------+-------+------+---------------+------+---------+-------+------+--------------------------+</span></span><br><span class="line">| id   | select_type | table | type | possible_keys | key  | key_len | ref   | rows | Extra                    |</span><br><span class="line">+<span class="comment">------+-------------+-------+------+---------------+------+---------+-------+------+--------------------------+</span></span><br><span class="line">|    1 | SIMPLE      | users | ref  | name          | name | 202     | const |    1 | Using where; Using index |</span><br><span class="line">+<span class="comment">------+-------------+-------+------+---------------+------+---------+-------+------+--------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回表查询</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">user</span>,<span class="keyword">name</span> <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'test1'</span>;</span><br><span class="line">+<span class="comment">------+-------------+-------+------+---------------+------+---------+-------+------+-----------------------+</span></span><br><span class="line">| id   | select_type | table | type | possible_keys | key  | key_len | ref   | rows | Extra                 |</span><br><span class="line">+<span class="comment">------+-------------+-------+------+---------------+------+---------+-------+------+-----------------------+</span></span><br><span class="line">|    1 | SIMPLE      | users | ref  | name          | name | 202     | const |    1 | Using index condition |</span><br><span class="line">+<span class="comment">------+-------------+-------+------+---------------+------+---------+-------+------+-----------------------+</span></span><br></pre></td></tr></table></figure><p>注意看<code>Extra</code>字段，当值为<code>Using index condition</code>时表示该SQL需要回表查询，那以上两条SQL到底有什么不同呢？</p><ol><li><p><font color="gray">SQL1</font>命中<code>name</code>索引并且在索引树的叶子节点找到主键<code>id</code>，满足了查询需求所以不需要回表查询其他字段。</p></li><li><p><font color="gray">SQL2</font>同样是命中<code>name</code>索引并且在索引树叶子节点找到主键<code>id</code>，但还有一个<code>user</code>字段没有得到，所以需要拿着主键<code>id</code>去索引树查询<code>user</code>字段。</p></li></ol><p>以上就是是否回表查询的区别，回表查询会额外产生一次查询的开销，故此效率较低。不过回表查询和聚簇索引又有什么关联呢？为什么回表查询需要遍历2次索引树呢？</p><h3 id="2-聚簇索引"><a href="#2-聚簇索引" class="headerlink" title="2. 聚簇索引"></a>2. 聚簇索引</h3><p>InnoDB的索引类型之前有说过，多数使用B+Tree做索引但在实现上又区分为：<code>聚簇索引</code>和<code>辅助索引</code>。</p><ul><li>聚簇索引（Clustered Index）</li></ul><blockquote><p>聚簇索引的叶子节点存储行记录，InnoDB有且只有一个聚簇索引。聚簇索引的每一个叶子节点都有一个指向相邻叶子节点的指针，所以面对Range查询聚簇索引效率很高。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InnoDB默认主键是聚簇索引，如果没有定义主键则第一个Not Null &amp; Unique索引列为聚簇索引。如果以上条件都不满足，则会生成一个6字节的隐式自增长主键`row-id`。</span><br></pre></td></tr></table></figure><p>（<font color="yellow">这也是为什么InnoDB引擎下要求数据表尽可能都要创建主键的原因</font>。）</p><ul><li>辅助索引（Secondary Index）</li></ul><blockquote><p>辅助索引的叶子节点存储主键值（聚簇索引）。</p></blockquote><p>了解了索引树的结构，其实也就明白了为什么明明命中了索引却还会产生回表查询需要扫描2次索引树，即：先扫描辅助索引树拿到主键值，再扫描聚簇索引树获取行记录。</p><h3 id="3-如何避免回表查询？"><a href="#3-如何避免回表查询？" class="headerlink" title="3. 如何避免回表查询？"></a>3. 如何避免回表查询？</h3><p>避免回表查询这里有个概念：覆盖索引（Covering index），Mysql官方虽然没有明确定义<code>覆盖索引</code>但是有同样的概念出现。</p><blockquote><p>查询的字段尽可能在一棵索引树都能获取到，避免回表。</p></blockquote><p>（概念出处：<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-extra-information" target="_blank" rel="noopener">Using index</a>）</p><p>具体怎么操作呢？直接上SQL。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`users`</span> <span class="keyword">DROP</span> <span class="keyword">INDEX</span> <span class="string">`name`</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`users`</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> <span class="string">`user_name`</span> ( <span class="string">`user`</span>, <span class="string">`name`</span> );</span><br></pre></td></tr></table></figure></p><p>创建<code>user</code>、<code>name</code>复合索引，这样就能够覆盖索引不需要回表。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>埋个坑，后面有时间会继续学习相比辅助索引聚簇索引平均会减少多少次IO操作。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前简单了解过Mysql的索引，今天来学习一下Mysql（InnoDB）的聚簇索引以及SQL为什么会产生回表查询？&lt;/p&gt;
&lt;h3 id=&quot;1-什么是回表查询？&quot;&gt;&lt;a href=&quot;#1-什么是回表查询？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是回表查询？&quot;&gt;&lt;/a&gt;1. 什么是回表查询？&lt;/h3&gt;&lt;p&gt;都知道Mysql存储的数据结构是B+Tree，所以当查询数据的时候能最快找到叶子节点的检索方式时是最快的。比如：主键直接定位行记录，而有些查询需要先检索索引树找到叶子节点的主键值，再通过主键值定位行记录这种扫描2次索引树的方式就叫做回表查询。&lt;/p&gt;
&lt;p&gt;如何确定SQL语句会不会造成回表查询？如下表：&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`users`&lt;/span&gt;  (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; AUTO_INCREMENT,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`user`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;125&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;CHARACTER&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;SET&lt;/span&gt; utf8mb4 &lt;span class=&quot;keyword&quot;&gt;COLLATE&lt;/span&gt; utf8mb4_unicode_ci &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`name`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;CHARACTER&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;SET&lt;/span&gt; utf8mb4 &lt;span class=&quot;keyword&quot;&gt;COLLATE&lt;/span&gt; utf8mb4_unicode_ci &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`status`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;tinyint&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`created_at`&lt;/span&gt; datetime &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY &lt;span class=&quot;keyword&quot;&gt;KEY&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;`id`&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;USING&lt;/span&gt; BTREE,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;UNIQUE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;INDEX&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`user`&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;`user`&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;USING&lt;/span&gt; BTREE,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;INDEX&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`name`&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;`name`&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;USING&lt;/span&gt; BTREE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) &lt;span class=&quot;keyword&quot;&gt;ENGINE&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;InnoDB&lt;/span&gt; AUTO_INCREMENT = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CHARACTER&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;SET&lt;/span&gt; = utf8mb4 &lt;span class=&quot;keyword&quot;&gt;COLLATE&lt;/span&gt; = utf8mb4_unicode_ci ROW_FORMAT = &lt;span class=&quot;keyword&quot;&gt;Compact&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;2种查询方式：&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="mysql" scheme="http://xupin.im/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习笔记 - Key事件通知</title>
    <link href="http://xupin.im/2020/08/10/redis-keyspace-notify/"/>
    <id>http://xupin.im/2020/08/10/redis-keyspace-notify/</id>
    <published>2020-08-09T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.756Z</updated>
    
    <content type="html"><![CDATA[<p>网上购物看到自己喜欢的东西加入购物车然后付款，但是在付款的突然不想要了 … 往往这个订单会给一个30分钟的支付时间，时间一到就自动关闭了 所以这是怎么做到的呢？</p><h3 id="1-实现方式"><a href="#1-实现方式" class="headerlink" title="1.实现方式"></a>1.实现方式</h3><ul><li><p>轮询</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">脚本每隔一定时间就去数据表检查一下状态，是否过期需要关闭。</span><br></pre></td></tr></table></figure></li><li><p>定时器</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建订单时开始计时，计时结束后直接处理关闭订单。</span><br></pre></td></tr></table></figure></li><li><p>数据库事件+存储过程</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据库建立检查事件，每隔一定时间去执行一次存储过程。</span><br></pre></td></tr></table></figure></li><li><p>Key事件通知</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于更改任何Redis Key的每个操作，都可以配置Redis将消息发布到Pub/Sub，然后订阅这些通知。</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-数据库事件-存储过程"><a href="#2-数据库事件-存储过程" class="headerlink" title="2.数据库事件+存储过程"></a>2.数据库事件+存储过程</h3><p>不多说，直接上SQL</p><a id="more"></a><ol><li><p>订单表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`orders`</span>  (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`good_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`status`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'0:待付款，1:已付款，-1:订单关闭'</span>,</span><br><span class="line">  <span class="string">`created_at`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span> AUTO_INCREMENT = <span class="number">1</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8mb4 <span class="keyword">COLLATE</span> = utf8mb4_unicode_ci ROW_FORMAT = <span class="keyword">Compact</span>;</span><br></pre></td></tr></table></figure></li><li><p>创建存储过程，处理关闭订单。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> job_proce()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"> <span class="keyword">update</span> orders <span class="keyword">set</span> <span class="keyword">status</span> = <span class="number">-1</span> <span class="keyword">where</span> time_to_sec(<span class="keyword">timediff</span>(<span class="keyword">now</span>(), created_at)) &gt; <span class="number">1800</span> <span class="keyword">and</span> <span class="keyword">status</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure></li><li><p>创建事件，调用存储过程。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> event_scheduler = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EVENT</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> job_event</span><br><span class="line"><span class="keyword">ON</span> SCHEDULE EVERY <span class="number">1</span> <span class="keyword">SECOND</span> <span class="comment"># 1秒检查一次</span></span><br><span class="line"><span class="keyword">ON</span> COMPLETION <span class="keyword">PRESERVE</span>  </span><br><span class="line"><span class="keyword">DO</span> <span class="keyword">CALL</span> job_proce();</span><br></pre></td></tr></table></figure></li><li><p>开启事件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">EVENT</span> job_event <span class="keyword">ON</span>  COMPLETION <span class="keyword">PRESERVE</span> <span class="keyword">ENABLE</span>;</span><br></pre></td></tr></table></figure></li></ol><p>这样<code>job_event</code>事件就会以1秒/次的频率去执行<code>job_proce</code>存储过程执行数据检查。</p><h3 id="3-Key事件通知"><a href="#3-Key事件通知" class="headerlink" title="3. Key事件通知"></a>3. Key事件通知</h3><p>Key事件通知（Redis Keyspace Notifications）机制自2.8版本以后出现，该机制默认是关闭的。可通过配置<code>redis.conf</code>进行开启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">notify-keyspace-events Ex # E表示Key事件通知，x代表Key过期行为。</span><br><span class="line"></span><br><span class="line"># notify-keyspace-events可配置参数</span><br><span class="line"># K 键空间事件，以__keyspace@&lt;db&gt;__前缀发布。</span><br><span class="line"># E 键事件事件，以__keyevent@&lt;db&gt;__前缀发布。</span><br><span class="line"># g 通用命令（非类型特定），如DEL，EXPIRE，RENAME等等</span><br><span class="line"># $ 字符串命令</span><br><span class="line"># l 列表命令</span><br><span class="line"># s 集合命令</span><br><span class="line"># h 哈希命令</span><br><span class="line"># z 有序集合命令</span><br><span class="line"># x 过期事件（每次键到期时生成的事件）</span><br><span class="line"># e 被驱逐的事件（当一个键由于达到最大内存而被驱逐时产生的事件）</span><br><span class="line"># A g$lshzxe的别名，因此字符串AKE表示所有的事件。</span><br></pre></td></tr></table></figure></p><p>修改配置开启Key事件通知以后，当Redis在删除过期Key的时候会向指定channel（过期行为的channel：<code>__keyevent@0__:expired</code>） publish消息，该消息可以使用subscribe/psubscribe进行订阅。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; PSUBSCRIBE __keyevent@<span class="number">0</span>__:expired</span><br><span class="line">Reading messages... (<span class="built_in">press</span> Ctrl-C to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">"psubscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"__keyevent@0__:expired"</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>所以我们只需要写个程序执行redis-&gt;psubscribe()进行监听即可。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>emmmm…</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;网上购物看到自己喜欢的东西加入购物车然后付款，但是在付款的突然不想要了 … 往往这个订单会给一个30分钟的支付时间，时间一到就自动关闭了 所以这是怎么做到的呢？&lt;/p&gt;
&lt;h3 id=&quot;1-实现方式&quot;&gt;&lt;a href=&quot;#1-实现方式&quot; class=&quot;headerlink&quot; title=&quot;1.实现方式&quot;&gt;&lt;/a&gt;1.实现方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;轮询&lt;/p&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;脚本每隔一定时间就去数据表检查一下状态，是否过期需要关闭。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定时器&lt;/p&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;创建订单时开始计时，计时结束后直接处理关闭订单。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据库事件+存储过程&lt;/p&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;数据库建立检查事件，每隔一定时间去执行一次存储过程。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Key事件通知&lt;/p&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;对于更改任何Redis Key的每个操作，都可以配置Redis将消息发布到Pub/Sub，然后订阅这些通知。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-数据库事件-存储过程&quot;&gt;&lt;a href=&quot;#2-数据库事件-存储过程&quot; class=&quot;headerlink&quot; title=&quot;2.数据库事件+存储过程&quot;&gt;&lt;/a&gt;2.数据库事件+存储过程&lt;/h3&gt;&lt;p&gt;不多说，直接上SQL&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="redis" scheme="http://xupin.im/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Git小知识 - Clone项目速度慢的小技巧</title>
    <link href="http://xupin.im/2020/07/05/git-cloning-slow/"/>
    <id>http://xupin.im/2020/07/05/git-cloning-slow/</id>
    <published>2020-07-04T16:00:00.000Z</published>
    <updated>2022-12-15T04:31:28.035Z</updated>
    
    <content type="html"><![CDATA[<p>碰上github网络抽风的时候，恰巧你又需要拉取github上托管的项目，这个时候看着2kb/s的下载速度是不是很抓狂？</p><h3 id="粗暴的解决方式"><a href="#粗暴的解决方式" class="headerlink" title="粗暴的解决方式"></a>粗暴的解决方式</h3><p>打开<a href="https://www.ipaddress.com" target="_blank" rel="noopener">ipaddress</a>查询以下三个域名的ip，写到hosts文件中。</p><ul><li>github.com</li><li>github.global.ssl.fastly.net</li><li>codeload.github.com</li></ul><h3 id="进阶的方式"><a href="#进阶的方式" class="headerlink" title="进阶的方式"></a>进阶的方式</h3><a id="more"></a><p>挂代理，哦豁<br>export ALL_PROXY=socks5://127.0.0.1:4000</p><h3 id="究极方式"><a href="#究极方式" class="headerlink" title="究极方式"></a>究极方式</h3><ol><li><p>复制你要拉取的项目github地址，比如：<a href="https://github.com/v2ray/v2ray-core" target="_blank" rel="noopener">https://github.com/v2ray/v2ray-core</a></p></li><li><p>打开<a href="https://gitee.com" target="_blank" rel="noopener">码云</a>，创建仓库-&gt;从 GitHub / GitLab 导入仓库</p></li><li><p>搞定！git clone <a href="https://gitee.com/xupinbest/v2ray-core" target="_blank" rel="noopener">https://gitee.com/xupinbest/v2ray-core</a></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;碰上github网络抽风的时候，恰巧你又需要拉取github上托管的项目，这个时候看着2kb/s的下载速度是不是很抓狂？&lt;/p&gt;
&lt;h3 id=&quot;粗暴的解决方式&quot;&gt;&lt;a href=&quot;#粗暴的解决方式&quot; class=&quot;headerlink&quot; title=&quot;粗暴的解决方式&quot;&gt;&lt;/a&gt;粗暴的解决方式&lt;/h3&gt;&lt;p&gt;打开&lt;a href=&quot;https://www.ipaddress.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ipaddress&lt;/a&gt;查询以下三个域名的ip，写到hosts文件中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github.com&lt;/li&gt;
&lt;li&gt;github.global.ssl.fastly.net&lt;/li&gt;
&lt;li&gt;codeload.github.com&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;进阶的方式&quot;&gt;&lt;a href=&quot;#进阶的方式&quot; class=&quot;headerlink&quot; title=&quot;进阶的方式&quot;&gt;&lt;/a&gt;进阶的方式&lt;/h3&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="github" scheme="http://xupin.im/tags/github/"/>
    
    <category term="biscuits" scheme="http://xupin.im/tags/biscuits/"/>
    
  </entry>
  
  <entry>
    <title>Go学习笔记 - goroutine</title>
    <link href="http://xupin.im/2020/06/12/goroutine/"/>
    <id>http://xupin.im/2020/06/12/goroutine/</id>
    <published>2020-06-11T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.751Z</updated>
    
    <content type="html"><![CDATA[<p>在现在大数据、高并发，到处都充斥着流量的互联网时代，能不能应对高并发俨然已经发展成一个衡量服务端架构是否合格的标准，作为程序媛我们思考如何利用语言在代码层面最优设计能应对并发的程序去并行处理任务。在程序中对于任务并行处理一般趋于使用：进程、线程，以及另外一种：<code>协程</code>。支持协程的语言有很多，比如：C/C++、Ruby、 Python（2.5+）、Golang等等，它们有些是本身语言支持协程，有些则是需要引入第三方包来使用。不过，我们主要来学习一下Golang这门语言（简称Go），它是如何理解以及实现协程的。</p><h3 id="一、进程、线程和协程的前世今生"><a href="#一、进程、线程和协程的前世今生" class="headerlink" title="一、进程、线程和协程的前世今生"></a>一、进程、线程和协程的前世今生</h3><p>都知道一台计算机的核心是CPU，它承担着所有的运算。而计算机承载的操作系统（内核）则是负责所有任务的处理和调度CPU以及资源的分配。如果用人类来比喻，大脑是CPU，思维则是操作系统（内核）。</p><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>最早的计算机每次只能运行一个程序，如果还有其他程序需要执行则要排队等待。后来CPU运算能力提高了，这种方式过于原始有些浪费性能，于是尝试让多个程序可以并行执行，但是这样面临一个新的问题：跑在同一个CPU中的程序都会使用计算机资源，那程序的运行状态和数据怎么保障？<code>进程</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进程是内核资源管理分配的最小单位，每个进程都有独立的虚拟地址空间。内核中的每个程序都运行在独立进程的上下文中，上下文是由程序正常运行需要的一系列参数组成，参数包括存储器中的代码和数据，寄存器中的内容以及进程打开的文件描述符（文件句柄）等。可以把上下文通俗理解为：`环境`。</span><br></pre></td></tr></table></figure></p><p>如果程序在运行过程中需要进行IO操作，IO操作阻塞了程序后面的计算，这时候CPU属于空闲状态，那内核会把CPU切换到其他进程去处理。不过当进程数量变高以后，计算机的大部分资源都被进程切换这个操作消耗掉了。为什么说进程切换操作消耗资源代价比较高？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所谓进程切换其实就是上下文切换，需要切换新的页表并加载新的虚拟地址空间、切换内核栈以及硬件上下文等。只要发生进程切换操作就得反复进入内核，加载切换一系列状态。</span><br></pre></td></tr></table></figure></p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>为了减少这种开销，<code>线程</code>应运而生。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程是内核调度CPU执行的最小单位，线程是运行在进程上下文的逻辑流，线程是具体执行程序的单位。一个进程至少包含一个主线程（可以拥有多个子线程），但是一个线程只能存在于一个进程中。</span><br></pre></td></tr></table></figure></p><p>线程切换相比进程切换开销就小了很多，线程切换只需要把寄存器刷新即可。</p><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>后面程序媛们发现线程这样还是有性能瓶颈（IO阻塞），无论是进程还是线程因为涉及到大量的计算机资源，所以都是由内核调度管理。能不能开发一种由代码控制的线程呢？这就是<code>协程</code>。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协程是由用户控制的线程（用户态线程），协程在程序中实现自我调度，不需要像进程切换一样进入内核加载切换状态，提高了线程在IO上的性能问题（IO多路复用）。</span><br></pre></td></tr></table></figure><p>但是协程也有个致命的问题，假如进程中的某一程序出现了阻塞操作同时被CPU中断处理（抢占式调度），那么该进程中的所有线程都会被阻塞。</p><p>后面会专门写一篇关于进程和线程以及协程的特性以及区别。（不够详细，埋坑Orz~）</p><h3 id="二、什么是goroutine？"><a href="#二、什么是goroutine？" class="headerlink" title="二、什么是goroutine？"></a>二、什么是goroutine？</h3><p>上面简单学习了进程和线程以及协程的渊源，虽然不够详细但是我们大概知道其实在进程或者线程甚至于协程存在的性能瓶颈大部分是CPU调度问题。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> // <span class="title">Go</span>语言启动协程，只需要使用<span class="title">go</span>关键字即可启动协程运行函数。使用<span class="title">go</span>关键字创建的这个协程就叫做`<span class="title">goroutine</span>`</span></span><br></pre></td></tr></table></figure><p>之前说了goroutine是Go语言的协程，其实这么理解是可以的但goroutine比协程更强大。它们使用的线程模型有着本质的区别，如下：</p><blockquote><p>goroutine通过通道来通信，而协程通过让出执行和恢复操作来通信。</p><p>goroutine通过Go语言的调度器进行调度，而协程通过程序本身调度。</p></blockquote><p>大部分语言或者第三方库提供的协程就是使用的用户态线程模型，但goroutine使用的不是传统的用户态线程模型。以下主流的线程模型：</p><ul><li>内核级线程模型<br>  内核级别的线程的状态切换需要内核直接处理，所以内核清楚的知道每一个KSE（Kernel Scheduling Entity）的存在（即内核线程和KSE是一对一关系），它们可以全系统内进行资源的竞争。</li><li>用户级线程模型（用户态线程，协程）<br>  用户态级别的线程受用户控制，内核并不直接知道用户态线程的存在（为什么这么说？因为用户态线程和内核线程存在着多对一的关系，即多个用户态线程对应一个内核线程），一般用户态多线程属于同一个进程，所以它们只能在进程内进行资源竞争。</li><li>两级线程模型（混合型线程模型）<br>  两级线程模型吸取了内核级和用户级线程的经验，两级线程模型下的线程和内核线程处于多对多的关系。一个进程内的多个线程可以分别绑定内核线程，既可以多个线程绑定多个内核线程也可以多个线程绑定一个内核线程，当某个线程内的程序产生阻塞其绑定的内核线程被CPU中断处理，进程内的其他线程可以重新与其他内核线程绑定。</li></ul><p><img src="/assets/goroutine/thread_model.png" alt></p><p>goroutine使用的正是两级线程模型，但是这种多个线程跑在多个内核中，既不是用户级线程模型完全靠自身调度也不是内核级线程模型完全依赖内核调度，而是用户和内核协同调度。因为这种模型复杂性较高，所以Go语言开发了自己的runtime调度器。</p><h3 id="三、Go-runtime调度器"><a href="#三、Go-runtime调度器" class="headerlink" title="三、Go runtime调度器"></a>三、Go runtime调度器</h3><p>Go runtime调度器的结构由三部分组成:</p><ul><li>G<br>  Goroutine，每个goroutine有对应的G结构体，G结构体储存goroutine的上下文信息。G并不能直接被调度，需要绑定对应的P才能被调度执行。</li><li><p>P<br>  Processor，为G和M进行调度的逻辑处理器，对于G来说P像是内核，而在M看来P相当于上下文。P的数量可以在程序中代码控制，如下:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOMAXPROCS(runtime.NumCPU()) <span class="comment">// 该值最大为256。</span></span><br></pre></td></tr></table></figure></li><li><p>M<br>  Machine，负责调度任务（可以理解为内核线程的抽象），代表着操作系统内核，是真正处理任务的服务。M的数量不是固定的，受Go runtime调度器控制。（不过该值最大为10000，可以参考：<a href="https://github.com/golang/go/blob/master/src/runtime/proc.go#L540" target="_blank" rel="noopener">src/runtime/proc.go</a>）</p></li></ul><p>值得一提的是Go语言在最初的版本中Go runtime调度器的结构是GM模型（并非GMP模型），P服务是因为GM模型在并发上出现很大的性能损耗。有兴趣的小伙伴可以看一下Go runtime的核心开发者Dmitry Vyukov发现的问题<a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#heading=h.mmq8lm48qfcw" target="_blank" rel="noopener">Scalable Go Scheduler Design Doc</a>。</p><p>简单说了一下Go runtime调度器中的GPM模型的概念，那么GPM究竟是怎么调度的呢？<br>首先当通过<code>go func()</code>创建一个G对象的时候，G会被优先放入P的本地队列。为了执行G M需要绑定一个P，然后M启动内核线程并循环从P的本地队列取出G并执行。<br><img src="/assets/goroutine/gmp.png" alt></p><p>当P发现当前绑定的M被阻塞时会转入绑定其他M（新的M可能是被创建或者从内核线程缓存中取出）。<br><img src="/assets/goroutine/gmp-m.png" alt></p><p>如果M处理完了当前P的本地队列里的G后，P会尝试从全局队列里取G来执行（同样P也会周期性的检查全局队列是否有G可以执行）。如果全局队列没有可以执行的G，P会随机挑选另外一个P并从它的本地队列中取出一半G到自己的本地队列中执行。这个动作使用调度算法<code>work-stealing</code>（工作窃取算法）实现。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>以上就是Go runtime调度器的运行原理（大概），后面有更深入的理解会补充进来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在现在大数据、高并发，到处都充斥着流量的互联网时代，能不能应对高并发俨然已经发展成一个衡量服务端架构是否合格的标准，作为程序媛我们思考如何利用语言在代码层面最优设计能应对并发的程序去并行处理任务。在程序中对于任务并行处理一般趋于使用：进程、线程，以及另外一种：&lt;code&gt;协程&lt;/code&gt;。支持协程的语言有很多，比如：C/C++、Ruby、 Python（2.5+）、Golang等等，它们有些是本身语言支持协程，有些则是需要引入第三方包来使用。不过，我们主要来学习一下Golang这门语言（简称Go），它是如何理解以及实现协程的。&lt;/p&gt;
&lt;h3 id=&quot;一、进程、线程和协程的前世今生&quot;&gt;&lt;a href=&quot;#一、进程、线程和协程的前世今生&quot; class=&quot;headerlink&quot; title=&quot;一、进程、线程和协程的前世今生&quot;&gt;&lt;/a&gt;一、进程、线程和协程的前世今生&lt;/h3&gt;&lt;p&gt;都知道一台计算机的核心是CPU，它承担着所有的运算。而计算机承载的操作系统（内核）则是负责所有任务的处理和调度CPU以及资源的分配。如果用人类来比喻，大脑是CPU，思维则是操作系统（内核）。&lt;/p&gt;
&lt;h4 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h4&gt;&lt;p&gt;最早的计算机每次只能运行一个程序，如果还有其他程序需要执行则要排队等待。后来CPU运算能力提高了，这种方式过于原始有些浪费性能，于是尝试让多个程序可以并行执行，但是这样面临一个新的问题：跑在同一个CPU中的程序都会使用计算机资源，那程序的运行状态和数据怎么保障？&lt;code&gt;进程&lt;/code&gt;。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;进程是内核资源管理分配的最小单位，每个进程都有独立的虚拟地址空间。内核中的每个程序都运行在独立进程的上下文中，上下文是由程序正常运行需要的一系列参数组成，参数包括存储器中的代码和数据，寄存器中的内容以及进程打开的文件描述符（文件句柄）等。可以把上下文通俗理解为：`环境`。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果程序在运行过程中需要进行IO操作，IO操作阻塞了程序后面的计算，这时候CPU属于空闲状态，那内核会把CPU切换到其他进程去处理。不过当进程数量变高以后，计算机的大部分资源都被进程切换这个操作消耗掉了。为什么说进程切换操作消耗资源代价比较高？&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;所谓进程切换其实就是上下文切换，需要切换新的页表并加载新的虚拟地址空间、切换内核栈以及硬件上下文等。只要发生进程切换操作就得反复进入内核，加载切换一系列状态。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h4&gt;&lt;p&gt;为了减少这种开销，&lt;code&gt;线程&lt;/code&gt;应运而生。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;线程是内核调度CPU执行的最小单位，线程是运行在进程上下文的逻辑流，线程是具体执行程序的单位。一个进程至少包含一个主线程（可以拥有多个子线程），但是一个线程只能存在于一个进程中。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;线程切换相比进程切换开销就小了很多，线程切换只需要把寄存器刷新即可。&lt;/p&gt;
&lt;h4 id=&quot;协程&quot;&gt;&lt;a href=&quot;#协程&quot; class=&quot;headerlink&quot; title=&quot;协程&quot;&gt;&lt;/a&gt;协程&lt;/h4&gt;&lt;p&gt;后面程序媛们发现线程这样还是有性能瓶颈（IO阻塞），无论是进程还是线程因为涉及到大量的计算机资源，所以都是由内核调度管理。能不能开发一种由代码控制的线程呢？这就是&lt;code&gt;协程&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="goroutine" scheme="http://xupin.im/tags/goroutine/"/>
    
  </entry>
  
  <entry>
    <title>Mysql小知识 - 查找连续编号中的缺失编号</title>
    <link href="http://xupin.im/2020/04/13/mysql-trick/"/>
    <id>http://xupin.im/2020/04/13/mysql-trick/</id>
    <published>2020-04-12T16:00:00.000Z</published>
    <updated>2022-12-15T04:31:13.452Z</updated>
    
    <content type="html"><![CDATA[<p>在和小伙伴讨论问题的时候，小伙伴突然问了我这样一个小问题，数据库中如何查找连续编号中的缺失编号？</p><h3 id="1-描述"><a href="#1-描述" class="headerlink" title="1.描述"></a>1.描述</h3><p>场景大概是这样，有一份连续数据ID：1 … 27，其中ID：6，7，14的数据丢了。结构如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`letter`</span>  (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span> AUTO_INCREMENT = <span class="number">27</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8mb4 <span class="keyword">COLLATE</span> = utf8mb4_unicode_ci ROW_FORMAT = <span class="keyword">Compact</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'A'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'B'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">'C'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">'D'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="string">'E'</span>);</span><br><span class="line"><span class="comment"># INSERT INTO `letter` VALUES (6, 'F');</span></span><br><span class="line"><span class="comment"># INSERT INTO `letter` VALUES (7, 'J');</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="string">'H'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">9</span>, <span class="string">'I'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="string">'J'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">11</span>, <span class="string">'K'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">12</span>, <span class="string">'L'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">13</span>, <span class="string">'M'</span>);</span><br><span class="line"><span class="comment"># INSERT INTO `letter` VALUES (14, 'N');</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">15</span>, <span class="string">'O'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">16</span>, <span class="string">'P'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">17</span>, <span class="string">'Q'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">18</span>, <span class="string">'R'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">19</span>, <span class="string">'S'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">20</span>, <span class="string">'T'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">21</span>, <span class="string">'U'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">22</span>, <span class="string">'V'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">23</span>, <span class="string">'W'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">24</span>, <span class="string">'X'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">25</span>, <span class="string">'Y'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`letter`</span> <span class="keyword">VALUES</span> (<span class="number">26</span>, <span class="string">'Z'</span>);</span><br></pre></td></tr></table></figure></p><p>怎么把6，7，14这三条数据找出来？方法有很多种哈，今天我们说一下如何利用SQL快速查询出来。大概思路是把ID+1，然后查询ID+1这个值是否存在ID列表中，如果不存在那肯定就是缺失的。SQL如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">id</span> + <span class="number">1</span> <span class="keyword">AS</span> <span class="keyword">id</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="string">`letter`</span> </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">id</span> + <span class="number">1</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> <span class="string">`letter`</span> )</span><br></pre></td></tr></table></figure></p><p>但是这样会有一个小问题，就是MAX(id)+1（27）也会被查询出来，所以：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">id</span> + <span class="number">1</span> <span class="keyword">AS</span> <span class="keyword">id</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="string">`letter`</span> </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">id</span> + <span class="number">1</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> <span class="string">`letter`</span> ) </span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">id</span> &lt;(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">max</span>( <span class="keyword">id</span> ) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="string">`letter`</span> </span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="2-优化"><a href="#2-优化" class="headerlink" title="2.优化"></a>2.优化</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">start_id,</span><br><span class="line">( <span class="keyword">SELECT</span> <span class="keyword">MIN</span>(<span class="keyword">id</span>)- <span class="number">1</span> <span class="keyword">FROM</span> <span class="string">`letter`</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> &gt; start_id ) <span class="keyword">AS</span> end_id </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">id</span> + <span class="number">1</span> <span class="keyword">AS</span> start_id </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="string">`letter`</span> </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">id</span> + <span class="number">1</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> <span class="string">`letter`</span> ) </span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">id</span> &lt;(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">max</span>(<span class="keyword">id</span>) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="string">`letter`</span> </span><br><span class="line">) </span><br><span class="line">) <span class="keyword">AS</span> max_id </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">start_id</span><br></pre></td></tr></table></figure><p>这种情况适用于查找整数类型的连续编号，那么如果编号是string类型的呢？后面有机会再补充进来=,=。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在和小伙伴讨论问题的时候，小伙伴突然问了我这样一个小问题，数据库中如何查找连续编号中的缺失编号？&lt;/p&gt;
&lt;h3 id=&quot;1-描述&quot;&gt;&lt;a href=&quot;#1-描述&quot; class=&quot;headerlink&quot; title=&quot;1.描述&quot;&gt;&lt;/a&gt;1.描述&lt;/h3&gt;&lt;p&gt;场景大概是这</summary>
      
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="biscuits" scheme="http://xupin.im/tags/biscuits/"/>
    
    <category term="mysql" scheme="http://xupin.im/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习笔记 - 集群</title>
    <link href="http://xupin.im/2020/03/27/redis-cluster/"/>
    <id>http://xupin.im/2020/03/27/redis-cluster/</id>
    <published>2020-03-26T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.756Z</updated>
    
    <content type="html"><![CDATA[<p>之前粗浅的学习了Redis三种集群策略的主从复制和哨兵策略，现在最后这篇来学习一下Redis Cluster也就是最后一个集群策略。</p><h3 id="1-什么是集群？"><a href="#1-什么是集群？" class="headerlink" title="1.什么是集群？"></a>1.什么是集群？</h3><p>集群（Cluster），Redis2.6版本（正式版本是3.0）推出的分布式解决方案，有效解决了单Master节点写操作的压力并且分布式存储数据，大大提高了负载能力。</p><blockquote><p>在Redis发布3.0正式版本前，一般使用代理中间件来实现分布式集群策略。这里不展开学习了，有兴趣的小伙伴自行研究。</p></blockquote><ul><li><p>特点</p><ol><li>Cluster策略是分布式部署，节点间相互协调工作。<blockquote><p>因为对主从复制和哨兵策略都称为集群策略，所以为了防止误解在下文中提及的集群（Cluster）策略，直接用Cluster称呼。</p></blockquote></li><li>Cluster至少要3个Master节点，并且是无中心化设计。</li><li>客户端使用Cluster，不需要连接所有节点，只需要连接Cluster中任意一个可用节点即可。</li><li>数据的分布式存储不需要指定，Cluster会自动完成。</li></ol></li><li><p>优点</p><ol><li>Cluster策略拥有主从复制和哨兵策略的优点。</li><li>解决了单Master节点写操作的压力。</li><li>分布式存储数据，提高了负载能力。</li><li>支持线性扩容。</li></ol></li></ul><a id="more"></a><ul><li>缺点<ol><li>部分操作命令受限，比如mset，目前只能支持同一个插槽（slot）的key进行操作。</li><li>事务机制不支持多节点操作。</li><li>不支持多数据库，即只有db0。</li></ol></li></ul><h3 id="2-如何配置（新旧方式）"><a href="#2-如何配置（新旧方式）" class="headerlink" title="2.如何配置（新旧方式）"></a>2.如何配置（新旧方式）</h3><ul><li>旧方式，./redis-trib.rb create –replicas {SLAVE_NUM} {IP}:{PORT} … {IP}:{PORT}</li><li>新方式，./redis-cli –cluster create –cluster-replicas {SLAVE_NUM} {IP}:{PORT} … {IP}:{PORT}</li></ul><p>redis.conf示例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否以守护进程方式运行</span></span><br><span class="line">daemonize yes/no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否启用Cluster</span></span><br><span class="line">cluster-enabled yes/no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点信息配置文件，自动生成。</span></span><br><span class="line"><span class="comment"># FILE_NAME：配置文件名</span></span><br><span class="line">cluster-cluster-config-file &#123;FILE_NAME&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点连接超时时间</span></span><br><span class="line"><span class="comment"># MS：超时时间（单位：Millisecond）</span></span><br><span class="line">cluster-node-timeout &#123;MS&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-工作机制"><a href="#3-工作机制" class="headerlink" title="3.工作机制"></a>3.工作机制</h3><ul><li>Redis节点启动，节点根据配置<code>cluster-enabled</code>判断是否加入Cluster。</li><li>新节点通过<code>cluster meet {IP} {PORT}</code>命令和其他节点感知并建立连接，节点间会通过<code>Gossip协议</code>PING/PONG命令来检测状态和交换信息。 </li><li>Cluster计算并且分配主节点插槽数量。<code>这个地方注意，不是插槽数量，是每个节点的插槽数量。插槽数量是固定的：16384。</code></li><li>插槽分配成功之后，Cluster开始服务。</li></ul><h3 id="4-如何感知新节点？"><a href="#4-如何感知新节点？" class="headerlink" title="4.如何感知新节点？"></a>4.如何感知新节点？</h3><p>当给某一节点发送命令<code>cluster meet {IP} {PORT}</code>（新节点），该节点就会尝试与新节点建立连接，具体流程：</p><ul><li>该节点向新节点发送MEET命令。</li><li>新节点接收到MEET命令后，回复PONG命令。</li><li>该节点接收到新节点返回的PONG命令，知道新节点成功接收了自己的MEET命令。</li><li>该节点向新节点发送PING命令。</li><li>新节点接收到该节点发送的PING命令，知道该节点已经成功接收到自己返回的PONG命令。</li><li>该节点和新节点握手完成，建立连接。</li><li>最后，该节点会将新节点的信息通过<code>Gossip协议</code>同步给Cluster中的其他节点，让其他节点也与新节点进行握手，建立连接。</li></ul><blockquote><p>可以通过<code>cluster nodes</code>命令查看集群中哪些节点已经建立连接。</p></blockquote><h3 id="5-数据插槽"><a href="#5-数据插槽" class="headerlink" title="5.数据插槽"></a>5.数据插槽</h3><p>说到插槽（slot）不得不提一下，为了能够让数据平均分配到多个节点上而采用的数据分区算法。常见的数据分区算法：范围（Range）、哈希（Hash）、一致性哈希算法和虚拟哈希槽等。</p><p>Cluster采用的虚拟哈希槽数据分区算法，所有的key根据哈希函数映射到0 ~ 16383插槽内（公式：slot = crc16(key) &amp; 16383），之前也提到过插槽也是平均分配到每个Master节点的。</p><ul><li>虚拟哈希槽的特点<ol><li>降低了节点和数据之间的耦合性，方便线性扩容&amp;动态管理节点。</li><li>节点自己管理和插槽的对应关系。</li><li>支持查询节点、插槽和key的对应关系。</li></ol></li></ul><p>可以通俗理解为，插槽是Cluster管理数据的基本单位。</p><h3 id="6-动态管理节点"><a href="#6-动态管理节点" class="headerlink" title="6.动态管理节点"></a>6.动态管理节点</h3><p>假如我们原有4个Master节点（M1 … M4），但是现在因为数据增量问题临时加一个Master节点（M5），我们需要怎么操作呢？</p><ul><li>启动M5节点，客户端发送MEET命令让M5节点加入到Cluster中，现在M5节点没有任何插槽所以不会接受任何读写操作。</li><li>在M5节点执行<code>cluster setslot {SLOT} importing {SOURCE_NODE_ID}</code>命令，让M5节点准备导入{SLOT}插槽。</li><li>在拥有这个{SLOT}插槽的源节点上面执行<code>cluster setslot {SLOT} migrating {M5_NODE_ID}</code>，让源节点准备好迁出插槽。</li><li>这时候如果客户端操作的key存在于{SLOT}插槽中，那么这个操作由源节点处理。如果key不存在于{SLOT}插槽中，这个操作将由M5节点操作。</li><li>现在源节点的{SLOT}插槽不会创建任何新的key，需要把源节点{SLOT}插槽中的key迁移到M5节点。执行<code>cluster getkeysinslot {SLOT} {COUNT}</code>命令获取{SLOT}插槽中指定{COUNT}数量的key列表。</li><li>在源节点对每个key执行<code>migrate</code>命令，把key迁移到M5节点。</li><li>在源节点和M5节点执行<code>cluster setslot {SLOT} NODE {M5_NODE_ID}</code>，完成迁移。</li></ul><p>这就是动态增加节点的流程了，可能在新的Redis版本中增加了节点迁移工具，但是核心流程应该还是这样。</p><h3 id="7-Hash-Tag"><a href="#7-Hash-Tag" class="headerlink" title="7.Hash Tag"></a>7.Hash Tag</h3><p>学习了数据插槽，我们知道Redis在key分配到插槽的这一操作完全是自动化的，不过当我们有需求对不同的key需要放到同一插槽中的时候，这个时候要怎么操作呢？我们只需要在key中加入{}符号即可，比如：</p><ul><li>{UID_1001}:following</li><li>{UID_1001}:followers</li></ul><p>这两个key会被分配到同一插槽，原理就是当key中存在{}符号，哈希算法只会针对{}符号内的字符串。</p><h3 id="8-插槽为什么是16384？这个值能修改吗？"><a href="#8-插槽为什么是16384？这个值能修改吗？" class="headerlink" title="8.插槽为什么是16384？这个值能修改吗？"></a>8.插槽为什么是16384？这个值能修改吗？</h3><p>首先crc16算法算出的值有16bit，2^16即65536。也就是说该算法的值在0 ~ 65535之间，那么为什么作者还是选择了16384即0 ~ 16383。</p><p>很开心，对于这个疑问Redis作者给了明确的回答。前面我们知道每个节点之间会以每秒1次的频率互相发送心跳包（PING）&amp;交换信息（信息分为消息头和消息体），之前也提了交换的信息体里面主要包含节点的信息等，那么消息头的内容呢？如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> sig[<span class="number">4</span>];        <span class="comment">/* Siganture "RCmb" (Redis Cluster message bus). */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> totlen;    <span class="comment">/* Total length of this message */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> ver;       <span class="comment">/* Protocol version, currently set to 1. */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> port;      <span class="comment">/* TCP base port number. */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> type;      <span class="comment">/* Message type */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> count;     <span class="comment">/* Only used for some kind of messages. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> currentEpoch;  <span class="comment">/* The epoch accordingly to the sending node. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch;   <span class="comment">/* The config epoch if it's a master, or the last</span></span><br><span class="line"><span class="comment">                               epoch advertised by its master if it is a</span></span><br><span class="line"><span class="comment">                               slave. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> offset;    <span class="comment">/* Master replication offset if node is a master or</span></span><br><span class="line"><span class="comment">                           processed replication offset if node is a slave. */</span></span><br><span class="line">    <span class="keyword">char</span> sender[CLUSTER_NAMELEN]; <span class="comment">/* Name of the sender node */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> myslots[CLUSTER_SLOTS/<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">char</span> slaveof[CLUSTER_NAMELEN];</span><br><span class="line">    <span class="keyword">char</span> myip[NET_IP_STR_LEN];    <span class="comment">/* Sender IP, if not all zeroed. */</span></span><br><span class="line">    <span class="keyword">char</span> notused1[<span class="number">34</span>];  <span class="comment">/* 34 bytes reserved for future usage. */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> cport;      <span class="comment">/* Sender TCP cluster bus port */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> flags;      <span class="comment">/* Sender node flags */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> state; <span class="comment">/* Cluster state from the POV of the sender */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> mflags[<span class="number">3</span>]; <span class="comment">/* Message flags: CLUSTERMSG_FLAG[012]_... */</span></span><br><span class="line">    <span class="keyword">union</span> clusterMsgData data; <span class="comment">/* message body*/</span></span><br><span class="line">&#125; clusterMsg;</span><br></pre></td></tr></table></figure></p><p>其中有个<code>myslots</code>字段要注意，该字段使用位图，即1bit代表1slot，如果该bit为1即说明该插槽属于这个节点。那么该字段的大小为：16384 / 8bit / 1024b = 2kb。也就是消息头不考虑其他信息的情况，单是<code>myslots</code>就已经有2kb大小。</p><p>那么消息体呢？之前已经提到了消息体中会包含节点信息。具体是什么样的呢？消息体每次携带最少3个节点的信息，数量约为总节点数的1/10。如果节点数量越多，消息体越大。</p><ol><li>如果插槽数量是65535，那么该字段的大小放大为：65535 / 8bit / 1024b = 8kb。这对于每秒1次频率的心跳包来讲，带宽开销是极大的。</li><li>上面说了节点越多，消息体也就越大，如果节点超过1000个也会导致网络拥堵，因为Redis作者不建议Cluster节点的数量超过1000，那么对于1000个以下的节点来说16384个插槽也就够用了。</li><li>第三个考虑是关于位图的压缩问题，我还没有搞明白~~所以这里不展开说了，先埋个坑。</li></ol><p>这个值能修改吗？<code>16384插槽数量是写死在Redis源代码中的，所以是不可以更改的。</code></p><p>附上关于作者的回答</p><blockquote><p><a href="https://github.com/antirez/redis/issues/2576" target="_blank" rel="noopener">https://github.com/antirez/redis/issues/2576</a></p></blockquote><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>Cluster在故障恢复主从切换的机制（包括：主观宕机、客观宕机、投票选举、主从切换）和哨兵策略基本一致，所以在这里就不学习Cluster关于故障恢复主从切换的相关知识了。</p><p>前面提到过Gossip协议，它主要职责就是各节点间的信息交换，常用的Gossip消息可分为：</p><ul><li>ping</li><li>pong</li><li>meet</li><li>fail</li></ul><p>后面会专门来学习Gossip协议的知识（-,-再次埋个坑）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前粗浅的学习了Redis三种集群策略的主从复制和哨兵策略，现在最后这篇来学习一下Redis Cluster也就是最后一个集群策略。&lt;/p&gt;
&lt;h3 id=&quot;1-什么是集群？&quot;&gt;&lt;a href=&quot;#1-什么是集群？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是集群？&quot;&gt;&lt;/a&gt;1.什么是集群？&lt;/h3&gt;&lt;p&gt;集群（Cluster），Redis2.6版本（正式版本是3.0）推出的分布式解决方案，有效解决了单Master节点写操作的压力并且分布式存储数据，大大提高了负载能力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在Redis发布3.0正式版本前，一般使用代理中间件来实现分布式集群策略。这里不展开学习了，有兴趣的小伙伴自行研究。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Cluster策略是分布式部署，节点间相互协调工作。&lt;blockquote&gt;
&lt;p&gt;因为对主从复制和哨兵策略都称为集群策略，所以为了防止误解在下文中提及的集群（Cluster）策略，直接用Cluster称呼。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Cluster至少要3个Master节点，并且是无中心化设计。&lt;/li&gt;
&lt;li&gt;客户端使用Cluster，不需要连接所有节点，只需要连接Cluster中任意一个可用节点即可。&lt;/li&gt;
&lt;li&gt;数据的分布式存储不需要指定，Cluster会自动完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;优点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Cluster策略拥有主从复制和哨兵策略的优点。&lt;/li&gt;
&lt;li&gt;解决了单Master节点写操作的压力。&lt;/li&gt;
&lt;li&gt;分布式存储数据，提高了负载能力。&lt;/li&gt;
&lt;li&gt;支持线性扩容。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="redis" scheme="http://xupin.im/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习笔记 - 哨兵</title>
    <link href="http://xupin.im/2020/03/26/redis-sentinel/"/>
    <id>http://xupin.im/2020/03/26/redis-sentinel/</id>
    <published>2020-03-25T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.757Z</updated>
    
    <content type="html"><![CDATA[<p>现在这篇来学习一下Redis Sentinel即哨兵策略的相关知识。</p><h3 id="1-什么是哨兵？"><a href="#1-什么是哨兵？" class="headerlink" title="1.什么是哨兵？"></a>1.什么是哨兵？</h3><p>哨兵（Sentinel），Redis2.6版本（正式版本是2.8，现2.6版本已被废弃）开始提供的一种集群策略，核心思想是解决了主从复制（Replication）在Master节点故障，无法自动切换Slave节点为新Master节点的问题。</p><ul><li><p>特点</p><ol><li>哨兵策略是分布式部署，节点间相互协调工作。</li><li>哨兵集群至少要3个节点。</li><li>可以把哨兵看作是一种特殊的Redis服务。</li></ol></li><li><p>优点</p><ol><li>哨兵策略拥有主从复制的优点。</li><li>哨兵策略解决了Master节点故障，无法自动切换Slave节点为新Master节点的问题。</li></ol></li></ul><a id="more"></a><ul><li>缺点<ol><li>Master节点写操作的压力没有得到解决。</li><li>数据存储能力还是受到单节点限制。</li></ol></li></ul><h3 id="2-如何配置（多种方式）"><a href="#2-如何配置（多种方式）" class="headerlink" title="2.如何配置（多种方式）"></a>2.如何配置（多种方式）</h3><ul><li>启动Redis哨兵，./redis-sentinel redis-sentinel.conf</li><li>启动Redis服务时并且启动哨兵，./redis-server redis-sentinel.conf –sentinel</li></ul><p>redis-sentinel.conf示例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 哨兵监控的节点。</span></span><br><span class="line"><span class="comment"># MASTER_NAME：自定义的Master节点名称。</span></span><br><span class="line"><span class="comment"># IP：Master节点的地址。</span></span><br><span class="line"><span class="comment"># PORT：Master节点的端口。</span></span><br><span class="line"><span class="comment"># QUORUM：当Master节点故障，确认Master节点odown最少的哨兵数量。</span></span><br><span class="line">sentinel monitor &#123;MASTER_NAME&#125; &#123;IP&#125; &#123;PORT&#125; &#123;QUORUM&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵验证</span></span><br><span class="line"><span class="comment"># PASS：Master节点的auth，需要注意的时哨兵不能同时为Master节点和Slave节点设置密码，所以auth需要保持一致。</span></span><br><span class="line">sentinel auth-pass &#123;MASTER_NAME&#125; &#123;PASS&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵心跳Ping最大时间，如果哨兵向Master节点发送Ping超过这个时间或者回复err，那么哨兵会主观（sdown）认为该Master节点已经处于不可用状态。</span></span><br><span class="line"><span class="comment"># MS：心跳Ping等待响应的最大时间（单位：Millisecond）。</span></span><br><span class="line">sentinel down-after-milliseconds &#123;MASTER_NAME&#125; &#123;MS&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时同步数据的Slave节点数量</span></span><br><span class="line"><span class="comment"># SLAVE_NUM：当Master节点故障，Slave节点通过竞选当选新Master节点，最多允许几个Slave节点开始同步新Master的数据。</span></span><br><span class="line">sentinel parallel-syncs &#123;MASTER_NAME&#125; &#123;SLAVE_NUM&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主从节点切换所需要的最大时间。</span></span><br><span class="line"><span class="comment"># MS：主从节点切换所需要的最大时间（单位：Millisecond）。</span></span><br><span class="line">sentinel failover-timeout &#123;MASTER_NAME&#125; &#123;MS&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Master节点故障调用的脚本</span></span><br><span class="line"><span class="comment"># SCRIPT_PATH：脚本路径</span></span><br><span class="line">sentinel notification-script &#123;MASTER_NAME&#125; &#123;SCRIPT_PATH&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-工作机制"><a href="#3-工作机制" class="headerlink" title="3.工作机制"></a>3.工作机制</h3><ol><li>哨兵向已知节点和哨兵发送心跳包检测状态。</li><li>Master节点无效回复，哨兵判断Master节点状态：主观宕机，客观宕机。</li><li>Master节点被确定客观宕机，进行领头（Leader）哨兵选举。</li><li>准备进行主从切换的领头哨兵获取其他哨兵的授权。</li><li>授权成功，从Slave节点中选举新Master节点。</li><li>领头哨兵把新Master节点信息同步给其他哨兵，其他哨兵把新Master节点信息同步对应Slave节点。</li></ol><h3 id="4-心跳包"><a href="#4-心跳包" class="headerlink" title="4.心跳包"></a>4.心跳包</h3><p>每个哨兵以每秒钟1次的频率向它已知的Master节点、Slave节点和其他哨兵发送PING命令，希望得到的有效回复如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PING replied with +PONG.</span><br><span class="line">PING replied with -LOADING error.</span><br><span class="line">PING replied with -MASTERDOWN error.</span><br></pre></td></tr></table></figure></p><p>其它任何回复或者无回复都是无效回复。</p><h3 id="5-哨兵和节点之间的自动发现机制"><a href="#5-哨兵和节点之间的自动发现机制" class="headerlink" title="5.哨兵和节点之间的自动发现机制"></a>5.哨兵和节点之间的自动发现机制</h3><p>通过Redis的pub/sub系统实现，每个哨兵都会向自己监控的节点对应的channel：<strong>sentinel</strong>:hello发送一条消息（消息体包含自己的{IP}、{PORT}和{RUNID}以及Master节点的完整配置），每个订阅该channel的哨兵都可以消费这条消息并且能发现到其他哨兵的存在，如果某个哨兵发现自己维护的节点配置低于新接收的节点配置，则会用新的节点配置进行覆盖。</p><h3 id="6-主观-客观宕机"><a href="#6-主观-客观宕机" class="headerlink" title="6.主观/客观宕机"></a>6.主观/客观宕机</h3><p>如果一个Master节点在收到PING命令后没有在有效时间内（down-after-milliseconds）进行有效回复，则会被标记为主观宕机（sdown，Subjectively Down）。</p><p>哨兵会获取其他哨兵检测该节点的状态，命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># IP：主观宕机的Master节点地址</span></span><br><span class="line"><span class="comment"># PORT：主观宕机的Master节点端口</span></span><br><span class="line"><span class="comment"># CURRENT_EPOCH：哨兵的配置纪元，用于领头哨兵选举。</span></span><br><span class="line"><span class="comment"># RUNID：可以是*和哨兵的RunID，当值是 * 代表检测节点是否主观宕机，如果是RunID则用于领头哨兵选举。</span></span><br><span class="line">SENTINEL is-master-down-byaddr &#123;IP&#125; &#123;PORT&#125; &#123;CURRENT_EPOCH&#125; &#123;RUNID&#125;</span><br></pre></td></tr></table></figure></p><p>当有足够数量（{QUORUM}）的哨兵都认为该Master节点处于主观宕机状态。则该Master节点会被标记为客观宕机（odown，Objectively Down），若没有足够数量的哨兵都认为该Master节点处于主观宕机状态，则不会被标记为客观宕机，同时如果该Master节点重新返回哨兵有效回复，该Master节点主观宕机状态会被移除。</p><h3 id="7-领头哨兵选举"><a href="#7-领头哨兵选举" class="headerlink" title="7.领头哨兵选举"></a>7.领头哨兵选举</h3><p>因为只需要一个哨兵完成主从切换，所以需要选举一个领头哨兵。</p><ol><li>每个哨兵都会发送<code>SENTINEL is-master-down-byaddr</code>命令希望成为领头哨兵。收到该命令的哨兵如果没有同意过其他哨兵的同样命令，那么同意该请求，否则拒绝。</li><li>如果某一哨兵发现同意自己请求的哨兵数量并且数量大于等于{QUORUM}，那么它将成为领头哨兵。</li><li>如果选举过程中有多个哨兵当选领头哨兵，等待一段时间后选举会重新进行。</li></ol><blockquote><p>该方法基于raft算法领头选举方法实现。</p></blockquote><h3 id="8-主从切换授权"><a href="#8-主从切换授权" class="headerlink" title="8.主从切换授权"></a>8.主从切换授权</h3><p>当选举出领头哨兵之后并未马上进行主从切换，领头哨兵还需要获取{MAJORITY}数量的哨兵授权。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># MAJORITY：该值不可配置，Redis自行计算。公式：majority = voters / <span class="number">2</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure></p><ul><li>如果{QUORUM} &lt; {MAJORITY}，领头哨兵需要{MAJORITY}数量的哨兵进行授权。</li><li>如果{QUORUM} &gt;= {MAJORITY}，那么领头哨兵需要{QUORUM}数量的哨兵授权才可以。</li></ul><p>当领头哨兵获得授权之后，正式开始主从切换流程。</p><h3 id="9-主从切换"><a href="#9-主从切换" class="headerlink" title="9.主从切换"></a>9.主从切换</h3><p>开始主从切换（failover），首先领头哨兵会选举出一个Slave节点出来作为新Master节点，该Slave节点选举参考参数：</p><ul><li><p>该节点和Master节点断开的时长，如果一个Slave节点与Master节点断开连接时间已经超过<code>down-after-milliseconds</code>参数的<code>10倍</code>，再加上Master宕机的时长，该Slave节点就会被认为不适合选举为新的Master节点。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state</span><br></pre></td></tr></table></figure></li><li><p>Slave节点的优先级（slave-priority），slave-priority越低优先级越高。</p></li><li>复制数据偏移量（复制数据最完整）</li><li>RunID（最小的）</li></ul><h3 id="10-配置同步"><a href="#10-配置同步" class="headerlink" title="10.配置同步"></a>10.配置同步</h3><p>在领头哨兵完成主从切换之后，会在本地生成最新的Master配置然后通过pub/sub消息机制同步给其他哨兵，其他哨兵则更新对应的Master节点配置。</p><p>那么其他哨兵怎么知道这份配置是最新的呢？</p><blockquote><p>领头哨兵准备执行主从切换前，会从要切换成新Master节点的Slave节点取得一个configuration epoch，可以理解为配置版本号。如果领头哨兵主从切换失败了，那么其他哨兵会等待<code>failover-timeout</code>时间然后接替继续执行切换，每次接替都会重新获取一个configuration epoch，作为新的配置版本号。如果领头哨兵切换成功，那么其他哨兵会根据自己的配置版本号来更新对应Slave节点的Master节点配置。</p></blockquote><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>为什么说哨兵最少要3个节点，举个例子：</p><blockquote><p>如果是2个节点，{QUORUM}值为1，此时其中一台服务器出现客观宕机。领头哨兵需要进行主从切换，在进行主从切换前需要获取{MAJORITY}数量的哨兵同意，该{MAJORITY}参数最小的值是：2，此时领头哨兵无法进行主从切换。</p><p><a href="https://redis.io/topics/sentinel" target="_blank" rel="noopener">https://redis.io/topics/sentinel</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在这篇来学习一下Redis Sentinel即哨兵策略的相关知识。&lt;/p&gt;
&lt;h3 id=&quot;1-什么是哨兵？&quot;&gt;&lt;a href=&quot;#1-什么是哨兵？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是哨兵？&quot;&gt;&lt;/a&gt;1.什么是哨兵？&lt;/h3&gt;&lt;p&gt;哨兵（Sentinel），Redis2.6版本（正式版本是2.8，现2.6版本已被废弃）开始提供的一种集群策略，核心思想是解决了主从复制（Replication）在Master节点故障，无法自动切换Slave节点为新Master节点的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;哨兵策略是分布式部署，节点间相互协调工作。&lt;/li&gt;
&lt;li&gt;哨兵集群至少要3个节点。&lt;/li&gt;
&lt;li&gt;可以把哨兵看作是一种特殊的Redis服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;优点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;哨兵策略拥有主从复制的优点。&lt;/li&gt;
&lt;li&gt;哨兵策略解决了Master节点故障，无法自动切换Slave节点为新Master节点的问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="redis" scheme="http://xupin.im/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习笔记 - 主从复制</title>
    <link href="http://xupin.im/2020/03/25/redis-replication/"/>
    <id>http://xupin.im/2020/03/25/redis-replication/</id>
    <published>2020-03-24T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.756Z</updated>
    
    <content type="html"><![CDATA[<p>Redis单点配置的情况下如果服务出现故障宕机，那么服务也就处于不可用状态，假如是生产环境那么带来的后果会有很严重，所以出现了高可用方案：集群策略。</p><h3 id="1-三种集群策略"><a href="#1-三种集群策略" class="headerlink" title="1.三种集群策略"></a>1.三种集群策略</h3><p>Redis提供了三种集群策略，它们分别是：</p><ul><li>主从复制（Replication）</li><li>哨兵（Sentinel）</li><li>集群（Cluster）</li></ul><p>这三种策略会逐一学习，本篇主要学习策略之一主从复制（Replication）。</p><h3 id="2-主从复制的概念"><a href="#2-主从复制的概念" class="headerlink" title="2.主从复制的概念"></a>2.主从复制的概念</h3><p>在主从复制（Replication）策略中，服务分为两类：Master节点、Slave节点。</p><ul><li><p>特点</p><ol><li>Master节点可以拥有多个Slave节点，但Slave节点只能服务一个Master节点。</li><li>数据复制方向只能是Master节点-&gt;Slave节点。</li></ol></li><li><p>优点</p><ol><li>实现了多机热数据备份，提高了面对宕机数据恢复的灾备能力。</li><li>在主从复制的基础上实现读写分离提高服务吞吐量，即：Master节点提供写服务，Slave节点提供读服务。</li><li>如果Master节点宕机可以快速切换使用Slave节点提供服务。</li></ol></li></ul><a id="more"></a><ul><li>缺点<ol><li>Master节点故障，无法自动切换Slave节点为新Master节点的问题。</li><li>Master节点写操作的压力没有得到解决。</li><li>数据存储能力还是受到单节点限制。</li></ol></li></ul><h3 id="3-如何配置（多种方式）"><a href="#3-如何配置（多种方式）" class="headerlink" title="3.如何配置（多种方式）"></a>3.如何配置（多种方式）</h3><ul><li>在Slave节点服务器redis.conf增加配置行，slaveof {MASTER_IP} {MASTER_PORT}。</li><li>启动redis-server时，./redis-server slaveof {MASTER_IP} {MASTER_PORT}。</li><li>在redis-cli命令行界面输入，slaveof {MASTER_IP} {MASTER_PORT}。</li></ul><h3 id="4-工作机制"><a href="#4-工作机制" class="headerlink" title="4.工作机制"></a>4.工作机制</h3><ol><li>Slave节点执行slaveof命令，保存Master节点信息。</li><li>节点内部的定时任务发现主节点信息，开始尝试Socket连接主节点。</li><li>连接建立成功，Slave节点发送ping命令，期望得到pong命令响应，否则发起重连。</li><li>如果主节点有设置auth，那么进行auth验证，成功继续，失败终止。（非必须，根据Master节点是否配置auth决定）</li><li>Slave节点同步Master节点全量数据集。（该操作是Master节点向Slave节点发送数据哟）</li><li>Master节点持续把写命令同步Slave节点。</li></ol><h3 id="5-同步命令"><a href="#5-同步命令" class="headerlink" title="5.同步命令"></a>5.同步命令</h3><p>Redis主从复制数据有两个命令，sync和psync，sync是Redis2.8版本之前的同步方法，psync是Redis2.8版本以后优化sync新设计同步方法。在这会着重学习psync，也会捎带说一下为什么sync会被优化。</p><p>首先，psync需要3个参数支持：</p><ul><li><p>Master节点和Slave节点复制数据的偏移量。</p>  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">Master</span>节点和<span class="literal">Slave</span>节点复制数据的偏移量，主要作用是通过对比复制偏移量，来判断<span class="literal">Master</span>节点和<span class="literal">Slave</span>节点数据是否一致。</span><br></pre></td></tr></table></figure></li><li><p>Master节点复制积压缓冲区。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psync的特性之一，用于增量数据复制和补救丢失的复制数据。</span><br></pre></td></tr></table></figure></li><li><p>Master节点的RunID（Replication ID）。</p>  <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis服务启动的时，都会生成一个<span class="number">40</span>位的唯一RunID。</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>Master节点和Slave节点复制数据的偏移量：每个参与复制数据的节点都会维护一份复制偏移量，Master节点在处理完写命令后，会把命令的字节长度进行累加，Slave节点每秒钟会向Master节点上报自己的复制偏移量，因此Master节点也会记录Slave节点的偏移量。Master节点持续把写命令同步Slave节点，Slave节点成功接收到之后也会累加自身的偏移量。查看偏移量：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;info replication</span><br><span class="line">master_repl_offset:&#123;NUM&#125; <span class="comment"># Master节点偏移量</span></span><br><span class="line">slave_repl_offset:&#123;NUM&#125; <span class="comment"># Slave节点偏移量</span></span><br></pre></td></tr></table></figure></p><p>复制积压缓冲区：复制积压缓冲区是一个保存在Master节点拥有固定长度的队列，该队列先进先出，大小受repl-backlog-size参数控制（默认：1MB），查看缓冲区：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;info replication</span><br><span class="line">repl_backlog_size:&#123;NUM&#125;（byte）</span><br></pre></td></tr></table></figure></p><p>Master节点的RunID（Replication ID）：该ID主要是用来识别Redis服务节点，因为如果使用IP+PORT方式，假如Master节点重启之后修改了RDB/AOF备份文件，此时Slave节点再基于原来的复制偏移量进行复制数据是不可靠的。查看RunID：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;info server</span><br><span class="line">run_id:8d252f66c3ef89bd60a060cf8dc5cfe3d511c5e4</span><br></pre></td></tr></table></figure></p><p>psync命令使用方式<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">psync </span><span class="template-variable">&#123;RUNID&#125;</span><span class="xml"> </span><span class="template-variable">&#123;OFFSET&#125;</span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="6-增量-全量复制"><a href="#6-增量-全量复制" class="headerlink" title="6.增量/全量复制"></a>6.增量/全量复制</h3><p>知道了命令如何使用，那么当Slave节点发送psync命令给Master节点之后会发生什么？流程分为全量复制和增量复制两种。</p><ul><li><p>全量复制，如果Slave节点发送的命令是：psync ? -1</p><blockquote><p>Master节点知道Slave节点要全量复制数据，返回命令则是：+fullresync {RUNID} {OFFSET}，同时Master节点会执行RDB备份并且使用复制积压缓冲区来记录此后所有的写命令。Master节点 RDB备份完成之后向Slave节点发送备份文件，同时继续缓冲写命令，在备份文件发送完毕后Master节点会向Slave节点发送缓冲区的写命令。Slave节点在收到Master节点发送的备份文件之后，会丢弃所有的旧数据，开始载入备份文件并且开始执行Master节点发送缓冲区的写命令。</p><p>值得一提的是，在Slave节点加载备份文件的时候数据处于不可靠阶段，此时可以通过参数slave-server-stale-data（yes、no）配置是否响应请求，yes响应，no则抛出“SYNC with master in progress”。</p><p>如果备份从创建到传输完毕消耗时间大于repl-timeout参数的值，Slave节点将会放弃接收备份文件并且清理已经下载的临时文件。</p></blockquote></li><li><p>增量复制，Master节点会根据{RUNID}和{OFFSET}决定返回结果。</p><blockquote><p>Master节点首先会检查{RUNID}是否与自身一致，如果不一致将会执行全量数据复制。如果一致会根据{OFFSET}参数在缓冲区查找，如果数据偏移量之后的数据存在缓冲区，返回命令：+continue，表示可以增量复制数据。如果返回命令+err，表示Master节点版本过低不支持psync命令，将会使用sync进行全量复制数据。</p></blockquote></li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最后学习一下为什么sync会被优化？</p><blockquote><p>使用sync命令，在网络或者其他不可抗力因素导致Master节点和Slave节点断开连接，需要重新进行一次全量数据复制，Slave节点数据恢复成本极高。</p><p><a href="https://redis.io/topics/replication" target="_blank" rel="noopener">https://redis.io/topics/replication</a></p><p><a href="http://try.redis.io" target="_blank" rel="noopener">http://try.redis.io</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis单点配置的情况下如果服务出现故障宕机，那么服务也就处于不可用状态，假如是生产环境那么带来的后果会有很严重，所以出现了高可用方案：集群策略。&lt;/p&gt;
&lt;h3 id=&quot;1-三种集群策略&quot;&gt;&lt;a href=&quot;#1-三种集群策略&quot; class=&quot;headerlink&quot; title=&quot;1.三种集群策略&quot;&gt;&lt;/a&gt;1.三种集群策略&lt;/h3&gt;&lt;p&gt;Redis提供了三种集群策略，它们分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主从复制（Replication）&lt;/li&gt;
&lt;li&gt;哨兵（Sentinel）&lt;/li&gt;
&lt;li&gt;集群（Cluster）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这三种策略会逐一学习，本篇主要学习策略之一主从复制（Replication）。&lt;/p&gt;
&lt;h3 id=&quot;2-主从复制的概念&quot;&gt;&lt;a href=&quot;#2-主从复制的概念&quot; class=&quot;headerlink&quot; title=&quot;2.主从复制的概念&quot;&gt;&lt;/a&gt;2.主从复制的概念&lt;/h3&gt;&lt;p&gt;在主从复制（Replication）策略中，服务分为两类：Master节点、Slave节点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Master节点可以拥有多个Slave节点，但Slave节点只能服务一个Master节点。&lt;/li&gt;
&lt;li&gt;数据复制方向只能是Master节点-&amp;gt;Slave节点。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;优点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实现了多机热数据备份，提高了面对宕机数据恢复的灾备能力。&lt;/li&gt;
&lt;li&gt;在主从复制的基础上实现读写分离提高服务吞吐量，即：Master节点提供写服务，Slave节点提供读服务。&lt;/li&gt;
&lt;li&gt;如果Master节点宕机可以快速切换使用Slave节点提供服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="redis" scheme="http://xupin.im/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Mysql学习笔记 - 分片和分区</title>
    <link href="http://xupin.im/2020/03/23/mysql-sharding-partition/"/>
    <id>http://xupin.im/2020/03/23/mysql-sharding-partition/</id>
    <published>2020-03-22T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.754Z</updated>
    
    <content type="html"><![CDATA[<p>之前在复习Mysql主从知识的同时，小伙伴考了我一个问题，分片和分区有什么差别 … 乍一听可能只是名词上的不同，但其实它们俩的确不是同一个东西。</p><h3 id="1-什么是分片（Sharding）？"><a href="#1-什么是分片（Sharding）？" class="headerlink" title="1.什么是分片（Sharding）？"></a>1.什么是分片（Sharding）？</h3><p>我们举个例子，一张文章表。<br>结构如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mark`</span>.<span class="string">`article`</span>  (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`type`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'类型'</span>,</span><br><span class="line">  <span class="string">`title`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'标题'</span>,</span><br><span class="line">  <span class="string">`content`</span> longtext <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'内容'</span>,</span><br><span class="line">  <span class="string">`author`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'作者'</span>,</span><br><span class="line">  <span class="string">`date`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'日期'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>需求如下：</p><ol><li>用户打开app会直接展示文章列表（类型，标题，作者，日期）</li><li>点击文章查看详情</li></ol><p>那么这张表在数据量比较小的初期应对访问是没什么问题的。但是随着数据量日益膨胀，查询效率会越来越低，因为里面<code>content</code>字段非常巨大。</p><p>这时候要怎么优化呢？把<code>content</code>字段拆出去，因为访问最多的请求并不需要<code>content</code>，怎么拆呢？结构如下：</p><a id="more"></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mark`</span>.<span class="string">`article`</span>  (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`type`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'类型'</span>,</span><br><span class="line">  <span class="string">`title`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'标题'</span>,</span><br><span class="line">  <span class="string">`c_id`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'文章ID'</span>,</span><br><span class="line">  <span class="string">`author`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'作者'</span>,</span><br><span class="line">  <span class="string">`created_at`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'日期'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment"># 文章内容表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mark`</span>.<span class="string">`article_content`</span>  (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`content`</span> longtext <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'内容'</span>,</span><br><span class="line">  <span class="string">`created_at`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'日期'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="2-垂直（纵向）切分"><a href="#2-垂直（纵向）切分" class="headerlink" title="2.垂直（纵向）切分"></a>2.垂直（纵向）切分</h3><p>上述这种情况就是分片的一种，<code>垂直切分</code>也被称为<code>纵向切分</code>，这种分片的方式不仅可以跨表也可以跨库。</p><p>优点</p><ol><li>拆分规则简单。</li><li>数据模块清晰。</li><li>容易维护，容易定位问题。</li></ol><p>缺点</p><ol><li>如果分片表跨库，那么在SQL层无法进行连表查询，只能在程序层处理。</li><li>事务处理复杂度变高。</li><li>后期表结构的扩展性受限。</li></ol><h3 id="3-水平（横向）切分"><a href="#3-水平（横向）切分" class="headerlink" title="3.水平（横向）切分"></a>3.水平（横向）切分</h3><p>说到了垂直切分，那就不得不提一下<code>水平切分</code>也被称之为<code>横向切分</code>。<br>同样举个例子，一张用户日志表。<br>结构如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mark`</span>.<span class="string">`user_log`</span>  (</span><br><span class="line">  <span class="string">`u_id`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户ID'</span>,</span><br><span class="line">  <span class="string">`content`</span> longtext <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'日志内容'</span>,</span><br><span class="line">  <span class="string">`created_at`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建日期'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>需求如下：</p><ol><li>根据用户ID快速检索日志信息</li></ol><p>情况一样，在数据量比较小的时候功能响应速度应该还可以，但是随着数据量增长的比较厉害。查询效率会呈断崖式下降。</p><p>那么这时候要怎么优化呢？我们按照用户ID去拆分表，即每个用户存储的日志固定在一张表。结构如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mark`</span>.<span class="string">`user_log_&#123;NUM&#125;`</span>  (</span><br><span class="line">  <span class="string">`u_id`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户ID'</span>,</span><br><span class="line">  <span class="string">`content`</span> longtext <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'日志内容'</span>,</span><br><span class="line">  <span class="string">`created_at`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建日期'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>为了省事，后面{NUM}是个数字哈，每个用户进来我们会利用摘要算法（比如：crc32）取个固定数值，然后固定把对应的数据存储到相应的表内。</p><p>优点</p><ol><li>不会出现跨库无法连表查询的情况。</li><li>事务处理相对简单。</li><li>很难出现扩展性受限的问题。</li></ol><p>缺点</p><ol><li>数据分布不平均，可能一张表10W行，另外一张100W行。</li><li>难维护，定位问题需要前置算法查询。</li><li>后期数据迁移比较麻烦。</li></ol><h3 id="4-什么是分区（Partition）？"><a href="#4-什么是分区（Partition）？" class="headerlink" title="4.什么是分区（Partition）？"></a>4.什么是分区（Partition）？</h3><p>分片简单说了说，那么接下来要学习一下分区。分区和分片比较明显的一点是：分片多是利用程序配合来实现，分区则是数据库（不仅仅是Mysql，其它数据库也有）提供的机制。</p><p>首先，分区分为4种模式：</p><ul><li>Range</li><li>List</li><li>Hash</li><li>Key</li></ul><h3 id="5-Range"><a href="#5-Range" class="headerlink" title="5.Range"></a>5.Range</h3><p>Range（范围）大概的思想是将数据进行分段，比如按照日期将内购表进行拆分，分为不同的年份。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> purchase (<span class="keyword">id</span> <span class="built_in">INT</span>, app_id <span class="built_in">INT</span>, <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>), money <span class="built_in">NUMERIC</span>(<span class="number">20</span>,<span class="number">4</span>),currency <span class="built_in">VARCHAR</span>(<span class="number">10</span>),created_at <span class="built_in">DATE</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>( <span class="keyword">YEAR</span>(created_at) ) (</span><br><span class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">1990</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">1995</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2000</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2005</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p4 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2010</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p5 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2015</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment"># 也可以按照金额来进行分区。</span></span><br><span class="line"><span class="comment"># PARTITION BY RANGE( money ) ();</span></span><br></pre></td></tr></table></figure><p>写入以下数据<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> purchase(app_id,<span class="keyword">name</span>,money,currency,created_at) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">600001</span>,<span class="string">'desk organiser'</span>,<span class="number">6.0000</span>,<span class="string">'CNY'</span>,<span class="string">'2003-10-15'</span>),</span><br><span class="line">(<span class="number">600001</span>,<span class="string">'alarm clock'</span>,<span class="number">12.0000</span>,<span class="string">'CNY'</span>,<span class="string">'1997-11-05'</span>),</span><br><span class="line">(<span class="number">600002</span>,<span class="string">'chair'</span>,<span class="number">30.0000</span>,<span class="string">'CNY'</span>,<span class="string">'2009-03-10'</span>),</span><br><span class="line">(<span class="number">600002</span>,<span class="string">'bookcase'</span>,<span class="number">68.0000</span>,<span class="string">'CNY'</span>,<span class="string">'1989-01-10'</span>),</span><br><span class="line">(<span class="number">600002</span>,<span class="string">'exercise bike'</span>,<span class="number">128.0000</span>,<span class="string">'CNY'</span>,<span class="string">'2014-05-09'</span>),</span><br><span class="line">(<span class="number">600003</span>,<span class="string">'sofa'</span>,<span class="number">258.0000</span>,<span class="string">'CNY'</span>,<span class="string">'1987-06-05'</span>),</span><br><span class="line">(<span class="number">600003</span>,<span class="string">'espresso maker'</span>,<span class="number">648.0000</span>,<span class="string">'CNY'</span>,<span class="string">'2011-11-22'</span>),</span><br><span class="line">(<span class="number">600004</span>,<span class="string">'aquarium'</span>,<span class="number">99.0000</span>,<span class="string">'USD'</span>,<span class="string">'1992-08-04'</span>),</span><br><span class="line">(<span class="number">600005</span>,<span class="string">'study desk'</span>,<span class="number">129.0000</span>,<span class="string">'USD'</span>,<span class="string">'2006-09-16'</span>),</span><br><span class="line">(<span class="number">600006</span>,<span class="string">'lava lamp'</span>,<span class="number">299.0000</span>,<span class="string">'USD'</span>,<span class="string">'1998-12-25'</span>);</span><br></pre></td></tr></table></figure></p><p>然后我们观察一下，可能通过肉眼看没什么变化，执行这条查看分区状态的SQL<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">partition_name part,</span><br><span class="line">partition_expression expr,</span><br><span class="line">table_rows </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">information_schema.PARTITIONS </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">table_schema = <span class="keyword">SCHEMA</span> () </span><br><span class="line"><span class="keyword">AND</span> table_name = <span class="string">'&#123;TABLE&#125;'</span>;</span><br><span class="line"><span class="comment"># 结果如下</span></span><br><span class="line">part    |   expr              |   descr |   table_rows</span><br><span class="line">p0      |   YEAR(created_at)  |   1990  |   2</span><br><span class="line">p1      |   YEAR(created_at)  |   1995  |   1</span><br><span class="line">p2      |   YEAR(created_at)  |   2000  |   2</span><br><span class="line">p3      |   YEAR(created_at)  |   2005  |   1</span><br><span class="line">p4      |   YEAR(created_at)  |   2010  |   2</span><br><span class="line">p5      |   YEAR(created_at)  |   2015  |   2</span><br></pre></td></tr></table></figure></p><p>很明显，数据分别按照规则写进了分区表p0 ~ p5。</p><h3 id="6-List"><a href="#6-List" class="headerlink" title="6.List"></a>6.List</h3><p>List（列表）模式，多用于对于指定字段的数值进行明确的数据拆分。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> purchase (<span class="keyword">id</span> <span class="built_in">INT</span>, app_id <span class="built_in">INT</span>, <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>), money <span class="built_in">NUMERIC</span>(<span class="number">20</span>,<span class="number">4</span>),currency <span class="built_in">VARCHAR</span>(<span class="number">10</span>),created_at <span class="built_in">DATE</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">LIST</span>( app_id ) (</span><br><span class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">600001</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">600002</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">600003</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">600004</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p4 <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">600005</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p5 <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">600006</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>写入同样的数据，之后执行查看分区状态的SQL。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">part    |   expr    |   descr   |   table_rows</span><br><span class="line">p0      |   app_id  |   600001  |   2</span><br><span class="line">p1      |   app_id  |   600002  |   3</span><br><span class="line">p2      |   app_id  |   600003  |   2</span><br><span class="line">p3      |   app_id  |   600004  |   1</span><br><span class="line">p4      |   app_id  |   600005  |   1</span><br><span class="line">p5      |   app_id  |   600006  |   1</span><br></pre></td></tr></table></figure></p><h3 id="7-Hash"><a href="#7-Hash" class="headerlink" title="7.Hash"></a>7.Hash</h3><p>Hash（哈希）模式通过对一个或多个字段进行Hash计算，通过这个Hash值来进行分区（是不是感觉很像分片，其实分片的思想就是根据分区衍生而来）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> purchase (<span class="keyword">id</span> <span class="built_in">INT</span>, app_id <span class="built_in">INT</span>, <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>), money <span class="built_in">NUMERIC</span>(<span class="number">20</span>,<span class="number">4</span>),currency <span class="built_in">VARCHAR</span>(<span class="number">10</span>),created_at <span class="built_in">DATE</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">HASH</span>( <span class="keyword">YEAR</span>(created_at) )</span><br><span class="line"><span class="keyword">PARTITIONS</span> <span class="number">4</span>; <span class="comment"># 为了区别，设4个分区。</span></span><br></pre></td></tr></table></figure><p>然后写入同样的数据，之后执行查看分区状态的SQL。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">part|   expr              |  descr |   table_rows</span><br><span class="line">p0  |   YEAR(created_at)  |  NULL  |   1</span><br><span class="line">p1  |   YEAR(created_at)  |  NULL  |   3</span><br><span class="line">p2  |   YEAR(created_at)  |  NULL  |   3</span><br><span class="line">p3  |   YEAR(created_at)  |  NULL  |   3</span><br></pre></td></tr></table></figure></p><h3 id="8-Key"><a href="#8-Key" class="headerlink" title="8.Key"></a>8.Key</h3><p>Key（键）模式和Hash模式极其相似，可能有一点区别就是，Hash模式下是用户自定义规则进行Hash计算，而Key模式是Mysql使用自己的函数进行Hash计算。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> purchase (<span class="keyword">id</span> <span class="built_in">INT</span>, app_id <span class="built_in">INT</span>, <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>), money <span class="built_in">NUMERIC</span>(<span class="number">20</span>,<span class="number">4</span>),currency <span class="built_in">VARCHAR</span>(<span class="number">10</span>),created_at <span class="built_in">DATE</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">KEY</span>( created_at )</span><br><span class="line"><span class="keyword">PARTITIONS</span> <span class="number">3</span>; <span class="comment"># 为了区别，设3个分区。</span></span><br></pre></td></tr></table></figure><p>重复步骤，写入同样的数据，之后执行查看分区状态的SQL。<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">part|   <span class="type">expr</span>          |  <span class="type">descr</span> |   <span class="type">table_rows</span></span><br><span class="line">p0  |   <span class="type">`created_at</span>`  |  <span class="type">NULL</span>  |   <span class="type">2</span></span><br><span class="line">p1  |   <span class="type">`created_at</span>`  |  <span class="type">NULL</span>  |   <span class="type">3</span></span><br><span class="line">p2  |   <span class="type">`created_at</span>`  |  <span class="type">NULL</span>  |   <span class="type">5</span></span><br></pre></td></tr></table></figure></p><p>Key模式和Hash模式在<code>expr</code>上面有了直观的不同表现，Hash模式是：YEAR(created_at)，而Key模式是：created_at。这就是我们前面提到的Hash计算方式的区别。</p><h3 id="9-最后"><a href="#9-最后" class="headerlink" title="9.最后"></a>9.最后</h3><p>其实Mysql分区还有第5种模式，叫做Composite（复合）模式，比如：Range - Key<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> purchase (<span class="keyword">id</span> <span class="built_in">INT</span>, app_id <span class="built_in">INT</span>, <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>), money <span class="built_in">NUMERIC</span>(<span class="number">20</span>,<span class="number">4</span>),currency <span class="built_in">VARCHAR</span>(<span class="number">10</span>),created_at <span class="built_in">DATE</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>( <span class="keyword">YEAR</span>( created_at ) ) </span><br><span class="line"><span class="keyword">SUBPARTITION</span> <span class="keyword">BY</span> <span class="keyword">KEY</span>( created_at )</span><br><span class="line"><span class="keyword">SUBPARTITIONS</span> <span class="number">3</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">1990</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">1995</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2000</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2005</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p4 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2010</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p5 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2015</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>这里就不展开Composite（复合）模式的学习了，最后通过以上的例子，可以看出分区也是有垂直分区和水平分区的说法的。</p><blockquote><p><a href="https://dev.mysql.com/doc/mysql-partitioning-excerpt/5.7/en/partitioning-management.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/mysql-partitioning-excerpt/5.7/en/partitioning-management.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前在复习Mysql主从知识的同时，小伙伴考了我一个问题，分片和分区有什么差别 … 乍一听可能只是名词上的不同，但其实它们俩的确不是同一个东西。&lt;/p&gt;
&lt;h3 id=&quot;1-什么是分片（Sharding）？&quot;&gt;&lt;a href=&quot;#1-什么是分片（Sharding）？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是分片（Sharding）？&quot;&gt;&lt;/a&gt;1.什么是分片（Sharding）？&lt;/h3&gt;&lt;p&gt;我们举个例子，一张文章表。&lt;br&gt;结构如下：&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`mark`&lt;/span&gt;.&lt;span class=&quot;string&quot;&gt;`article`&lt;/span&gt;  (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; AUTO_INCREMENT,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`type`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;类型&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`title`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;标题&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`content`&lt;/span&gt; longtext &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;内容&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`author`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;作者&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`date`&lt;/span&gt; datetime &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;日期&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY &lt;span class=&quot;keyword&quot;&gt;KEY&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;`id`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;需求如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户打开app会直接展示文章列表（类型，标题，作者，日期）&lt;/li&gt;
&lt;li&gt;点击文章查看详情&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么这张表在数据量比较小的初期应对访问是没什么问题的。但是随着数据量日益膨胀，查询效率会越来越低，因为里面&lt;code&gt;content&lt;/code&gt;字段非常巨大。&lt;/p&gt;
&lt;p&gt;这时候要怎么优化呢？把&lt;code&gt;content&lt;/code&gt;字段拆出去，因为访问最多的请求并不需要&lt;code&gt;content&lt;/code&gt;，怎么拆呢？结构如下：&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="mysql" scheme="http://xupin.im/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql学习笔记 - 刷脏机制</title>
    <link href="http://xupin.im/2020/03/21/mysql-checkpoint/"/>
    <id>http://xupin.im/2020/03/21/mysql-checkpoint/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.752Z</updated>
    
    <content type="html"><![CDATA[<p>之前学习了LRU算法和Mysql缓冲池使用的LRU变体算法，其中有个共同点就是当LRU链表写满以后如果再有新数据进来会淘汰尾部的数据，那么Mysql淘汰这些尾部数据的时候是否会进行什么操作呢？这就是我们在最后提到了一个参数<code>Modified db pages</code>，即脏页。</p><h3 id="1-什么是脏页？"><a href="#1-什么是脏页？" class="headerlink" title="1.什么是脏页？"></a>1.什么是脏页？</h3><ul><li>脏页，这个名词很抽象从字面意思去看可能很不解，脏页是当内存中的数据页和磁盘中的数据页内容不一致时，这个数据页称之为脏页。因为从操作系统的角度来讲，自己读入的数据被外部所修改等于被污染，所以叫脏页。</li><li>当内存中的数据页和磁盘中的数据页数据一致，叫干净页。</li></ul><h3 id="2-脏页什么时候会刷新？"><a href="#2-脏页什么时候会刷新？" class="headerlink" title="2.脏页什么时候会刷新？"></a>2.脏页什么时候会刷新？</h3><ol><li>缓冲池（buffer pool）空间不足，也就是LRU链表写满时，新数据进来时淘汰掉的尾部数据脏页。</li><li>redo log不可用时，需要强制将脏页列表中的一些数据页刷入磁盘。</li><li>Mysql在服务器负载较小时，会主动进行刷脏操作。</li><li>Mysql服务正常关闭，会刷新所有脏页。</li></ol><h3 id="3-什么是redo-log？"><a href="#3-什么是redo-log？" class="headerlink" title="3.什么是redo log？"></a>3.什么是redo log？</h3><p>InnoDB中两块非常重要的日志，一个是undo log，另外一个就是我们接下来要学习的redo log。前者用来保证事务的原子性以及InnoDB的MVCC（Mutil-Version Concurrency Control），后者用来保证事务的持久性。</p><p>那么什么时候写redo log呢？当数据库对数据做修改的时候，需要把数据页从磁盘读到缓冲池中，然后在缓冲池中进行修改。但是InnoDB采用的是WAL（Write Ahead Log）策略来防止数据丢失，也就是事务提交时，先写redo log才会再去修改内存数据页。</p><p>redo log的文件名默认以ib_logfile{NUM}，存储在my.cnf中datadir目录下面，受以下两个参数控制</p><ul><li>innodb_log_file_size，日志大小</li><li>innodb_log_files_in_group，日志个数，默认是2个。</li></ul><p>所以redo log的大小等于innodb_log_files_in_group*innodb_log_file_size。</p><p>既然redo log会产生，那么什么时候会被覆盖呢？redo log被设计成可循环使用，当日志文件写满时那些已经被刷入磁盘中的数据就可以被覆盖啦。</p><blockquote><p>WAL（Write Ahead Log），是关系数据库系统中用于提供原子性和持久性（ACID属性中的两个）的一系列技术，ARIES是WAL系列技术常用的算法，在文件系统中WAL通常称为journaling。WAL的主要思想是将元数据的实时变更操作写入日志文件中，然后在系统负载较小时再把日志刷入磁盘。主要是为了减少磁盘的IO操作，此处就不展开学习了。先Mark一下</p></blockquote><a id="more"></a><h3 id="4-Checkpoint"><a href="#4-Checkpoint" class="headerlink" title="4.Checkpoint"></a>4.Checkpoint</h3><p>Checkpoint（检查点），在数据库中一般是用来把redo log脏页刷入磁盘的一个操作，通过LSN保存记录，作用是当发生宕机等crash情况时，再次启动时会查询Checkpoint，在该Checkpoint之后发生的事务修改恢复到磁盘。通俗来解释，就像我们玩一些游戏每过不久就会存一次档，然后如果游戏客户端不幸crash重新进入最近的一次存档即可，同理。</p><p>Checkpoint存在的目的：</p><ol><li>缩短恢复数据时间。</li><li>缓冲池写满时，淘汰脏页刷入磁盘。</li><li>redo log写满时，进行刷脏操作。</li></ol><p>那么怎么查看我们的检查点呢？可以使用命令show engine innodb status来查看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;show engine innodb status\G;</span><br><span class="line">---</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 1597945</span><br><span class="line">Log flushed up to   1597945</span><br><span class="line">Last Checkpoint at  1597945</span><br><span class="line">Max Checkpoint age    7782360</span><br><span class="line">Checkpoint age target 7539162</span><br><span class="line">Modified age          0</span><br><span class="line">Checkpoint age        0</span><br><span class="line">0 pending <span class="built_in">log</span> writes, 0 pending chkp writes</span><br><span class="line">8 <span class="built_in">log</span> i/o<span class="string">'s done, 0.42 log i/o'</span>s/second</span><br></pre></td></tr></table></figure></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Log</span> sequence number     <span class="string">|   当前系统LSN最大值，新的日志LSN将在此基础上生成（LSN+新日志的大小）。</span></span><br><span class="line"><span class="built_in">Log</span> flushed up to       <span class="string">|   当前已经写入日志文件的LSN。</span></span><br><span class="line">Last Checkpoint at      <span class="string">|   当前已经写入Checkpoint的LSN。</span></span><br><span class="line">Max Checkpoint age      <span class="string">|   Percona的XtraDB参数，此处不过多解释。</span></span><br><span class="line">Checkpoint age target   <span class="string">|   同上。</span></span><br></pre></td></tr></table></figure><blockquote><p>LSN（Log Sequence Number），LSN是日志空间中每条日志的结束点，用字节偏移量来表示。每个数据页有LSN，redo log也有LSN，Checkpoint亦有LSN。该LSN记录当前数据页最后一次修改的LSN号，用于在恢复数据时对比重做日志LSN号决定是否对该数据页进行恢复数据。可以通俗理解为，存档编号。</p></blockquote><h3 id="5-Checkpoint什么时候会触发？"><a href="#5-Checkpoint什么时候会触发？" class="headerlink" title="5.Checkpoint什么时候会触发？"></a>5.Checkpoint什么时候会触发？</h3><p>InnoDB存储引擎有两种Checkpoint，分别是：</p><ul><li>Sharp Checkpoint</li><li>Fuzzy Checkpoint</li></ul><p>Sharp Checkpoint发生在数据库服务关闭时，将所有脏页刷入磁盘，此时innodb_fast_shutdown参数的值为1（innodb_fast_shutdown参数的值：0、1、2），这是默认机制。但是考虑到如果数据库在使用时也执行这种机制，数据库的性能会受到影响，所以Fuzzy Checkpoint刷新部分脏页的这种机制产生了。</p><p>Fuzzy Checkpoint刷新部分脏页，也分为以下几种方式：</p><ul><li>Master Thread Checkpoint</li><li>FLUSH_LRU_LIST Checkpoint</li><li>Dirty Page too much Checkpoint</li><li>Async/Sync Flush Checkpoint</li></ul><p>Master Thread Checkpoint</p><blockquote><p>主线程以每秒或者每十秒从缓冲池的脏页列表（Flush List）刷新一定比例的数据页回磁盘，这个操作过程是异步的不会阻塞线程。</p></blockquote><p>FLUSH_LRU_LIST Checkpoint</p><blockquote><p>InnoDB需要保证LRU链表中有足够空闲页可以使用，在InnoDB1.1.x版本前，如果LRU链表写满有新的数据进来如果淘汰尾部脏页，会触发Checkpoint机制强制进行刷脏操作。该操作是阻塞线程的，所以在InnoDB1.2.x版本开始，这个操作放到Page Cleaner Thread来处理，每次刷新LRU链表脏页的数量受innodb_lru_scan_depth参数控制（默认：1024）。</p></blockquote><p>Dirty Page too much Checkpoint</p><blockquote><p>当LRU链表中脏页数量过多时（比例），InnoDB为了保证缓冲池中有足够多的空闲页可以使用，会强制触发Checkpoint机制进行刷脏操作。此值受innodb_max_dirty_pages_pct参数控制（默认：75%）。</p></blockquote><p>Async/Sync Flush Checkpoint</p><blockquote><p>为了保证redo log循环使用的可重用性，在redo log不可用时会强制触发Checkpoint刷脏操作。在InnoDB1.2.x版本以前，Async Flush Checkpoint会阻塞当前查询线程，Sync Flush Checkpoint会阻塞所有查询线程。InnoDB1.2.X之后放到单独的Page Cleaner Thread来处理。</p></blockquote><h3 id="6-最后"><a href="#6-最后" class="headerlink" title="6.最后"></a>6.最后</h3><p>关于Async/Sync Flush Checkpoint刷脏方式的原理有些复杂，这里先Mark一下，暂时不展开学习了。</p><p><code>前面说到的Percona XtraDB</code></p><blockquote><p><a href="https://www.percona.com/doc/percona-server/8.0/scalability/innodb_io.html" target="_blank" rel="noopener">https://www.percona.com/doc/percona-server/8.0/scalability/innodb_io.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前学习了LRU算法和Mysql缓冲池使用的LRU变体算法，其中有个共同点就是当LRU链表写满以后如果再有新数据进来会淘汰尾部的数据，那么Mysql淘汰这些尾部数据的时候是否会进行什么操作呢？这就是我们在最后提到了一个参数&lt;code&gt;Modified db pages&lt;/code&gt;，即脏页。&lt;/p&gt;
&lt;h3 id=&quot;1-什么是脏页？&quot;&gt;&lt;a href=&quot;#1-什么是脏页？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是脏页？&quot;&gt;&lt;/a&gt;1.什么是脏页？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;脏页，这个名词很抽象从字面意思去看可能很不解，脏页是当内存中的数据页和磁盘中的数据页内容不一致时，这个数据页称之为脏页。因为从操作系统的角度来讲，自己读入的数据被外部所修改等于被污染，所以叫脏页。&lt;/li&gt;
&lt;li&gt;当内存中的数据页和磁盘中的数据页数据一致，叫干净页。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-脏页什么时候会刷新？&quot;&gt;&lt;a href=&quot;#2-脏页什么时候会刷新？&quot; class=&quot;headerlink&quot; title=&quot;2.脏页什么时候会刷新？&quot;&gt;&lt;/a&gt;2.脏页什么时候会刷新？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;缓冲池（buffer pool）空间不足，也就是LRU链表写满时，新数据进来时淘汰掉的尾部数据脏页。&lt;/li&gt;
&lt;li&gt;redo log不可用时，需要强制将脏页列表中的一些数据页刷入磁盘。&lt;/li&gt;
&lt;li&gt;Mysql在服务器负载较小时，会主动进行刷脏操作。&lt;/li&gt;
&lt;li&gt;Mysql服务正常关闭，会刷新所有脏页。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;3-什么是redo-log？&quot;&gt;&lt;a href=&quot;#3-什么是redo-log？&quot; class=&quot;headerlink&quot; title=&quot;3.什么是redo log？&quot;&gt;&lt;/a&gt;3.什么是redo log？&lt;/h3&gt;&lt;p&gt;InnoDB中两块非常重要的日志，一个是undo log，另外一个就是我们接下来要学习的redo log。前者用来保证事务的原子性以及InnoDB的MVCC（Mutil-Version Concurrency Control），后者用来保证事务的持久性。&lt;/p&gt;
&lt;p&gt;那么什么时候写redo log呢？当数据库对数据做修改的时候，需要把数据页从磁盘读到缓冲池中，然后在缓冲池中进行修改。但是InnoDB采用的是WAL（Write Ahead Log）策略来防止数据丢失，也就是事务提交时，先写redo log才会再去修改内存数据页。&lt;/p&gt;
&lt;p&gt;redo log的文件名默认以ib_logfile{NUM}，存储在my.cnf中datadir目录下面，受以下两个参数控制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;innodb_log_file_size，日志大小&lt;/li&gt;
&lt;li&gt;innodb_log_files_in_group，日志个数，默认是2个。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以redo log的大小等于innodb_log_files_in_group*innodb_log_file_size。&lt;/p&gt;
&lt;p&gt;既然redo log会产生，那么什么时候会被覆盖呢？redo log被设计成可循环使用，当日志文件写满时那些已经被刷入磁盘中的数据就可以被覆盖啦。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;WAL（Write Ahead Log），是关系数据库系统中用于提供原子性和持久性（ACID属性中的两个）的一系列技术，ARIES是WAL系列技术常用的算法，在文件系统中WAL通常称为journaling。WAL的主要思想是将元数据的实时变更操作写入日志文件中，然后在系统负载较小时再把日志刷入磁盘。主要是为了减少磁盘的IO操作，此处就不展开学习了。先Mark一下&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="mysql" scheme="http://xupin.im/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>PHP学习笔记 - 文件分片上传</title>
    <link href="http://xupin.im/2020/03/19/laravel-chunk-upload/"/>
    <id>http://xupin.im/2020/03/19/laravel-chunk-upload/</id>
    <published>2020-03-18T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.751Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是分片上传？"><a href="#1-什么是分片上传？" class="headerlink" title="1.什么是分片上传？"></a>1.什么是分片上传？</h3><ul><li>如果我们上传的文件是一个很大的文件，那么上传的时间应该会比较久，再加上网络不稳定各种因素的影响，很容易导致传输中断。</li><li>服务端一般都会设置固定大小的接收BUFF，往往上传文件的体积是该值的几何倍数。</li></ul><p>分片上传的原理大致可以描述为，把一个较大文件分成若干份的分片一个一个传输，服务端在接收到最后一个分片后进行合并资源。</p><h3 id="2-前端"><a href="#2-前端" class="headerlink" title="2.前端"></a>2.前端</h3><p>前端使用Dropzone控件，DropzoneJS是一个开源库，提供带有图像预览的拖放文件上传并且有分割文件分片上传的机制，当然该控件不仅仅可以上传图片，经测试视频，Word等文件一样可以。</p><p>Dropzone官网提供了一个<a href="https://gitlab.com/meno/dropzone/raw/master/website/examples/simple.html" target="_blank" rel="noopener">simple.html</a>的上传demo（js、css文件路径有改动过），内容如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Dropzone simple example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  DO NOT SIMPLY COPY THOSE LINES. Download the JS and CSS files from the</span></span><br><span class="line"><span class="comment">  latest release (https://github.com/enyo/dropzone/releases/latest), and</span></span><br><span class="line"><span class="comment">  host them yourself!</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dropzone.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./dropzone.css"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  This is the most minimal example of Dropzone. The upload in this example</span><br><span class="line">  doesn't work, because there is no actual server to handle the file upload.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Change /upload-target to your upload address --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"api/upload"</span> <span class="attr">class</span>=<span class="string">"dropzone"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Dropzone官方提供的demo默认是没有开启分片上传的，需要修改dropzone.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Whether you want files to be uploaded in chunks to your server. This can't be</span></span><br><span class="line"><span class="comment"> * used in combination with `uploadMultiple`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See [chunksUploaded](#config-chunksUploaded) for the callback to finalise an upload.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">chunking: <span class="literal">false</span>, <span class="comment">// 修改为true,即开启分片</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If `chunking` is `true`, then this defines the chunk size in bytes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">chunkSize: <span class="number">2000000</span>, <span class="comment">// 默认分片大小，单位：Byte</span></span><br></pre></td></tr></table></figure></p><h3 id="3-后端"><a href="#3-后端" class="headerlink" title="3.后端"></a>3.后端</h3><blockquote><p>框架：Laravel 6.8<br>扩展：<a href="https://github.com/pionl/laravel-chunk-upload" target="_blank" rel="noopener">laravel-chunk-upload</a><br>代码如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// create the file receiver</span></span><br><span class="line">$receiver = <span class="keyword">new</span> FileReceiver(<span class="string">"file"</span>, $request, HandlerFactory::classFromRequest($request));</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if the upload is success, throw exception or return response you need</span></span><br><span class="line"><span class="keyword">if</span> ($receiver-&gt;isUploaded() === <span class="keyword">false</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UploadMissingFileException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// receive the file</span></span><br><span class="line">$save = $receiver-&gt;receive();</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if the upload has finished (in chunk mode it will send smaller files)</span></span><br><span class="line"><span class="keyword">if</span> ($save-&gt;isFinished()) &#123;</span><br><span class="line">    <span class="comment">// save the file and return any response you need, current example uses `move` function. If you are</span></span><br><span class="line">    <span class="comment">// not using move, you need to manually delete the file by unlink($save-&gt;getFile()-&gt;getPathname())</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;saveFile($save-&gt;getFile());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// we are in chunk mode, lets send the current progress</span></span><br><span class="line"><span class="comment">/** <span class="doctag">@var</span> AbstractHandler $handler */</span></span><br><span class="line">$handler = $save-&gt;handler();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> response()-&gt;json([</span><br><span class="line">    <span class="string">"done"</span> =&gt; $handler-&gt;getPercentageDone(),</span><br><span class="line">    <span class="string">'status'</span> =&gt; <span class="keyword">true</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="4-Demo"><a href="#4-Demo" class="headerlink" title="4.Demo"></a>4.Demo</h3><blockquote><p><a href="https://github.com/xupin/chunk-upload-example" target="_blank" rel="noopener">https://github.com/xupin/chunk-upload-example</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-什么是分片上传？&quot;&gt;&lt;a href=&quot;#1-什么是分片上传？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是分片上传？&quot;&gt;&lt;/a&gt;1.什么是分片上传？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;如果我们上传的文件是一个很大的文件，那么上传的时间应该会比较久，</summary>
      
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="laravel" scheme="http://xupin.im/tags/laravel/"/>
    
    <category term="dropzone" scheme="http://xupin.im/tags/dropzone/"/>
    
  </entry>
  
  <entry>
    <title>Mysql学习笔记 - LRU算法</title>
    <link href="http://xupin.im/2020/03/18/mysql-lru/"/>
    <id>http://xupin.im/2020/03/18/mysql-lru/</id>
    <published>2020-03-17T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.753Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是LRU？"><a href="#1-什么是LRU？" class="headerlink" title="1.什么是LRU？"></a>1.什么是LRU？</h3><p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“最近使用的页面数据会在未来一段时期内仍然被使用,已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用”。</p><h3 id="2-LRU的实现"><a href="#2-LRU的实现" class="headerlink" title="2.LRU的实现"></a>2.LRU的实现</h3><p>LRU算法最常见的实现是使用链表来保存数据，该链表是双向链表，然后利用先进先出的特性，最新写入的数据会最快被获取。</p><ul><li>访问不存在的数据时，缓存数据则会写入链表的头部，链表写满时会淘汰掉尾部的缓存数据。</li><li>当缓存数据被访问时，则将该缓存数据向链表头部移动。</li></ul><p><img src="/assets/lru/struct.png" alt></p><blockquote><p>优点：面对频繁访问的热点数据，查询效率高</p><p>缺点：如果一次查询扫描全表，那么LRU列表会被污染</p></blockquote><h3 id="3-Mysql-LRU算法有何不同？"><a href="#3-Mysql-LRU算法有何不同？" class="headerlink" title="3.Mysql LRU算法有何不同？"></a>3.Mysql LRU算法有何不同？</h3><p>Mysql（InnoDB）的缓冲池（buffer pool）使用了LRU算法的变体，将链表分为三个部分：young、midpoint、old。链表比例(5、3)分配给young、old。其中young占据5/8，old占据3/8，此比例受参数innodb_old_blocks_pct控制。</p><blockquote><p>young是链表中最近访问过的新子表。</p><p>old是链表中最近访问的旧子表。</p><p>midpoint是介于新子表 &amp; 旧子表的边界中间位置（也可以理解为旧子表的头部）。</p></blockquote><a id="more"></a><ul><li>数据库刚启动LRU链表为空时，此时会检查Free List中是否有空闲的数据页，如果有则从Free List中删除并且在LRU链表中写入相同的数据页。</li><li>访问不存在的数据页时，数据页不会直接写入链表的头部，而是写入中间位置，如果链表满了则会从旧子表尾部淘汰数据页。</li><li>当数据页被访问时，则判断访问数据页的时间是否大于设定innodb_old_blocks_time（默认：1000ms），如果大于则向链表头部移动，如果小于其位置不变。</li></ul><p><img src="/assets/lru/innodb-buffer-pool-list.png" alt></p><blockquote><p>改进优点：能够防止单次大量的全表扫描污染整个LRU链表。</p></blockquote><h3 id="4-Mysql-LRU相关查询命令"><a href="#4-Mysql-LRU相关查询命令" class="headerlink" title="4.Mysql LRU相关查询命令"></a>4.Mysql LRU相关查询命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;show engine innodb status\G;</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total memory allocated 137756672; <span class="keyword">in</span> additional pool allocated 0</span><br><span class="line">Total memory allocated by <span class="built_in">read</span> views 88</span><br><span class="line">Internal <span class="built_in">hash</span> tables (constant factor + variable factor)</span><br><span class="line">    Adaptive <span class="built_in">hash</span> index 2217584         (2213368 + 4216)</span><br><span class="line">    Page <span class="built_in">hash</span>           139112 (buffer pool 0 only)</span><br><span class="line">    Dictionary cache    593780  (554768 + 39012)</span><br><span class="line">    File system         83536   (82672 + 864)</span><br><span class="line">    Lock system         333248  (332872 + 376)</span><br><span class="line">    Recovery system     0       (0 + 0)</span><br><span class="line">Dictionary memory allocated 39012</span><br><span class="line">Buffer pool size        8191</span><br><span class="line">Buffer pool size, bytes 134201344</span><br><span class="line">Free buffers            8048</span><br><span class="line">Database pages          143</span><br><span class="line">Old database pages      0</span><br><span class="line">Modified db pages       0</span><br><span class="line">Pending reads 0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages <span class="built_in">read</span> 143, created 0, written 0</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages <span class="built_in">read</span> ahead 0.00/s, evicted without access 0.00/s, Random <span class="built_in">read</span> ahead 0.00/s</span><br><span class="line">LRU len: 143, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Buffer<span class="built_in"> pool </span>size                    |   innodb_buffer_pool的大小</span><br><span class="line">Free buffers                        |   当前Free List中数据页数量</span><br><span class="line">Database pages                      |   LRU链表中数据页数量</span><br><span class="line">Old database pages                  |   LRU链表中旧子表数据页数量</span><br><span class="line">Modified db pages                   |   LRU链表中脏页数量</span><br><span class="line">Pages made young 0, <span class="keyword">not</span> young 0     |   数据页从old移至young的行为：page made young,数据页因为innodb_old_blocks_time导致没有从old移至young的行为：page <span class="keyword">not</span> young。后面的数值是该行为发生的次数。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-什么是LRU？&quot;&gt;&lt;a href=&quot;#1-什么是LRU？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是LRU？&quot;&gt;&lt;/a&gt;1.什么是LRU？&lt;/h3&gt;&lt;p&gt;LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“最近使用的页面数据会在未来一段时期内仍然被使用,已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用”。&lt;/p&gt;
&lt;h3 id=&quot;2-LRU的实现&quot;&gt;&lt;a href=&quot;#2-LRU的实现&quot; class=&quot;headerlink&quot; title=&quot;2.LRU的实现&quot;&gt;&lt;/a&gt;2.LRU的实现&lt;/h3&gt;&lt;p&gt;LRU算法最常见的实现是使用链表来保存数据，该链表是双向链表，然后利用先进先出的特性，最新写入的数据会最快被获取。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;访问不存在的数据时，缓存数据则会写入链表的头部，链表写满时会淘汰掉尾部的缓存数据。&lt;/li&gt;
&lt;li&gt;当缓存数据被访问时，则将该缓存数据向链表头部移动。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/assets/lru/struct.png&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;优点：面对频繁访问的热点数据，查询效率高&lt;/p&gt;
&lt;p&gt;缺点：如果一次查询扫描全表，那么LRU列表会被污染&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;3-Mysql-LRU算法有何不同？&quot;&gt;&lt;a href=&quot;#3-Mysql-LRU算法有何不同？&quot; class=&quot;headerlink&quot; title=&quot;3.Mysql LRU算法有何不同？&quot;&gt;&lt;/a&gt;3.Mysql LRU算法有何不同？&lt;/h3&gt;&lt;p&gt;Mysql（InnoDB）的缓冲池（buffer pool）使用了LRU算法的变体，将链表分为三个部分：young、midpoint、old。链表比例(5、3)分配给young、old。其中young占据5/8，old占据3/8，此比例受参数innodb_old_blocks_pct控制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;young是链表中最近访问过的新子表。&lt;/p&gt;
&lt;p&gt;old是链表中最近访问的旧子表。&lt;/p&gt;
&lt;p&gt;midpoint是介于新子表 &amp;amp; 旧子表的边界中间位置（也可以理解为旧子表的头部）。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="mysql" scheme="http://xupin.im/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql学习笔记 - Int长度的问题</title>
    <link href="http://xupin.im/2020/03/15/mysql-int-length/"/>
    <id>http://xupin.im/2020/03/15/mysql-int-length/</id>
    <published>2020-03-15T11:30:00.000Z</published>
    <updated>2022-07-15T02:59:17.753Z</updated>
    
    <content type="html"><![CDATA[<p>创建数据表的时候我们总是要考虑存储数据的字段该用哪种类型、多少长度比较合适，不过在Mysql中如果字段类型是Int，此时长度是不生效的。</p><h3 id="1-Int类型的长度问题"><a href="#1-Int类型的长度问题" class="headerlink" title="1.Int类型的长度问题"></a>1.Int类型的长度问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test` (</span><br><span class="line">  `id` int(3) NOT NULL,</span><br><span class="line">  `name` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci</span><br></pre></td></tr></table></figure><p>有这样一张表，<code>id</code>是Int类型长度3的字段，那么理论上是不能存储长度超过3的值，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `test`(`id`, `name`) VALUES (1000000, &apos;name&apos;);</span><br></pre></td></tr></table></figure></p><p>不过结果是意外的，这条数据可以正常写入。</p><h3 id="2-Int类型的长度为什么不生效"><a href="#2-Int类型的长度为什么不生效" class="headerlink" title="2.Int类型的长度为什么不生效"></a>2.Int类型的长度为什么不生效</h3><p>翻了一下Mysql的<a href="https://dev.mysql.com/doc/refman/5.6/en/data-types.html" target="_blank" rel="noopener">数据类型文档</a>，发现这么一句话：</p><blockquote><p>对于整数类型，M表示最大显示宽度。 对于浮点和定点类型，M是可以存储的总位数（精度）。 对于字符串类型，M是最大长度。 M的最大允许值取决于数据类型。</p></blockquote><p>所以这个Int类型的“长度”其实叫宽度，也可以理解为显示长度。</p><h3 id="3-如果存储的数据长度低于显示宽度会怎样？"><a href="#3-如果存储的数据长度低于显示宽度会怎样？" class="headerlink" title="3.如果存储的数据长度低于显示宽度会怎样？"></a>3.如果存储的数据长度低于显示宽度会怎样？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `test`(`id`, `name`) VALUES (1, &apos;name&apos;);</span><br></pre></td></tr></table></figure><p>当然是可以写入的，但是好像并没有什么特别的不一样，不过我们再执行一条SQL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `test` MODIFY COLUMN `id` int(3) UNSIGNED ZEROFILL;</span><br></pre></td></tr></table></figure></p><p>这次数据产生变化了，变成了这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id      |   name</span><br><span class="line">001     |   name</span><br><span class="line">1000000 |   name</span><br></pre></td></tr></table></figure></p><h3 id="4-为什么要设计显示宽度？"><a href="#4-为什么要设计显示宽度？" class="headerlink" title="4.为什么要设计显示宽度？"></a>4.为什么要设计显示宽度？</h3><p>我也没有得出明确的答案，和小伙伴讨论这个问题~ta觉得是为了方便<code>排序</code>，你觉得呢？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;创建数据表的时候我们总是要考虑存储数据的字段该用哪种类型、多少长度比较合适，不过在Mysql中如果字段类型是Int，此时长度是不生效的。&lt;/p&gt;
&lt;h3 id=&quot;1-Int类型的长度问题&quot;&gt;&lt;a href=&quot;#1-Int类型的长度问题&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="mysql int length" scheme="http://xupin.im/tags/mysql-int-length/"/>
    
  </entry>
  
  <entry>
    <title>Go学习笔记 - 定时任务调度</title>
    <link href="http://xupin.im/2020/01/19/go-console/"/>
    <id>http://xupin.im/2020/01/19/go-console/</id>
    <published>2020-01-18T16:00:00.000Z</published>
    <updated>2022-12-13T12:48:48.864Z</updated>
    
    <content type="html"><![CDATA[<p>每一个任务都需要编写一个Crontab命令，这是件很麻烦且很不友好的事情。 任务调度器允许你以代码的形式定义调度命令，并且服务器上只需要一个Crontab命令即可, 任务调度又是我们俗称的 “计划任务”</p><h3 id="1-工欲善其事，必先利其器"><a href="#1-工欲善其事，必先利其器" class="headerlink" title="1.工欲善其事，必先利其器"></a>1.工欲善其事，必先利其器</h3><p>Github一番搜索，发现Golang有个cron包（<a href="https://github.com/robfig/cron" target="_blank" rel="noopener">robfig/cron</a>）大概满足需求，于是学习一下。</p><h3 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2.介绍"></a>2.介绍</h3><p>看了一遍文档，cron包支持的已经很全面了~~~不用自己造轮子了。</p><p>表达式</p><blockquote><p>兼容Linux的crontab表达式（支持分钟级别）。</p></blockquote><p>日志</p><blockquote><p>可以很详细的记录调度的任务状态</p></blockquote><p>时区</p><blockquote><p>支持任务级别的时区配置</p></blockquote><p>预定义计划</p><blockquote><p>支持在未来指定的时间去运行</p></blockquote><p><code>线程安全问题</code></p><blockquote><p>该cron lib管理任务队列的slice没有做并发安全考虑，可能会出现任务竟抢行为。</p></blockquote><a id="more"></a><h3 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/robfig/cron"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := cron.New()</span><br><span class="line">    c.AddFunc(<span class="string">"* * * * * *"</span>, test)</span><br><span class="line">    c.Start()</span><br><span class="line"></span><br><span class="line">    timer := time.NewTimer(time.Second * <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">            timer.Reset(time.Second * <span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"I'm a test script!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go run .</span><br><span class="line">I<span class="string">'m a test script!!!</span></span><br><span class="line"><span class="string">I'</span>m a <span class="built_in">test</span> script!!!</span><br><span class="line">I<span class="string">'m a test script!!!</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><h3 id="4-简单封装"><a href="#4-简单封装" class="headerlink" title="4.简单封装"></a>4.简单封装</h3><ul><li><p>main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"cron-example/console"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    quitChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// console</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        console.Default()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    &lt;-quitChan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>console.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> console</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"cron-example/console/commands"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/robfig/cron"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">(c *cron.Cron)</span></span> &#123;</span><br><span class="line">    c.AddFunc(<span class="string">"* * * * * *"</span>, commands.Test)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Default</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Println(<span class="string">"Starting..."</span>)</span><br><span class="line"></span><br><span class="line">    c := cron.New()</span><br><span class="line">    c.Start()</span><br><span class="line"></span><br><span class="line">    schedule(c)</span><br><span class="line"></span><br><span class="line">    timer := time.NewTimer(time.Second * <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">            timer.Reset(time.Second * <span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;每一个任务都需要编写一个Crontab命令，这是件很麻烦且很不友好的事情。 任务调度器允许你以代码的形式定义调度命令，并且服务器上只需要一个Crontab命令即可, 任务调度又是我们俗称的 “计划任务”&lt;/p&gt;
&lt;h3 id=&quot;1-工欲善其事，必先利其器&quot;&gt;&lt;a href=&quot;#1-工欲善其事，必先利其器&quot; class=&quot;headerlink&quot; title=&quot;1.工欲善其事，必先利其器&quot;&gt;&lt;/a&gt;1.工欲善其事，必先利其器&lt;/h3&gt;&lt;p&gt;Github一番搜索，发现Golang有个cron包（&lt;a href=&quot;https://github.com/robfig/cron&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;robfig/cron&lt;/a&gt;）大概满足需求，于是学习一下。&lt;/p&gt;
&lt;h3 id=&quot;2-介绍&quot;&gt;&lt;a href=&quot;#2-介绍&quot; class=&quot;headerlink&quot; title=&quot;2.介绍&quot;&gt;&lt;/a&gt;2.介绍&lt;/h3&gt;&lt;p&gt;看了一遍文档，cron包支持的已经很全面了~~~不用自己造轮子了。&lt;/p&gt;
&lt;p&gt;表达式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;兼容Linux的crontab表达式（支持分钟级别）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;日志&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以很详细的记录调度的任务状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;时区&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;支持任务级别的时区配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;预定义计划&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;支持在未来指定的时间去运行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;线程安全问题&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该cron lib管理任务队列的slice没有做并发安全考虑，可能会出现任务竟抢行为。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="golang" scheme="http://xupin.im/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>PHP小知识 - aliyundb SQLSetStatement is NOT supported</title>
    <link href="http://xupin.im/2020/01/07/php-aliyundb/"/>
    <id>http://xupin.im/2020/01/07/php-aliyundb/</id>
    <published>2020-01-06T16:00:00.000Z</published>
    <updated>2022-12-15T04:31:18.371Z</updated>
    
    <content type="html"><![CDATA[<p>PHP项目在数据库迁移使用ADB（aliyundb）时发现这个问题，具体错误描述是：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQLSTATE[HY000]: General error: 1815 [15022, 2020010711034801025210201503151413416] statement type: class com.alibaba.fastsql.sql.ast.statement.SQLSetStatement is NOT supported! (SQL: <span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">`users`</span>)</span><br></pre></td></tr></table></figure></p><p>在排查该问题的过程中，尝试了各种方式，降版本、使用原生语句等，甚至查找ADB手册和Issue还是无法解决。</p><h3 id="1-原因"><a href="#1-原因" class="headerlink" title="1.原因"></a>1.原因</h3><p>因为ADB兼容Mysql但是有些机制还是略有不同，阅读源码后发现比如：ADB就不能很好的支持本地预处理语句，这也是该异常的原因。</p><h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h3><p>PHP PDO链接的属性值<code>PDO::ATTR_EMULATE_PREPARES</code>需要设置为<code>true</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PDO::<span class="function"><span class="params">ATTR_EMULATE_PREPARES</span> =&gt;</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PHP项目在数据库迁移使用ADB（aliyundb）时发现这个问题，具体错误描述是：&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span</summary>
      
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="biscuits" scheme="http://xupin.im/tags/biscuits/"/>
    
    <category term="php" scheme="http://xupin.im/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Go学习笔记 - WEB框架Gin</title>
    <link href="http://xupin.im/2019/12/31/go-gin/"/>
    <id>http://xupin.im/2019/12/31/go-gin/</id>
    <published>2019-12-30T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.750Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener">Gin</a> 是一个用 Go (Golang) 编写的 HTTP web 框架。 它是一个类似于 martini 但拥有更好性能的 API 框架, 由于 httprouter，速度提高了近 40 倍。</p><h3 id="1-有哪些优点"><a href="#1-有哪些优点" class="headerlink" title="1.有哪些优点"></a>1.有哪些优点</h3><blockquote><p>较高的性能（<a href="https://github.com/julienschmidt/go-http-routing-benchmark" target="_blank" rel="noopener">Golang WEB框架比对数据</a>）</p><p>简单易用的中间件</p><p>使用了性能高可扩展的HTTP路由<a href="https://github.com/julienschmidt/httprouter" target="_blank" rel="noopener">httprouter</a></p><p>社区长期有着很高的活跃度</p><p>Github星星多（Orz）</p></blockquote><p>…等</p><a id="more"></a><h3 id="2-安装-更新"><a href="#2-安装-更新" class="headerlink" title="2.安装/更新"></a>2.安装/更新</h3><p>安装<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/gin-gonic/gin</span><br></pre></td></tr></table></figure></p><p>更新<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span> github.<span class="keyword">com</span>/gin-gonic/gin</span><br></pre></td></tr></table></figure></p><h3 id="3-Hello-World"><a href="#3-Hello-World" class="headerlink" title="3.Hello World"></a>3.Hello World</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 框架</span></span><br><span class="line">    g := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路由</span></span><br><span class="line">    g.GET(<span class="string">"/t"</span>, test)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务端口</span></span><br><span class="line">    g.Run(<span class="string">":4000"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.String(<span class="number">200</span>, <span class="string">"Hallo!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br></pre></td></tr></table></figure></p><p>访问 <a href="http://127.0.0.1:4000/t" target="_blank" rel="noopener">http://127.0.0.1:4000/t</a> ，页面输出Hallo!。</p><h3 id="4-路由"><a href="#4-路由" class="headerlink" title="4.路由"></a>4.路由</h3><p>Gin支持的路由方式和大部分主流框架基本一致。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    g := gin.Default()</span><br><span class="line"></span><br><span class="line">    g.GET(<span class="string">"/someGet"</span>, getting)</span><br><span class="line">    g.POST(<span class="string">"/somePost"</span>, posting)</span><br><span class="line">    g.PUT(<span class="string">"/somePut"</span>, putting)</span><br><span class="line">    g.DELETE(<span class="string">"/someDelete"</span>, deleting)</span><br><span class="line">    g.PATCH(<span class="string">"/somePatch"</span>, patching)</span><br><span class="line">    g.HEAD(<span class="string">"/someHead"</span>, head)</span><br><span class="line">    g.OPTIONS(<span class="string">"/someOptions"</span>, options)</span><br><span class="line"></span><br><span class="line">    g.Run(<span class="string">":4000"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Gin同样也支持路由参数，不过不支持路由正则表达式。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    g := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此 handler 只能匹配 /user/&#123;PARAM&#125;</span></span><br><span class="line">    g.GET(<span class="string">"/user/:name"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        name := c.Param(<span class="string">"name"</span>)</span><br><span class="line">        c.String(http.StatusOK, <span class="string">"Hello %s"</span>, name)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此 handler 会匹配 /user/&#123;PARAM&#125;/ 和 /user/&#123;PARAM&#125;/&#123;ACTION_2&#125;</span></span><br><span class="line">    <span class="comment">// 如果访问 /user/&#123;PARAM&#125;，在没有 "/user/:name" 路由的情况下，会重定向至 /user/&#123;PARAM&#125;/ 匹配当前路由。</span></span><br><span class="line">    g.GET(<span class="string">"/user/:name/*action"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        name := c.Param(<span class="string">"name"</span>)</span><br><span class="line">        action := c.Param(<span class="string">"action"</span>)</span><br><span class="line">        message := name + <span class="string">" is "</span> + action</span><br><span class="line">        c.String(http.StatusOK, message)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    g.Run(<span class="string">":4000"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-路由组"><a href="#5-路由组" class="headerlink" title="5.路由组"></a>5.路由组</h3><p>Gin在路由分组上的做法和其他框架也都是一致的，再次体现了Gin简单易用极容易上手的优点。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    g := gin.Default()</span><br><span class="line"></span><br><span class="line">    userGroup := g.Group(<span class="string">"/user"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        userGroup.POST(<span class="string">"/login"</span>, ctrls.Login)</span><br><span class="line">        userGroup.POST(<span class="string">"/logout"</span>, ctrls.Logout)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reportGroup := g.Group(<span class="string">"/report"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        reportGroup.POST(<span class="string">"/revenue"</span>, ctrls.RevenueReport)</span><br><span class="line">        reportGroup.POST(<span class="string">"/cost"</span>, ctrls.CostReport)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.Run(<span class="string">":4000"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="6-中间件"><a href="#6-中间件" class="headerlink" title="6.中间件"></a>6.中间件</h3><p>Gin的中间件分为：全局，路由组，路由级别。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    g := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局中间件</span></span><br><span class="line">    g.Use(middleware)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路由组中间件</span></span><br><span class="line">    routerGroup := g.Group(<span class="string">"/user"</span>, middleware)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 路由中间件</span></span><br><span class="line">        routerGroup.GET(<span class="string">"/login"</span>, middleware, ctrls.Login)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.Run(<span class="string">":4000"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="7-参数"><a href="#7-参数" class="headerlink" title="7.参数"></a>7.参数</h3><p>Gin如何获取请求参数？下面的简单例子：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    g := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// URL参数</span></span><br><span class="line">    <span class="comment">// URL：/user?email=mark@im.com</span></span><br><span class="line">    g.GET(<span class="string">"/user"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 使用 DefaultQuery 或者 Query</span></span><br><span class="line">        email := c.DefaultQuery(<span class="string">"email"</span>, <span class="string">"default value"</span>)</span><br><span class="line">        email = c.Query(<span class="string">"email"</span>)</span><br><span class="line"></span><br><span class="line">        c.String(http.StatusOK, <span class="string">"Hallo, %s"</span>, email)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// POST参数</span></span><br><span class="line">    g.POST(<span class="string">"/user/login"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 使用 DefaultPostForm 或者 PostForm</span></span><br><span class="line">        email := c.PostForm(<span class="string">"email"</span>)</span><br><span class="line">        email = c.DefaultPostForm(<span class="string">"email"</span>, <span class="string">"default value"</span>)</span><br><span class="line"></span><br><span class="line">        c.String(http.StatusOK, <span class="string">"Hallo, %s"</span>, email)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    g.Run(<span class="string">":4000"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>Gin支持的操作还有很多，比如：数据绑定、数据验证、上传文件、静态资源嵌入等。 </p><p>Gin没有提供的组件也有很多，比如：ORM、Console、日志滚动分割等。 </p><p>仁者见仁智者见智，Gin专注做HTTP WEB框架的核心，更多扩展需要开发人员自己去选择，组件化的设计无疑是好的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/gin-gonic/gin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gin&lt;/a&gt; 是一个用 Go (Golang) 编写的 HTTP web 框架。 它是一个类似于 martini 但拥有更好性能的 API 框架, 由于 httprouter，速度提高了近 40 倍。&lt;/p&gt;
&lt;h3 id=&quot;1-有哪些优点&quot;&gt;&lt;a href=&quot;#1-有哪些优点&quot; class=&quot;headerlink&quot; title=&quot;1.有哪些优点&quot;&gt;&lt;/a&gt;1.有哪些优点&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;较高的性能（&lt;a href=&quot;https://github.com/julienschmidt/go-http-routing-benchmark&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Golang WEB框架比对数据&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;简单易用的中间件&lt;/p&gt;
&lt;p&gt;使用了性能高可扩展的HTTP路由&lt;a href=&quot;https://github.com/julienschmidt/httprouter&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;httprouter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;社区长期有着很高的活跃度&lt;/p&gt;
&lt;p&gt;Github星星多（Orz）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;…等&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="golang" scheme="http://xupin.im/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>ES学习笔记 - 实现列分组统计</title>
    <link href="http://xupin.im/2019/12/17/elasticsearch-group/"/>
    <id>http://xupin.im/2019/12/17/elasticsearch-group/</id>
    <published>2019-12-16T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.749Z</updated>
    
    <content type="html"><![CDATA[<p>Elasticsearch是Elastic Stack核心的分布式搜索和分析引擎。</p><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><p>因为业务调整采用了ES作为数据库，所以需要了解ES对于这一块的设计如何实现类似Mysql中Group By的查询的效果。</p><h3 id="2-实现方式"><a href="#2-实现方式" class="headerlink" title="2.实现方式"></a>2.实现方式</h3><p>ES实现Group By有两种方式：TermsAgg、CompositeAgg，它们也具有不同程度的优缺点。</p><p>TermsAgg的使用方式非常粗暴，直接进行桶嵌套即可，如下:</p><details><br>  <summary>TermsAgg请求DSL语句</summary><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"aggregations"</span>: &#123;</span><br><span class="line"><span class="attr">"group_app"</span>: &#123;</span><br><span class="line"><span class="attr">"terms"</span>: &#123;</span><br><span class="line"><span class="attr">"field"</span>: <span class="string">"app"</span>,</span><br><span class="line"><span class="attr">"size"</span>: <span class="number">1000000</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"aggregations"</span>: &#123;</span><br><span class="line"><span class="attr">"group_campaign_id"</span>: &#123;</span><br><span class="line"><span class="attr">"terms"</span>: &#123;</span><br><span class="line"><span class="attr">"field"</span>: <span class="string">"campaign_id"</span>,</span><br><span class="line"><span class="attr">"size"</span>: <span class="number">1000000</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"size"</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details><br><details><br>  <summary>TermsAgg执行结果</summary><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"took"</span>: <span class="number">142</span>,</span><br><span class="line">    <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"successful"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"hits"</span>: &#123;</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">175033</span>,</span><br><span class="line">        <span class="attr">"max_score"</span>: <span class="number">0.0</span>,</span><br><span class="line">        <span class="attr">"hits"</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"aggregations"</span>: &#123;</span><br><span class="line">        <span class="attr">"group_app"</span>: &#123;</span><br><span class="line">            <span class="attr">"doc_count_error_upper_bound"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"sum_other_doc_count"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"buckets"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="string">"com.aa.bb.cc"</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">59929</span>,</span><br><span class="line">                    <span class="attr">"group_campaign_id"</span>: &#123;</span><br><span class="line">                        <span class="attr">"doc_count_error_upper_bound"</span>: <span class="number">0</span>,</span><br><span class="line">                        <span class="attr">"sum_other_doc_count"</span>: <span class="number">0</span>,</span><br><span class="line">                        <span class="attr">"buckets"</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"key"</span>: <span class="string">"Campaign_118"</span>,</span><br><span class="line">                                <span class="attr">"doc_count"</span>: <span class="number">56466</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"key"</span>: <span class="string">"Campaign_119"</span>,</span><br><span class="line">                                <span class="attr">"doc_count"</span>: <span class="number">1937</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="string">"com.dd.ee.ff"</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">23231</span>,</span><br><span class="line">                    <span class="attr">"group_campaign_id"</span>: &#123;</span><br><span class="line">                        <span class="attr">"doc_count_error_upper_bound"</span>: <span class="number">0</span>,</span><br><span class="line">                        <span class="attr">"sum_other_doc_count"</span>: <span class="number">0</span>,</span><br><span class="line">                        <span class="attr">"buckets"</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"key"</span>: <span class="string">"Campaign_120"</span>,</span><br><span class="line">                                <span class="attr">"doc_count"</span>: <span class="number">16692</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"key"</span>: <span class="string">"Campaign_121"</span>,</span><br><span class="line">                                <span class="attr">"doc_count"</span>: <span class="number">5336</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details><p>CompositeAgg的使用方式略微有一些不同，下面：</p><details><br>  <summary>CompositeAgg请求DSL语句</summary><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"aggregations"</span>: &#123;</span><br><span class="line"><span class="attr">"group_by"</span>: &#123;</span><br><span class="line"><span class="attr">"composite"</span>: &#123;</span><br><span class="line"><span class="attr">"sources"</span>: [</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"app"</span>: &#123;</span><br><span class="line">        <span class="attr">"terms"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"app"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"campaign_id"</span>: &#123;</span><br><span class="line">    <span class="attr">"terms"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"campaign_id"</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">                <span class="attr">"size"</span>: <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"size"</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details><br><details><br>  <summary>CompositeAgg执行结果</summary><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"took"</span>: <span class="number">14</span>,</span><br><span class="line">    <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"successful"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"hits"</span>: &#123;</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">175033</span>,</span><br><span class="line">        <span class="attr">"max_score"</span>: <span class="number">0.0</span>,</span><br><span class="line">        <span class="attr">"hits"</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"aggregations"</span>: &#123;</span><br><span class="line">        <span class="attr">"group_by"</span>: &#123;</span><br><span class="line">            <span class="attr">"after_key"</span>: &#123;</span><br><span class="line">                <span class="attr">"app"</span>: <span class="string">"com.dd.ee.ff"</span>,</span><br><span class="line">                <span class="attr">"campaign_id"</span>: <span class="string">"Campaign_120"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"buckets"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: &#123;</span><br><span class="line">                        <span class="attr">"app"</span>: <span class="string">"com.aa.bb.cc"</span>,</span><br><span class="line">                        <span class="attr">"campaign_id"</span>: <span class="string">"Campaign_119"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">182</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: &#123;</span><br><span class="line">                        <span class="attr">"app"</span>: <span class="string">"com.dd.ee.ff"</span>,</span><br><span class="line">                        <span class="attr">"campaign_id"</span>: <span class="string">"Campaign_120"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">40</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details><h3 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3.优缺点"></a>3.优缺点</h3><p>TermsAgg</p><blockquote><p>优点：使用简单、没有数据量限制。</p><p>缺点：数据结构层次深、不支持分页。</p></blockquote><p>CompositeAgg</p><blockquote><p>优点：使用简单、数据结构清晰可读，支持分页。</p><p>缺点：有数据量限制。</p></blockquote><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>至于ES这两种分组方式的<code>性能方面还没有研究，后续学习笔记会更新性能上面的差异。</code></p><blockquote><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-composite-aggregation.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-composite-aggregation.html</a> // 附上ES官方文档</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Elasticsearch是Elastic Stack核心的分布式搜索和分析引擎。&lt;/p&gt;
&lt;h3 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1.背景&quot;&gt;&lt;/a&gt;1.背景&lt;/h3&gt;&lt;p&gt;因为业务调整采用了ES作为</summary>
      
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="elasticsearch" scheme="http://xupin.im/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Nginx - 正向/反向代理</title>
    <link href="http://xupin.im/2019/12/17/nginx-proxy/"/>
    <id>http://xupin.im/2019/12/17/nginx-proxy/</id>
    <published>2019-12-16T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.754Z</updated>
    
    <content type="html"><![CDATA[<p>代理通常用于在几台服务器之间分配负载，无缝显示来自不同网站的内容或通过除HTTP之外的协议将处理请求传递给应用服务器。</p><h3 id="1-代理的常用场景及优点"><a href="#1-代理的常用场景及优点" class="headerlink" title="1.代理的常用场景及优点"></a>1.代理的常用场景及优点</h3><p>正向代理</p><blockquote><p>gfw科学上网。</p><p>客户端访问鉴权。</p></blockquote><p>反向代理</p><blockquote><p>负载均衡。</p><p>保证内网的安全，阻止web攻击。</p></blockquote><h3 id="2-正向代理和反向代理有什么不同"><a href="#2-正向代理和反向代理有什么不同" class="headerlink" title="2.正向代理和反向代理有什么不同"></a>2.正向代理和反向代理有什么不同</h3><p>比较通俗的来解释：正向代理代理的是客户端，服务端不知道实际发起请求的客户端、反向代理代理的是服务端，客户端不知道实际接收请求的服务端。</p><p>一张图表示（来源：<a href="https://zhuanlan.zhihu.com/p/82300486" target="_blank" rel="noopener">知乎wplulala</a>）<br><img src="/assets/nginx-proxy/relation.jpg" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;代理通常用于在几台服务器之间分配负载，无缝显示来自不同网站的内容或通过除HTTP之外的协议将处理请求传递给应用服务器。&lt;/p&gt;
&lt;h3 id=&quot;1-代理的常用场景及优点&quot;&gt;&lt;a href=&quot;#1-代理的常用场景及优点&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="nginx" scheme="http://xupin.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Mysql学习笔记 - 索引</title>
    <link href="http://xupin.im/2019/12/16/mysql-index/"/>
    <id>http://xupin.im/2019/12/16/mysql-index/</id>
    <published>2019-12-16T11:30:00.000Z</published>
    <updated>2022-07-15T02:59:17.752Z</updated>
    
    <content type="html"><![CDATA[<p>索引用于快速查找具有特定列值的行。没有索引，MySQL必须从第一行开始，然后通读整个表以找到相关的行。如果表中有相关​​列的索引，MySQL可以快速确定要在数据文件中间查找的位置，而不必查看所有数据。这比顺序读取每一行要快得多。<br>InnoDB和MyIsam只支持Btree，因此默认均是Btree，Memory和Heap支持Hash和Btree，如无明确声明，则默认索引均是Hash（包括主键）。</p><h3 id="1-Mysql有哪些常用的索引"><a href="#1-Mysql有哪些常用的索引" class="headerlink" title="1.Mysql有哪些常用的索引"></a>1.Mysql有哪些常用的索引</h3><blockquote><p>主键索引：数据列不允许重复，不允许为null，一个表只能有一个主键。</p><p>唯一索引：数据列不允许重复，允许为null，一个表允许多个列创建唯一索引。</p><p>普通索引：基本的索引类型，没有唯一性的限制，允许为null。</p><p>全文索引：全文索引是目前实现大数据搜索的关键技术。</p></blockquote><h3 id="2-Mysql索引的建立原则"><a href="#2-Mysql索引的建立原则" class="headerlink" title="2.Mysql索引的建立原则"></a>2.Mysql索引的建立原则</h3><p>Mysql的索引遵循最左原则，在创建多列索引时，要根据业务需求，where条件中使用最频繁的一列放在最左边。</p><a id="more"></a><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">index</span><span class="params">(a,b,c)</span></span></span><br><span class="line">where <span class="selector-tag">a</span> = v <span class="comment">// 使用a</span></span><br><span class="line">where <span class="selector-tag">a</span> = v and <span class="selector-tag">b</span> = v <span class="comment">// 使用a,b</span></span><br><span class="line">where <span class="selector-tag">a</span> = v and <span class="selector-tag">b</span> = v and c = v <span class="comment">// 使用a,b,c</span></span><br><span class="line"></span><br><span class="line">where <span class="selector-tag">b</span> = v <span class="comment">// 未使用索引</span></span><br><span class="line">where <span class="selector-tag">a</span> = v and c = v <span class="comment">// 使用a</span></span><br><span class="line">where <span class="selector-tag">b</span> = v and c = v <span class="comment">// 未使用索引</span></span><br><span class="line"></span><br><span class="line">where <span class="selector-tag">a</span> &gt; v <span class="comment">// 是否使用索引，取决于查询结果集，如果全表扫描速度比索引速度快，那么不使用索引。</span></span><br><span class="line"></span><br><span class="line">where <span class="selector-tag">a</span> like <span class="string">"v%"</span> <span class="comment">// 使用a</span></span><br><span class="line">where <span class="selector-tag">a</span> like <span class="string">"%v%"</span> <span class="comment">// 不适用索引</span></span><br></pre></td></tr></table></figure><h3 id="3-如何分析SQL语句执行性能"><a href="#3-如何分析SQL语句执行性能" class="headerlink" title="3.如何分析SQL语句执行性能"></a>3.如何分析SQL语句执行性能</h3><p>以下是两种分析SQL性能的常用方式，explain、show profiles/show profile。</p><blockquote><p>explain + SQL语句，获取SQL分析数据</p><ul><li>select_type：对应SQL语句的查询复杂度。</li><li>table：正在访问的表。</li><li>partitions：数据所在的分区。</li><li>type：表示是否用上索引，以及索引是如何使用的，此字段决定索引的性能。<code>ALL&lt;TYPE&lt;RANGE&lt;REF&lt;CONST</code></li><li>possible_keys：查询条件存在的索引。</li><li>key：触发的索引。</li><li>key_len：索引字段的长度。</li><li>ref：索引访问，返回所有匹配某个单值的行。</li><li>rows：执行查询必须检查的行数，在InnoDB中此值不精确。</li><li>filtered：条件过滤出的行数的百分比。</li><li>extra：查询分析结果的额外信息，很重要 e.g. Using index、Using where …</li></ul><p>show profiles获得当前会话中执行的SQL语句，字段为：Query_ID, Duration, Query，show profile all for query {Query_ID}</p></blockquote><h3 id="4-Mysql中索引建立常见问题"><a href="#4-Mysql中索引建立常见问题" class="headerlink" title="4.Mysql中索引建立常见问题"></a>4.Mysql中索引建立常见问题</h3><ol><li>为经常需要排序、分组和联合操作的字段建立索引</li><li>为常作为查询条件的字段建立索引</li><li>索引列值保证唯一性</li><li>索引建立的数量不要过多</li><li>索引列不要使用函数或者表达式</li><li>行锁依赖索引的建立</li><li>普通索引的数据重复率过高会导致索引失效</li><li><code>最左原则</code></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;索引用于快速查找具有特定列值的行。没有索引，MySQL必须从第一行开始，然后通读整个表以找到相关的行。如果表中有相关​​列的索引，MySQL可以快速确定要在数据文件中间查找的位置，而不必查看所有数据。这比顺序读取每一行要快得多。&lt;br&gt;InnoDB和MyIsam只支持Btree，因此默认均是Btree，Memory和Heap支持Hash和Btree，如无明确声明，则默认索引均是Hash（包括主键）。&lt;/p&gt;
&lt;h3 id=&quot;1-Mysql有哪些常用的索引&quot;&gt;&lt;a href=&quot;#1-Mysql有哪些常用的索引&quot; class=&quot;headerlink&quot; title=&quot;1.Mysql有哪些常用的索引&quot;&gt;&lt;/a&gt;1.Mysql有哪些常用的索引&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;主键索引：数据列不允许重复，不允许为null，一个表只能有一个主键。&lt;/p&gt;
&lt;p&gt;唯一索引：数据列不允许重复，允许为null，一个表允许多个列创建唯一索引。&lt;/p&gt;
&lt;p&gt;普通索引：基本的索引类型，没有唯一性的限制，允许为null。&lt;/p&gt;
&lt;p&gt;全文索引：全文索引是目前实现大数据搜索的关键技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2-Mysql索引的建立原则&quot;&gt;&lt;a href=&quot;#2-Mysql索引的建立原则&quot; class=&quot;headerlink&quot; title=&quot;2.Mysql索引的建立原则&quot;&gt;&lt;/a&gt;2.Mysql索引的建立原则&lt;/h3&gt;&lt;p&gt;Mysql的索引遵循最左原则，在创建多列索引时，要根据业务需求，where条件中使用最频繁的一列放在最左边。&lt;/p&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="mysql" scheme="http://xupin.im/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql学习笔记 - 事务隔离级别</title>
    <link href="http://xupin.im/2019/12/05/mysql-transaction/"/>
    <id>http://xupin.im/2019/12/05/mysql-transaction/</id>
    <published>2019-12-05T04:30:00.000Z</published>
    <updated>2022-07-15T02:59:17.754Z</updated>
    
    <content type="html"><![CDATA[<p>什么是事务？事务（Transaction）一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)，具有4个特性：原子性、一致性、隔离性、持久性，简称ACID。</p><p>那么Mysql的事务隔离级别又是什么呢？Mysql的事务隔离级别分别是4种：未提交读（Read Uncommitted）、已提交读（Read Committed）、Repeatable Read（可重复读）、Serializable（可串行化）。可以简单理解为Mysql事务的4种执行标准。</p><h3 id="一、ACID特性"><a href="#一、ACID特性" class="headerlink" title="一、ACID特性"></a>一、ACID特性</h3><blockquote><p>原子性（Atomicity）：一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</p></blockquote><p><br></p><blockquote><p>一致性（Consistency）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</p></blockquote><p><br></p><blockquote><p>隔离性（Isolation）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p></blockquote><p><br></p><blockquote><p>持久性（Durability）：指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</p></blockquote><h3 id="二、Mysql事务隔离级别"><a href="#二、Mysql事务隔离级别" class="headerlink" title="二、Mysql事务隔离级别"></a>二、Mysql事务隔离级别</h3><blockquote><p>未提交读（Read Uncommitted），指当前事务可以读取到其他事务还未提交的数据变化，最容易带来的问题是脏读（Dirty Read），很少应用到生产环境。</p></blockquote><p><br></p><blockquote><p>已提交读（Read Committed），大部分数据库默认隔离级别但不包括Mysql，指当前事务可以读取其他事务已提交的数据变化，具有隔离性的基本标准，但是在出现交叉事务的并发操作场景中会发生两次读取的数据结果集不一致的问题，即不可重复读（Nonrepeatable Read）。</p></blockquote><p><br></p><blockquote><p>Repeatable Read（可重复读），Mysql数据库的默认隔离级别，这里顺便解释一下为什么Mysql的隔离级别不是Read Committed，因为在Mysql5.0之前日志格式只有statement这一种，这种格式导致主从复制一致性很难得到保证。这种隔离级别可以解决Nonrepeatable Read的问题，但如果也出现在交叉事务的并发操作场景会出现幻读（Phantom Read）的现象，这一行为状态是当前事务不能及时有效的读取其他事务的数据变化。</p></blockquote><p><br></p><blockquote><p>Serializable（可串行化），Mysql事务隔离最高级别，望文生义大概意思是事务的执行是有序（串行化顺序）的，不存在事务交叉执行的场景从而解决了Phantom Read的问题，但是在高并发的业务场景下请求会出现阻塞、超时、锁竟抢的问题，系统的可用性也随之降低。</p></blockquote><h3 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h3><blockquote><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html</a> // Mysql事务官方文档</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;什么是事务？事务（Transaction）一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)，具有4个特性：原子性、一致性、隔离性、持久性，简称ACID。&lt;/p&gt;
&lt;p&gt;那么Mysql的事务隔离级别又是什么呢？Mys</summary>
      
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="mysql" scheme="http://xupin.im/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql学习笔记 - 悲观锁/乐观锁</title>
    <link href="http://xupin.im/2019/12/04/pessimistic-optimistic/"/>
    <id>http://xupin.im/2019/12/04/pessimistic-optimistic/</id>
    <published>2019-12-04T11:30:00.000Z</published>
    <updated>2022-07-15T02:59:17.755Z</updated>
    
    <content type="html"><![CDATA[<p>什么是锁？在多进程（线程）编程中为了数据的一致性、有效性，如果一资源被某进程（线程）上锁，那么在释放锁之前其他进程（线程）无法进行操作或者等待获取（上）锁。</p><h3 id="一、悲观锁"><a href="#一、悲观锁" class="headerlink" title="一、悲观锁"></a>一、悲观锁</h3><p>悲观锁（Pessimistic locking），顾名思义对待任何事务都持悲观态度，做任何事情都会认为会有竞抢行为~所以在进行任何操作之前都要做好万全准备（上锁）才会继续执行后续的操作。通常是利用系统提供的锁机制来实现。<br>比如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mysql中的上锁命令：for <span class="keyword">update</span>、<span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>等</span><br><span class="line">Redis中的一些操作命令：setnx、getset等（原子操作）</span><br></pre></td></tr></table></figure></p><h3 id="二、乐观锁"><a href="#二、乐观锁" class="headerlink" title="二、乐观锁"></a>二、乐观锁</h3><p>乐观锁（Optimistic locking），和悲观锁相反对待任何事务都持乐观态度，只会在最后即将执行操作的时刻前才会进行验证。通常是通过程序配合来实现。<br>比如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="string">`orders`</span> <span class="keyword">set</span> <span class="keyword">hash</span> = <span class="keyword">md5</span>(<span class="keyword">now</span>()) <span class="keyword">where</span> uid = <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">hash</span> = &#123;lastHash&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="三、优缺点"><a href="#三、优缺点" class="headerlink" title="三、优缺点"></a>三、优缺点</h3><p>悲观锁优点很鲜明，因为每次执行的操作都是独占的，数据的一致性、有效性、安全性较高。但缺点同样突出，每次操作都会产生上锁的开销，在并发请求比较密集的情况下容易阻塞或者驳回请求，甚至是造成死锁，也大大降低了系统的性能。</p><p>乐观锁优点是省去了锁的开销，能较高的提高系统吞吐量，缺点是如果出现在并发高且竟抢（冲突）行为比较多的场景下数据的一致性很难保证。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;什么是锁？在多进程（线程）编程中为了数据的一致性、有效性，如果一资源被某进程（线程）上锁，那么在释放锁之前其他进程（线程）无法进行操作或者等待获取（上）锁。&lt;/p&gt;
&lt;h3 id=&quot;一、悲观锁&quot;&gt;&lt;a href=&quot;#一、悲观锁&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="mysql" scheme="http://xupin.im/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习笔记 - 持久化方式</title>
    <link href="http://xupin.im/2019/12/03/redis-aof-rdb/"/>
    <id>http://xupin.im/2019/12/03/redis-aof-rdb/</id>
    <published>2019-12-03T07:30:00.000Z</published>
    <updated>2022-07-15T02:59:17.756Z</updated>
    
    <content type="html"><![CDATA[<p>Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。</p><h3 id="一、Redis数据存储的方式有两种"><a href="#一、Redis数据存储的方式有两种" class="headerlink" title="一、Redis数据存储的方式有两种"></a>一、Redis数据存储的方式有两种</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单纯的缓存模式, 整个数据的生命周期随着Redis <span class="built_in">Server</span>的停止而消失。</span><br><span class="line">persistence模式, 数据会持续备份到磁盘文件。</span><br></pre></td></tr></table></figure><h3 id="二、Redis如何实现持久化存储？Redis提供了两种方式。"><a href="#二、Redis如何实现持久化存储？Redis提供了两种方式。" class="headerlink" title="二、Redis如何实现持久化存储？Redis提供了两种方式。"></a>二、Redis如何实现持久化存储？Redis提供了两种方式。</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">RDB</span><span class="params">(Redis DataBase)</span></span></span><br><span class="line"><span class="function"><span class="title">AOF</span><span class="params">(Append-only file)</span></span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="三、RDB"><a href="#三、RDB" class="headerlink" title="三、RDB"></a>三、RDB</h3><p>RDB的工作原理有点像运维脚本自动化定时备份数据一样，当内存中的数据到达配置的阈值就会执行DUMP操作备份数据到临时文件,备份成功结束后重命名为dump.rdb文件。<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优点：<span class="keyword">fork</span>子进程来进行备份,父进程不会进行io操作。恢复数据时的速度很快。</span><br><span class="line">缺点：这种方式是每隔一次才会进行备份,假如下一次备份前down机会丢失部分数据。而且如果备份的数据比较大，<span class="keyword">fork</span>的子进程将会比较耗时，这段时间内会导致父进程阻塞。</span><br><span class="line">补充：因为这种每隔一段时间去备份一次的方式，类似快照。所以又叫 Snapshot。</span><br></pre></td></tr></table></figure></p><h3 id="四、AOF"><a href="#四、AOF" class="headerlink" title="四、AOF"></a>四、AOF</h3><p>AOF的工作原理是讲写操作（数据）格式化追加到日志尾部，该日志文件保存了所有的历史操作数据，这一点非常类似Mysql中的bin.log。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：AOF这种方式可以保证较高的数据完整性，可以设置不同的策略，比如不保存，每一秒钟保存一次，或者每执行一个命令保存一次。AOF的默认策略为每一秒钟保存一次, 就算出现down机最多也就丢失<span class="number">1</span>秒钟的数据, AOF备份数据因为是在后台线程执行fork子进程, 所以不会阻塞主线程。</span><br><span class="line">缺点：对于同样规模的数据备份的文件体积AOF要大于RDB。在备份速度上面也会慢于RDB，恢复速度同样也没有RDB快。</span><br></pre></td></tr></table></figure></p><h3 id="五、AOF备份触发机制"><a href="#五、AOF备份触发机制" class="headerlink" title="五、AOF备份触发机制"></a>五、AOF备份触发机制</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Redis服务端接收到客户端bgrewriteaof指令请求，如果当前没有在进行备份那么立即进行备份，否则等待备份完毕之后再执行备份。</span><br><span class="line"><span class="number">2.</span> Redis conf配置了<span class="keyword">auto</span>-aof-rewrite-percentage和<span class="keyword">auto</span>-aof-rewrite-<span class="built_in">min</span>-<span class="built_in">size</span>参数，并且当前AOF文件大小server.aof_current_size大于<span class="keyword">auto</span>-aof-rewrite-<span class="built_in">min</span>-<span class="built_in">size</span>，且AOF文件大小的增长率大于<span class="keyword">auto</span>-aof-rewrite-percentage时触发备份。</span><br><span class="line"><span class="number">3.</span> 使用<span class="built_in">config</span> <span class="built_in">set</span> appendonly yes命令时，调用startAppendOnly()函数触发备份。</span><br></pre></td></tr></table></figure><h3 id="六、那究竟使用哪种方式？"><a href="#六、那究竟使用哪种方式？" class="headerlink" title="六、那究竟使用哪种方式？"></a>六、那究竟使用哪种方式？</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RDB 会有丢失数据风险，备份文件体积小，数据备份/恢复速度快。</span><br><span class="line">AOF 数据完整性更加安全，但是频繁备份需要过多的<span class="built_in">io</span>操作性能会受到影响，备份文件体积较大，数据恢复速度慢。</span><br></pre></td></tr></table></figure><p>首先，我们明白AOF, RDB的优缺点之后可以概括出: AOF适合热备，RDB适合冷备，Redis4.0以后允许使用aof-use-rdb-preamble配置项打开RDB-AOF混合持久化。</p><h3 id="七、RDB-AOF混合使用的之后备份文件的变化"><a href="#七、RDB-AOF混合使用的之后备份文件的变化" class="headerlink" title="七、RDB/AOF混合使用的之后备份文件的变化"></a>七、RDB/AOF混合使用的之后备份文件的变化</h3><p>当RDB和AOF同时开启之后<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>Redis默认会优先加载AOF的配置文件。</span><br><span class="line"><span class="bullet">2. </span>AOF备份文件的内容格式发生改变，备份文件前半段是RDB格式的全量数据后半段是Redis命令格式的增量数据。</span><br></pre></td></tr></table></figure></p><h3 id="八、AOF文件内容格式"><a href="#八、AOF文件内容格式" class="headerlink" title="八、AOF文件内容格式"></a>八、AOF文件内容格式</h3><p>AOF文件内容格式是Redis通讯协议RESP（REdis Serialization Protocol）格式的命令文本存储，在此不展开学习后续会专门学习Redis的RESP协议。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>附上Redis对于持久化方式说明的文档</p><blockquote><p><a href="https://redis.io/topics/persistence" target="_blank" rel="noopener">https://redis.io/topics/persistence</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。&lt;/p&gt;
&lt;h3 id=&quot;一、Redis数据存储的方式有两种&quot;&gt;&lt;a href=&quot;#一、Redis数据存储的方式有两种&quot; class=&quot;headerlink&quot; title=&quot;一、Redis数据存储的方式有两种&quot;&gt;&lt;/a&gt;一、Redis数据存储的方式有两种&lt;/h3&gt;&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;单纯的缓存模式, 整个数据的生命周期随着Redis &lt;span class=&quot;built_in&quot;&gt;Server&lt;/span&gt;的停止而消失。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;persistence模式, 数据会持续备份到磁盘文件。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;二、Redis如何实现持久化存储？Redis提供了两种方式。&quot;&gt;&lt;a href=&quot;#二、Redis如何实现持久化存储？Redis提供了两种方式。&quot; class=&quot;headerlink&quot; title=&quot;二、Redis如何实现持久化存储？Redis提供了两种方式。&quot;&gt;&lt;/a&gt;二、Redis如何实现持久化存储？Redis提供了两种方式。&lt;/h3&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;RDB&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Redis DataBase)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;AOF&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Append-only file)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="redis" scheme="http://xupin.im/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>设备通知推送 - Google FCM</title>
    <link href="http://xupin.im/2017/02/28/google-msg-push/"/>
    <id>http://xupin.im/2017/02/28/google-msg-push/</id>
    <published>2017-02-27T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.751Z</updated>
    
    <content type="html"><![CDATA[<p>Firebase 是一个移动平台，可以帮助您快速开发高品质应用，扩大用户群，并赚取更多收益。Firebase 由多种互补功能组成，您可以自行组合和匹配这些功能以满足自己的需求。</p><h3 id="1-获取Google推送的KEY-Google应用后台"><a href="#1-获取Google推送的KEY-Google应用后台" class="headerlink" title="1.获取Google推送的KEY(Google应用后台)"></a>1.获取Google推送的KEY(Google应用后台)</h3><blockquote><p>AIzaSyCm5Vufc1FAtWE1kupGhVDRb0ThkCoWC7d // 这个是我的</p></blockquote><h3 id="2-PHP推送代码"><a href="#2-PHP推送代码" class="headerlink" title="2.PHP推送代码"></a>2.PHP推送代码</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化环境</span></span><br><span class="line">$url = <span class="string">'https://fcm.googleapis.com/fcm/send'</span>;</span><br><span class="line">$ch = curl_init($url);</span><br><span class="line">curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, <span class="keyword">false</span>);</span><br><span class="line">curl_setopt($ch, CURLOPT_RETURNTRANSFER,<span class="number">1</span>);</span><br><span class="line">curl_setopt($ch, CURLOPT_POST, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">$header = <span class="keyword">array</span>(</span><br><span class="line"><span class="string">'Content-Type: application/json'</span>,</span><br><span class="line"><span class="string">'Authorization: key=AIzaSyCm5Vufc1FAtWE1kupGhVDRb0ThkCoWC7d'</span> <span class="comment">// 这里是刚才的KEY</span></span><br><span class="line">);</span><br><span class="line">curl_setopt($ch, CURLOPT_HTTPHEADER, $header);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建消息体,json编码</span></span><br><span class="line">$content = json_encode([</span><br><span class="line"><span class="string">'notification'</span>=&gt;[</span><br><span class="line"><span class="string">'title'</span> =&gt; <span class="string">'这里是标题'</span>, </span><br><span class="line"><span class="string">'body'</span> =&gt; <span class="string">'这里是内容'</span>, </span><br><span class="line"><span class="string">'icon'</span> =&gt; <span class="string">'这里是后台设置的iconName'</span></span><br><span class="line">],</span><br><span class="line"><span class="string">'to'</span>=&gt;<span class="string">'设备标识(Google SDK可以获取)'</span>,</span><br><span class="line"><span class="string">'registration_ids'</span>=&gt;[<span class="string">'设备标识'</span>,<span class="string">'设备标识'</span>] <span class="comment">// 如果要推送多台设备,可以使用此字段,最多支持1000台设备</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">curl_setopt($ch, CURLOPT_POSTFIELDS, $content);</span><br><span class="line"></span><br><span class="line">$ret = json_decode(curl_exec($ch), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">$ret[<span class="string">'success'</span>]; <span class="comment">// 推送成功数</span></span><br><span class="line"></span><br><span class="line">$ret[<span class="string">'failure'</span>]; <span class="comment">// 推送失败数</span></span><br></pre></td></tr></table></figure><h3 id="3-返回值示例"><a href="#3-返回值示例" class="headerlink" title="3.返回值示例"></a>3.返回值示例</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"multicast_id"</span>: <span class="number">7669649331143639654</span>,</span><br><span class="line">    <span class="attr">"success"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"failure"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"canonical_ids"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"results"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"message_id"</span>: <span class="string">"0:1488360060090224%6490a2d16490a2d1"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"message_id"</span>: <span class="string">"0:1488360060095871%6490a2d16490a2d1"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"message_id"</span>: <span class="string">"0:1488360060090765%6490a2d16490a2d1"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Google-FCM-文档"><a href="#4-Google-FCM-文档" class="headerlink" title="4.Google(FCM) 文档"></a>4.Google(FCM) 文档</h3><blockquote><p><a href="https://firebase.google.com/docs" target="_blank" rel="noopener">https://firebase.google.com/docs</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Firebase 是一个移动平台，可以帮助您快速开发高品质应用，扩大用户群，并赚取更多收益。Firebase 由多种互补功能组成，您可以自行组合和匹配这些功能以满足自己的需求。&lt;/p&gt;
&lt;h3 id=&quot;1-获取Google推送的KEY-Google应用后台&quot;&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
    <category term="google fcm" scheme="http://xupin.im/tags/google-fcm/"/>
    
  </entry>
  
  <entry>
    <title>设备通知推送 - Apple APNS</title>
    <link href="http://xupin.im/2017/02/22/apple-msg-push/"/>
    <id>http://xupin.im/2017/02/22/apple-msg-push/</id>
    <published>2017-02-21T16:00:00.000Z</published>
    <updated>2022-07-15T02:59:17.748Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-合成证书-需要两个文件-cer-p12-苹果开发者后台获取"><a href="#1-合成证书-需要两个文件-cer-p12-苹果开发者后台获取" class="headerlink" title="1.合成证书(需要两个文件.cer,.p12,苹果开发者后台获取)"></a>1.合成证书(需要两个文件<em>.cer,</em>.p12,苹果开发者后台获取)</h3><blockquote><p>ios.cer,ios.p12 // 我这里的文件名</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ openssl x509 -<span class="keyword">in</span> ios.cer -inform der -out ios_cer.pem</span><br><span class="line">$ openssl pkcs12 -nocerts -out ios_p12.pem -<span class="keyword">in</span> ios.p12</span><br><span class="line">Enter Import Password: // 这里输入Apple后台文件导出时的密码</span><br><span class="line">MAC verified OK</span><br><span class="line">Enter PEM pass phrase: // 这里输入新的pem密码(用于代码中),我输入的是123456789</span><br><span class="line">$ cat ios_cer.pem ios_p12.pem &gt; key.pem</span><br></pre></td></tr></table></figure><h3 id="2-PHP推送代码"><a href="#2-PHP推送代码" class="headerlink" title="2.PHP推送代码"></a>2.PHP推送代码</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化环境</span></span><br><span class="line">$ctx = stream_context_create();</span><br><span class="line"></span><br><span class="line">stream_context_set_option($ctx, <span class="string">'ssl'</span>, <span class="string">'local_cert'</span>, <span class="string">'assets/key/key.pem'</span>); <span class="comment">// key文件的路径</span></span><br><span class="line">stream_context_set_option($ctx, <span class="string">'ssl'</span>, <span class="string">'passphrase'</span>, <span class="string">'123456789'</span>); <span class="comment">// 生成pem输入的密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立APNS连接</span></span><br><span class="line">$fp = stream_socket_client( <span class="string">'ssl://gateway.push.apple.com:2195'</span>, $err, $errstr, <span class="number">60</span>, STREAM_CLIENT_CONNECT|STREAM_CLIENT_PERSISTENT, $ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建消息体,json编码</span></span><br><span class="line">$payload = json_encode( <span class="keyword">array</span>( <span class="string">'aps'</span>=&gt;<span class="keyword">array</span>(<span class="string">'alert'</span> =&gt; <span class="string">'这里是内容'</span>, <span class="string">'sound'</span> =&gt; <span class="string">'这里是提示声音'</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换二进制</span></span><br><span class="line">$msg = chr(<span class="number">0</span>) . pack(<span class="string">'n'</span>, <span class="number">32</span>) . pack(<span class="string">'H*'</span>, <span class="string">'设备标识(Apple SDK可以获取)'</span>) . pack(<span class="string">'n'</span>, strlen($payload)) . $payload;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line">$result = fwrite($fp, $msg, strlen($msg));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!$result)&#123;</span><br><span class="line"><span class="comment">// 推送失败</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 推送成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose($fp);</span><br></pre></td></tr></table></figure><h3 id="3-APNS文档"><a href="#3-APNS文档" class="headerlink" title="3.APNS文档"></a>3.APNS文档</h3><blockquote><p><a href="https://developer.apple.com/notifications/" target="_blank" rel="noopener">https://developer.apple.com/notifications/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-合成证书-需要两个文件-cer-p12-苹果开发者后台获取&quot;&gt;&lt;a href=&quot;#1-合成证书-需要两个文件-cer-p12-苹果开发者后台获取&quot; class=&quot;headerlink&quot; title=&quot;1.合成证书(需要两个文件.cer,.p12,苹果开发者后台</summary>
      
    
    
    
    
    <category term="apns" scheme="http://xupin.im/tags/apns/"/>
    
    <category term="develop" scheme="http://xupin.im/tags/develop/"/>
    
  </entry>
  
</feed>
