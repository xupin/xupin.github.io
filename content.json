[{"title":"Golang 实现定时任务调度","date":"2020-01-19T11:30:00.000Z","path":"2020/01/19/go-console/","text":"每一个任务都需要编写一个Crontab命令，这是件很麻烦且很不友好的事情。 任务调度器允许你以代码的形式定义调度命令，并且服务器上只需要一个Crontab命令即可, 任务调度又是我们俗称的 “计划任务” 1.工欲善其事，必先利其器Github一番搜索，发现Golang有个cron包（robfig/cron）大概满足需求，于是学习一下。 2.介绍看了一遍文档，cron包支持的已经很全面了~~~不用自己造轮子了。 表达式 兼容Linux的crontab表达式（支持分钟级别）。 日志 可以很详细的记录调度的任务状态 时区 支持任务级别的时区配置 预定义计划 支持在未来指定的时间去运行 线程安全问题 该cron lib管理任务队列的slice没有做并发安全考虑，可能会出现任务竟抢行为。 3.实例1234567891011121314151617181920212223242526package mainimport ( \"fmt\" \"time\" \"github.com/robfig/cron\")func main() &#123; c := cron.New() c.AddFunc(\"* * * * * *\", test) c.Start() timer := time.NewTimer(time.Second * 10) for &#123; select &#123; case &lt;-timer.C: timer.Reset(time.Second * 10) &#125; &#125;&#125;func test() &#123; fmt.Println(\"I'm a test script!\")&#125; 12345$ go run .I'm a test script!!!I'm a test script!!!I'm a test script!!!... 4.简单封装 main.go 123456789101112131415package mainimport \"cron-example/console\"func main() &#123; quitChan := make(chan bool, 1) // console go func() &#123; console.Default() &#125;() &lt;-quitChan&#125; console.go 12345678910111213141516171819202122232425262728293031package consoleimport ( \"log\" \"time\" \"cron-example/console/commands\" \"github.com/robfig/cron\")func schedule(c *cron.Cron) &#123; c.AddFunc(\"* * * * * *\", commands.Test)&#125;func Default() &#123; log.Println(\"Starting...\") c := cron.New() c.Start() schedule(c) timer := time.NewTimer(time.Second * 10) for &#123; select &#123; case &lt;-timer.C: timer.Reset(time.Second * 10) &#125; &#125;&#125; https://github.com/xupin/go-cron-example","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"golang","slug":"golang","permalink":"http://xupin.im/tags/golang/"}]},{"title":"PHP踩坑小记 - aliyundb SQLSetStatement is NOT supported","date":"2020-01-07T11:30:00.000Z","path":"2020/01/07/php-aliyundb/","text":"PHP项目在数据库迁移使用ADB（aliyundb）时发现这个问题，具体错误描述是：1SQLSTATE[HY000]: General error: 1815 [15022, 2020010711034801025210201503151413416] statement type: class com.alibaba.fastsql.sql.ast.statement.SQLSetStatement is NOT supported! (SQL: select * from `users`) 在排查该问题的过程中，尝试了各种方式，降版本、使用原生语句等，甚至查找ADB手册和Issue还是无法解决。 1.原因因为ADB兼容Mysql但是有些机制还是略有不同，阅读源码后发现比如：ADB就不能很好的支持本地预处理语句，这也是该异常的原因。 2.解决方案PHP PDO链接的属性值PDO::ATTR_EMULATE_PREPARES需要设置为true1PDO::ATTR_EMULATE_PREPARES =&gt; true","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"php","slug":"php","permalink":"http://xupin.im/tags/php/"}]},{"title":"高性能Golang WEB框架Gin - 初探","date":"2019-12-31T04:30:00.000Z","path":"2019/12/31/go-gin/","text":"Gin 是一个用 Go (Golang) 编写的 HTTP web 框架。 它是一个类似于 martini 但拥有更好性能的 API 框架, 由于 httprouter，速度提高了近 40 倍。 1.有哪些优点 较高的性能（Golang WEB框架比对数据） 简单易用的中间件 使用了性能高可扩展的HTTP路由httprouter 社区长期有着很高的活跃度 Github星星多（Orz） …等 2.安装/更新安装1$ go get github.com/gin-gonic/gin 更新1$ go get -u github.com/gin-gonic/gin 3.Hello World1234567891011121314151617181920package mainimport ( \"github.com/gin-gonic/gin\")func main() &#123; // 框架 g := gin.Default() // 路由 g.GET(\"/t\", test) // 服务端口 g.Run(\":4000\")&#125;func test(c *gin.Context) &#123; c.String(200, \"Hallo!\")&#125; 运行1$ go run main.go 访问 http://127.0.0.1:4000/t ，页面输出Hallo!。 4.路由Gin支持的路由方式和大部分主流框架基本一致。12345678910111213func main() &#123; g := gin.Default() g.GET(\"/someGet\", getting) g.POST(\"/somePost\", posting) g.PUT(\"/somePut\", putting) g.DELETE(\"/someDelete\", deleting) g.PATCH(\"/somePatch\", patching) g.HEAD(\"/someHead\", head) g.OPTIONS(\"/someOptions\", options) g.Run(\":4000\")&#125; Gin同样也支持路由参数，不过不支持路由正则表达式。1234567891011121314151617181920func main() &#123; g := gin.Default() // 此 handler 只能匹配 /user/&#123;PARAM&#125; g.GET(\"/user/:name\", func(c *gin.Context) &#123; name := c.Param(\"name\") c.String(http.StatusOK, \"Hello %s\", name) &#125;) // 此 handler 会匹配 /user/&#123;PARAM&#125;/ 和 /user/&#123;PARAM&#125;/&#123;ACTION_2&#125; // 如果访问 /user/&#123;PARAM&#125;，在没有 \"/user/:name\" 路由的情况下，会重定向至 /user/&#123;PARAM&#125;/ 匹配当前路由。 g.GET(\"/user/:name/*action\", func(c *gin.Context) &#123; name := c.Param(\"name\") action := c.Param(\"action\") message := name + \" is \" + action c.String(http.StatusOK, message) &#125;) g.Run(\":4000\")&#125; 5.路由组Gin在路由分组上的做法和其他框架也都是一致的，再次体现了Gin简单易用极容易上手的优点。1234567891011121314151617func main() &#123; g := gin.Default() userGroup := g.Group(\"/user\") &#123; userGroup.POST(\"/login\", ctrls.Login) userGroup.POST(\"/logout\", ctrls.Logout) &#125; reportGroup := g.Group(\"/report\") &#123; reportGroup.POST(\"/revenue\", ctrls.RevenueReport) reportGroup.POST(\"/cost\", ctrls.CostReport) &#125; g.Run(\":4000\")&#125; 6.中间件Gin的中间件分为：全局，路由组，路由级别。123456789101112131415func main() &#123; g := gin.Default() // 全局中间件 g.Use(middleware) // 路由组中间件 routerGroup := g.Group(\"/user\", middleware) &#123; // 路由中间件 routerGroup.GET(\"/login\", middleware, ctrls.Login) &#125; g.Run(\":4000\")&#125; 7.参数Gin如何获取请求参数？下面的简单例子：123456789101112131415161718192021222324func main() &#123; g := gin.Default() // URL参数 // URL：/user?email=mark@im.com g.GET(\"/user\", func(c *gin.Context) &#123; // 使用 DefaultQuery 或者 Query email := c.DefaultQuery(\"email\", \"default value\") email = c.Query(\"email\") c.String(http.StatusOK, \"Hallo, %s\", email) &#125;) // POST参数 g.POST(\"/user/login\", func(c *gin.Context) &#123; // 使用 DefaultPostForm 或者 PostForm email := c.PostForm(\"email\") email = c.DefaultPostForm(\"email\", \"default value\") c.String(http.StatusOK, \"Hallo, %s\", email) &#125;) g.Run(\":4000\")&#125; 最后Gin支持的操作还有很多，比如：数据绑定、数据验证、上传文件、静态资源嵌入等。 Gin没有提供的组件也有很多，比如：ORM、Console、日志滚动分割等。 仁者见仁智者见智，Gin专注做HTTP WEB框架的核心，更多扩展需要开发人员自己去选择，组件化的设计无疑是好的。","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"golang","slug":"golang","permalink":"http://xupin.im/tags/golang/"}]},{"title":"10分钟学会使用Tmux","date":"2019-12-24T04:30:00.000Z","path":"2019/12/24/tmux/","text":"Tmux是一个终端多路复用器：它使从单个屏幕创建，访问和控制多个终端成为可能。Tmux可能会与屏幕分离，并继续在后台运行，然后再重新连接。 1.Tmux的结构 Session Window Panel 即，Tmux允许访问多个会话，每个会话可以拥有多个窗口，每个窗口还可以进行划分窗格。 2.安装运行Tmux安装12345678# centos$ yum install tmux# ubuntu$ apt install tmux# mac$ brew install tmux 运行1$ tmux 效果图，如下： 底面状态栏的左侧是会话窗口相关信息，右侧是系统相关信息。 退出 1$ exit // 或者Ctrl + D 3.Tmux怎么分屏呢？首先，在Tmux中所有的快捷键都是以Ctrl + B开头的（默认是这样）。 横向划分窗格：Ctrl + B %竖向划分窗格：Ctrl + B “（英文） 窗格分好了，怎么切换窗格呢？ Ctrl + B Up/Down/Left/Right（键盘方向键）亦或自定义键。12345vim ~/.tmux.confbind h select-pane -Lbind j select-pane -Dbind k select-pane -Ubind l select-pane -R 示例图，如下： 最后本小白文仅仅简单教会入门使用Tmux，Tmux支持的操作远远不止这么简单。 比如快捷键： 新建窗口：Ctrl + B c 切换下一个窗口：Ctrl + B n 切换上一个窗口：Ctrl + B p 比如命令： 新建会话：tmux new -s 会话列表：tmux ls / tmux list-session 关于Tmux更多内容可以去官方文档了解一下 https://github.com/tmux/tmux#documentation","tags":[{"name":"tools","slug":"tools","permalink":"http://xupin.im/tags/tools/"},{"name":"tmux","slug":"tmux","permalink":"http://xupin.im/tags/tmux/"}]},{"title":"Elasticsearch实现字段分组","date":"2019-12-17T11:30:00.000Z","path":"2019/12/17/elasticsearch-group/","text":"Elasticsearch是Elastic Stack核心的分布式搜索和分析引擎。 1.背景因为业务调整采用了ES作为数据库，所以需要了解ES对于这一块的设计如何实现类似Mysql中Group By的查询的效果。 2.实现方式ES实现Group By有两种方式：TermsAgg、CompositeAgg，它们也具有不同程度的优缺点。 TermsAgg的使用方式非常粗暴，直接进行桶嵌套即可，如下: TermsAgg请求DSL语句12345678910111213141516171819&#123; \"aggregations\": &#123; \"group_app\": &#123; \"terms\": &#123; \"field\": \"app\", \"size\": 1000000 &#125;, \"aggregations\": &#123; \"group_campaign_id\": &#123; \"terms\": &#123; \"field\": \"campaign_id\", \"size\": 1000000 &#125; &#125; &#125; &#125; &#125;, \"size\": 0&#125; TermsAgg执行结果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&#123; \"took\": 142, \"timed_out\": false, \"_shards\": &#123; \"total\": 5, \"successful\": 5, \"skipped\": 0, \"failed\": 0 &#125;, \"hits\": &#123; \"total\": 175033, \"max_score\": 0.0, \"hits\": [] &#125;, \"aggregations\": &#123; \"group_app\": &#123; \"doc_count_error_upper_bound\": 0, \"sum_other_doc_count\": 0, \"buckets\": [ &#123; \"key\": \"com.aa.bb.cc\", \"doc_count\": 59929, \"group_campaign_id\": &#123; \"doc_count_error_upper_bound\": 0, \"sum_other_doc_count\": 0, \"buckets\": [ &#123; \"key\": \"Campaign_118\", \"doc_count\": 56466 &#125;, &#123; \"key\": \"Campaign_119\", \"doc_count\": 1937 &#125; ] &#125; &#125;, &#123; \"key\": \"com.dd.ee.ff\", \"doc_count\": 23231, \"group_campaign_id\": &#123; \"doc_count_error_upper_bound\": 0, \"sum_other_doc_count\": 0, \"buckets\": [ &#123; \"key\": \"Campaign_120\", \"doc_count\": 16692 &#125;, &#123; \"key\": \"Campaign_121\", \"doc_count\": 5336 &#125; ] &#125; &#125; ] &#125; &#125;&#125; CompositeAgg的使用方式略微有一些不同，下面： CompositeAgg请求DSL语句1234567891011121314151617181920212223242526&#123; \"aggregations\": &#123; \"group_by\": &#123; \"composite\": &#123; \"sources\": [ &#123; \"app\": &#123; \"terms\": &#123; \"field\": \"app\" &#125; &#125; &#125;, &#123; \"campaign_id\": &#123; \"terms\": &#123; \"field\": \"campaign_id\" &#125; &#125; &#125; ], \"size\": 1000 &#125; &#125; &#125;, \"size\": 0&#125; CompositeAgg执行结果123456789101112131415161718192021222324252627282930313233343536373839&#123; \"took\": 14, \"timed_out\": false, \"_shards\": &#123; \"total\": 5, \"successful\": 5, \"skipped\": 0, \"failed\": 0 &#125;, \"hits\": &#123; \"total\": 175033, \"max_score\": 0.0, \"hits\": [] &#125;, \"aggregations\": &#123; \"group_by\": &#123; \"after_key\": &#123; \"app\": \"com.dd.ee.ff\", \"campaign_id\": \"Campaign_120\" &#125;, \"buckets\": [ &#123; \"key\": &#123; \"app\": \"com.aa.bb.cc\", \"campaign_id\": \"Campaign_119\" &#125;, \"doc_count\": 182 &#125;, &#123; \"key\": &#123; \"app\": \"com.dd.ee.ff\", \"campaign_id\": \"Campaign_120\" &#125;, \"doc_count\": 40 &#125; ] &#125; &#125;&#125; 3.优缺点TermsAgg 优点：使用简单、没有数据量限制。 缺点：数据结构层次深、不支持分页。 CompositeAgg 优点：使用简单、数据结构清晰可读，支持分页。 缺点：有数据量限制。 最后至于ES这两种分组方式的性能方面还没有研究，后续学习笔记会更新性能上面的差异。 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-composite-aggregation.html // 附上ES官方文档","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://xupin.im/tags/elasticsearch/"}]},{"title":"Nginx正向代理和反向代理","date":"2019-12-17T04:30:00.000Z","path":"2019/12/17/nginx-proxy/","text":"代理通常用于在几台服务器之间分配负载，无缝显示来自不同网站的内容或通过除HTTP之外的协议将处理请求传递给应用服务器。 1.代理的常用场景及优点正向代理 gfw科学上网。 客户端访问鉴权。 反向代理 负载均衡。 保证内网的安全，阻止web攻击。 2.正向代理和反向代理有什么不同比较通俗的来解释：正向代理代理的是客户端，服务端不知道实际发起请求的客户端、反向代理代理的是服务端，客户端不知道实际接收请求的服务端。 一张图表示（来源：知乎wplulala）","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"nginx","slug":"nginx","permalink":"http://xupin.im/tags/nginx/"}]},{"title":"简单的优化Mysql索引","date":"2019-12-16T11:30:00.000Z","path":"2019/12/16/mysql-index/","text":"索引用于快速查找具有特定列值的行。没有索引，MySQL必须从第一行开始，然后通读整个表以找到相关的行。桌子越大，花费越多。如果表中有相关​​列的索引，MySQL可以快速确定要在数据文件中间查找的位置，而不必查看所有数据。这比顺序读取每一行要快得多。InnoDB和MyISAM只支持BTREE，因此默认均是BTree，MEMORY和HEAP支持Hash和Btree，如无明确声明，则默认索引均是Hash（包括主键）。 1.Mysql有哪些常用的索引 主键索引：数据列不允许重复，不允许为null，一个表只能有一个主键。 唯一索引：数据列不允许重复，允许为null，一个表允许多个列创建唯一索引。 普通索引：基本的索引类型，没有唯一性的限制，允许为null。 全文索引：全文索引是目前实现大数据搜索的关键技术。 2.如何分析SQL语句执行性能以下是两种分析SQL性能的常用方式，explain、show profiles/show profile。 explain + SQL语句，获取SQL分析数据 select_type：对应SQL语句的查询复杂度。 table：正在访问的表。 partitions：数据所在的分区。 type：表示是否用上索引，以及索引是如何使用的，此字段决定索引的性能。ALL&lt;TYPE&lt;RANGE&lt;REF&lt;CONST possible_keys：查询条件存在的索引。 key：触发的索引。 key_len：索引字段的长度。 ref：索引访问，返回所有匹配某个单值的行。 rows：执行查询必须检查的行数，在InnoDB中此值不精确。 filtered：条件过滤出的行数的百分比。 extra：查询分析结果的额外信息，很重要 e.g. Using index、Using where … show profiles 获得当前会话中执行的SQL语句，字段为：Query_ID, Duration, Query，show profile all for query {Query_ID} 3.Mysql索引的建立原则Mysql的索引遵循最左原则，在创建多列索引时，要根据业务需求，where条件中使用最频繁的一列放在最左边。12345678910111213index(a,b,c)where a = v // 使用awhere a = v and b = v // 使用a,bwhere a = v and b = v and c = v // 使用a,b,cwhere b = v // 未使用索引where a = v and c = v // 使用awhere b = v and c = v // 未使用索引where a &gt; v // 是否使用索引，取决于查询结果集，如果全表扫描速度比索引速度快，那么不使用索引。where a like \"v%\" // 使用awhere a like \"%v%\" // 不适用索引 4.Mysql中索引建立常见问题 为经常需要排序、分组和联合操作的字段建立索引 为常作为查询条件的字段建立索引 索引列值保证唯一性 索引建立的数量不要过多 索引列不要使用函数或者表达式 行锁依赖索引的建立 普通索引的数据重复率过高会导致索引失效 最左原则","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"mysql","slug":"mysql","permalink":"http://xupin.im/tags/mysql/"}]},{"title":"Mysql的事务隔离级别","date":"2019-12-05T04:30:00.000Z","path":"2019/12/05/mysql-transaction/","text":"什么是事务？事务（Transaction）一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)，具有4个特性：原子性、一致性、隔离性、持久性，简称ACID。 那么Mysql的事务隔离级别又是什么呢？Mysql的事务隔离级别分别是4种：未提交读（Read Uncommitted）、已提交读（Read Committed）、Repeatable Read（可重复读）、Serializable（可串行化）。可以简单理解为Mysql事务的4种执行标准。 一、ACID特性 原子性（Atomicity）：一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。 一致性（Consistency）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。 隔离性（Isolation）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（Durability）：指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。 二、Mysql事务隔离级别 未提交读（Read Uncommitted），指当前事务可以读取到其他事务还未提交的数据变化，最容易带来的问题是脏读（Dirty Read），很少应用到生产环境。 已提交读（Read Committed），大部分数据库默认隔离级别但不包括Mysql，指当前事务可以读取其他事务已提交的数据变化，具有隔离性的基本标准，但是在出现交叉事务的并发操作场景中会发生两次读取的数据结果集不一致的问题，即不可重复读（Nonrepeatable Read）。 Repeatable Read（可重复读），Mysql数据库的默认隔离级别，这里顺便解释一下为什么Mysql的隔离级别不是Read Committed，因为在Mysql5.0之前日志格式只有statement这一种，这种格式导致主从复制一致性很难得到保证。这种隔离级别可以解决Nonrepeatable Read的问题，但如果也出现在交叉事务的并发操作场景会出现幻读（Phantom Read）的现象，这一行为状态是当前事务不能及时有效的读取其他事务的数据变化。 Serializable（可串行化），Mysql事务隔离最高级别，望文生义大概意思是事务的执行是有序（串行化顺序）的，不存在事务交叉执行的场景从而解决了Phantom Read的问题，但是在高并发的业务场景下请求会出现阻塞、超时、锁竟抢的问题，系统的可用性也随之降低。 收尾什么时候使用事务以及Mysql事务隔离级别的应用还是要根据业务场景和系统架构来选择。 https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html // Mysql事务官方文档","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"mysql","slug":"mysql","permalink":"http://xupin.im/tags/mysql/"}]},{"title":"通俗解释什么是悲观锁/乐观锁","date":"2019-12-04T11:30:00.000Z","path":"2019/12/04/pessimistic-optimistic/","text":"什么是锁？在多进程（线程）编程中为了数据的一致性、有效性，如果一资源被某进程（线程）上锁，那么在释放锁之前其他进程（线程）无法进行操作或者等待获取（上）锁。 一、悲观锁悲观锁（Pessimistic locking），顾名思义对待任何事务都持悲观态度，做任何事情都会认为会有竞抢行为~所以在进行任何操作之前都要做好万全准备（上锁）才会继续执行后续的操作。通常是利用系统提供的锁机制来实现。比如：12Mysql中的上锁命令：for update、lock in share mode等Redis中的一些操作命令：setnx、getset等（原子操作） 二、乐观锁乐观锁（Optimistic locking），和悲观锁相反对待任何事务都持乐观态度，只会在最后即将执行操作的时刻前才会进行验证。通常是通过程序配合来实现。比如：1update `orders` set hash = md5(now()) where uid = 1 and hash = &#123;lastHash&#125;; 三、优缺点悲观锁优点很鲜明，因为每次执行的操作都是独占的，数据的一致性、有效性、安全性较高。但缺点同样突出，每次操作都会产生上锁的开销，在并发请求比较密集的情况下容易阻塞或者驳回请求，甚至是造成死锁，也大大降低了系统的性能。 乐观锁优点是省去了锁的开销，能较高的提高系统吞吐量，缺点是如果出现在并发高且竟抢（冲突）行为比较多的场景下数据的一致性很难保证。 综上所述，悲观锁和乐观锁的使用是根据业务的场景来抉择。","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"mysql","slug":"mysql","permalink":"http://xupin.im/tags/mysql/"}]},{"title":"Redis持久化方式aof/rdb浅析","date":"2019-12-03T07:30:00.000Z","path":"2019/12/03/redis-aof-rdb/","text":"Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。 一、Redis数据存储的方式有两种12单纯的缓存模式, 整个数据的生命周期随着Redis Server的停止而消失。persistence模式, 数据会持续备份到磁盘文件。 二、Redis如何实现持久化存储？Redis提供了两种方式。12RDB(Redis DataBase)AOF(Append-only file) 三、RDBRDB的工作原理有点像运维脚本自动化定时备份数据一样，当内存中的数据到达配置的阈值就会执行DUMP操作备份数据到临时文件,备份成功结束后重命名为dump.rdb文件。123优点：fork子进程来进行备份,父进程不会进行io操作。恢复数据时的速度很快。缺点：这种方式是每隔一次才会进行备份,假如下一次备份前down机会丢失部分数据。而且如果备份的数据比较大，fork的子进程将会比较耗时，这段时间内会导致父进程阻塞。补充：因为这种每隔一段时间去备份一次的方式，类似快照。所以又叫 Snapshot。 四、AOFAOF的工作原理是讲写操作（数据）格式化追加到日志尾部，该日志文件保存了所有的历史操作数据，这一点非常类似Mysql中的bin.log。12优点：AOF这种方式可以保证较高的数据完整性，可以设置不同的策略，比如不保存，每一秒钟保存一次，或者每执行一个命令保存一次。AOF的默认策略为每一秒钟保存一次, 就算出现down机最多也就丢失1秒钟的数据, AOF备份数据因为是在后台线程执行fork子进程, 所以不会阻塞主线程。缺点：对于同样规模的数据备份的文件体积AOF要大于RDB。在备份速度上面也会慢于RDB，恢复速度同样也没有RDB快。 五、AOF备份触发机制1231. Redis服务端接收到客户端bgrewriteaof指令请求，如果当前没有在进行备份那么立即进行备份，否则等待备份完毕之后再执行备份。2. Redis conf配置了auto-aof-rewrite-percentage和auto-aof-rewrite-min-size参数，并且当前AOF文件大小server.aof_current_size大于auto-aof-rewrite-min-size，且AOF文件大小的增长率大于auto-aof-rewrite-percentage时触发备份。3. 使用config set appendonly yes命令时，调用startAppendOnly()函数触发备份。 六、那究竟使用哪种方式？12RDB 会有丢失数据风险，备份文件体积小，数据备份/恢复速度快。AOF 数据完整性更加安全，但是频繁备份需要过多的io操作性能会受到影响，备份文件体积较大，数据恢复速度慢。 首先，我们明白AOF, RDB的优缺点之后可以概括出: AOF适合热备，RDB适合冷备，Redis4.0以后允许使用aof-use-rdb-preamble配置项打开RDB-AOF混合持久化。 七、RDB/AOF混合使用的之后备份文件的变化当RDB和AOF同时开启之后121. Redis默认会优先加载AOF的配置文件。2. aof备份文件的内容格式发生改变，备份文件前半段是RDB格式的全量数据后半段是redis命令格式的增量数据。 最后附上Redis对于持久化方式说明的文档 https://redis.io/topics/persistence","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"redis","slug":"redis","permalink":"http://xupin.im/tags/redis/"}]},{"title":"使用Guetzli压缩图片","date":"2017-06-12T03:00:00.000Z","path":"2017/06/12/guetzli/","text":"Guetzli is a JPEG encoder that aims for excellent compression density at high visual quality. Guetzli-generated images are typically 20-30% smaller than images of equivalent quality generated by libjpeg. Guetzli generates only sequential (nonprogressive) JPEGs due to faster decompression speeds they offer. 1.安装libpng依赖库1$ yum install libpng-devel git 2.获取Guetzli项目 https://github.com/google/guetzli 123456789101112131415$ cd /tmp$ git clone https://github.com/google/guetzli$ cd guetzli$ make$ ./bin/Release/guetzli // 这里我就不加软连接,为了方便使用你们可以加入软连接Guetzli JPEG compressor. Usage: guetzli [flags] input_filename output_filename // 这里是使用方法Flags: --verbose - Print a verbose trace of all attempts to standard output. --quality Q - Visual quality to aim for, expressed as a JPEG quality value. Default value is 95. --memlimit M - Memory limit in MB. Guetzli will fail if unable to stay under the limit. Default limit is 6000 MB. --nomemlimit - Do not limit memory usage. 3.压缩前后对比压缩前(920KB) 压缩后(748KB),20%","tags":[{"name":"guetzli","slug":"guetzli","permalink":"http://xupin.im/tags/guetzli/"},{"name":"tools","slug":"tools","permalink":"http://xupin.im/tags/tools/"}]},{"title":"部署像Trello一样的看板工具 - Wekan","date":"2017-06-09T04:00:00.000Z","path":"2017/06/09/wekan/","text":"Wekan is an completely Open Source and Free software collaborative kanban board application with MIT license. 1.安装MongoDB123456789$ vi /etc/yum.repos.d/mongodb-org-3.2.repo $ [mongodb-org-3.2]$ name=MongoDB Repository$ baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.2/x86_64/$ gpgcheck=1$ enabled=1$ gpgkey=https://www.mongodb.org/static/pgp/server-3.2.asc$ yum install mongodb-org$ service mongod start // 启动MongoDB 2.安装NodeJS http://nodejs.org/dist/latest/ // pkg列表 我下载的是 http://nodejs.org/dist/latest/node-v8.1.0.tar.xz 1234567891011$ yum install gcc gcc-c++ wget$ cd /tmp$ wget http://nodejs.org/dist/latest/node-v8.1.0.tar.xz$ xz -d node-v8.1.0.tar.xz$ tar -vxf node-v8.1.0.tar$ cd node-v8.1.0$ vi README.md // To build 有告诉需要的环境,以及安装步骤$ ./configure$ make &amp;&amp; make install$ node -v$ v8.1.0 3.获取Wekan项目 https://github.com/wekan/wekan/releases/ // 版本列表 我下载的是 v0.23 1234567891011$ cd /tmp$ wget https://github.com/wekan/wekan/releases/download/v0.23/wekan-0.23.tar.gz$ tar -zxvf wekan wekan-0.23.tar.gz$ mkdir wekan$ mv ./bundle ./wekan $ cd wekan/bundle$ export MONGO_URL='mongodb://127.0.0.1:27017/wekan' $ export ROOT_URL='https://example.com' $ export MAIL_URL='smtp://user:pass@mailserver.example.com:25/' $ export PORT=8080$ node main.js // 如果没有报错,访问http://host:8080就可以使用Wekan啦 4.一些错误问题 ##There is an issue with node-fibers## npm install fibers","tags":[{"name":"tools","slug":"tools","permalink":"http://xupin.im/tags/tools/"},{"name":"wekan","slug":"wekan","permalink":"http://xupin.im/tags/wekan/"}]},{"title":"PHP 图片转换Webp格式","date":"2017-03-21T16:00:00.000Z","path":"2017/03/22/php-webp/","text":"WebP是Google推出的一种图片格式，它基于VP8编码，可对图像大幅压缩。与JPEG相同，WebP也是一种有损压缩，但在画质相同的情况下，WebP格式比JPEG图像小40%。 1.利与弊 WebP 与 JPEG 图像相比，这种格式可对图像大幅压缩。从而显著优化页面加载时间和带宽使用情况。WebP 目前支持桌面上的 Chrome 和 Opera 浏览器。手机支持仅限于原生的 Android 浏览器和 Android 系统上的 Chrome 浏览器,后面会介绍关于如何处理这个限制的方法。 （Google 已和正在部署的 WebP 的产品） 2.后端PHP代码如何转换？12345678910&lt;?php// 文件名$fileName = './res.png';// 图片源$res = imagecreatefrompng($fileName); // 如果是jpg(imagecreatefromjpg),其他格式自行查阅手册// 输出.webp文件imagewebp($res, './res.webp'); (非常简单!) 3.前端JS代码如何判断浏览器支持?1234567891011121314151617181920212223242526272829// 代码片段摘自网站,亲测可用function checkWebp(callback) &#123; var img = new Image(); img.onload = function () &#123; var result = (img.width &gt; 0) &amp;&amp; (img.height &gt; 0); callback(result); &#125;; img.onerror = function () &#123; callback(false); &#125;; img.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';&#125;function showImage(useWebp)&#123; var imgs = Array.from(document.querySelectorAll('img')); imgs.forEach(function(i)&#123; var src = i.attributes['data-src'].value; if (useWebp)&#123; src = src.replace(/\\.jpg$/, '.webp'); &#125; i.src = src; &#125;);&#125;checkWebp(showImage); 4.实例前后对比转换前(378KB) 转换后(8KB)","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"webp","slug":"webp","permalink":"http://xupin.im/tags/webp/"}]},{"title":"PHP + Google(FCM)安卓设备消息推送/群发","date":"2017-02-28T09:10:00.000Z","path":"2017/02/28/google-msg-push/","text":"Firebase 是一个移动平台，可以帮助您快速开发高品质应用，扩大用户群，并赚取更多收益。Firebase 由多种互补功能组成，您可以自行组合和匹配这些功能以满足自己的需求。 1.获取Google推送的KEY(Google应用后台) AIzaSyCm5Vufc1FAtWE1kupGhVDRb0ThkCoWC7d // 这个是我的 2.PHP推送代码12345678910111213141516171819202122232425262728293031// 初始化环境$url = 'https://fcm.googleapis.com/fcm/send';$ch = curl_init($url);curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);curl_setopt($ch, CURLOPT_RETURNTRANSFER,1);curl_setopt($ch, CURLOPT_POST, 1);$header = array( 'Content-Type: application/json', 'Authorization: key=AIzaSyCm5Vufc1FAtWE1kupGhVDRb0ThkCoWC7d' // 这里是刚才的KEY);curl_setopt($ch, CURLOPT_HTTPHEADER, $header);// 构建消息体,json编码$content = json_encode(['notification'=&gt;[ 'title' =&gt; '这里是标题', 'body' =&gt; '这里是内容', 'icon' =&gt; '这里是后台设置的iconName'],'to'=&gt;'设备标识(Google SDK可以获取)','registration_ids'=&gt;['设备标识','设备标识'] // 如果要推送多台设备,可以使用此字段,最多支持1000台设备]);curl_setopt($ch, CURLOPT_POSTFIELDS, $content);$ret = json_decode(curl_exec($ch), true);$ret['success']; // 推送成功数$ret['failure']; // 推送失败数 3.返回值示例1234567891011121314151617&#123; \"multicast_id\": 7669649331143639654, \"success\": 3, \"failure\": 0, \"canonical_ids\": 0, \"results\": [ &#123; \"message_id\": \"0:1488360060090224%6490a2d16490a2d1\" &#125;, &#123; \"message_id\": \"0:1488360060095871%6490a2d16490a2d1\" &#125;, &#123; \"message_id\": \"0:1488360060090765%6490a2d16490a2d1\" &#125; ]&#125; 4.Google(FCM) 文档 https://firebase.google.com/docs","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"google fcm","slug":"google-fcm","permalink":"http://xupin.im/tags/google-fcm/"}]},{"title":"通用缩写表","date":"2017-02-27T16:00:00.000Z","path":"2017/02/28/short-names/","text":"1、本缩写表是《编码命名规范》的附录。2、本缩写表中列出的都是通用性缩写，不提供标准缩写，如：Win9x、COM 等。3、使用本缩写表里的缩写时，请对其进行必要的注释说明。4、除少数情况以外，大部分缩写与大小写无关。 缩写 全称 addr Address adm Administrator app Application arg Argument asm assemble asyn asynchronization avg average DB Database bk back bmp Bitmap btn Button buf Buffer calc Calculate char Character chg Change clk Click clr color cmd Command cmp Compare col Column coord coordinates cpy copy ctl /ctrl Control cur Current cyl Cylinder dbg Debug dbl Double dec Decrease def default del Delete dest /dst Destination dev Device dict dictionary diff different dir directory disp Display div Divide 缩写 全称 dlg Dialog doc Document drv Driver dyna Dynamic env Environment err error ex/ext Extend exec execute flg flag frm Frame func /fn Function grp group horz Horizontal idx /ndx Index img Image impl Implement inc Increase info Information init Initial/Initialize/Initialization ins Insert inst Instance INT /intr Interrupt len Length lib Library lnk Link log logical lst List max maximum mem Memory mgr /man Manage/Manager mid middle min minimum msg Message mul Multiply num Number obj Object ofs Offset org Origin/Original param Parameter pic picture pkg package pnt /pt Point pos Position pre /prev previous 缩写 全称 prg program prn Print proc Process/Procedure prop Properties psw Password ptr Pointer pub Public rc rect ref Reference reg Register req request res Resource ret return rgn region scr screen sec Second seg Segment sel Select src Source std Standard stg Storage stm Stream str String sub Subtract sum summation svr Server sync Synchronization sys System tbl Table temp /tmp Temporary tran /trans translate/transation/transparent tst Test txt text unk Unknown upd Update upg Upgrade util Utility var Variable ver Version vert Vertical vir Virus wnd Window","tags":[{"name":"short names","slug":"short-names","permalink":"http://xupin.im/tags/short-names/"}]},{"title":"Nginx recv() failed (104 Connection reset by peer)","date":"2017-02-23T10:05:00.000Z","path":"2017/02/23/nginx-recv-104/","text":"Error: recv() failed (104: Connection reset by peer) while reading response header from upstream 1.日志信息123456789// www.xxxx.com 公司域名,故此屏蔽2017/02/18 12:03:58 [error] 7519#7519: *33 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 192.168.1.207, server: www.xxxx.com, request: \"POST /Api/GetRegSvrInfo HTTP/1.1\", upstream: \"fastcgi://127.0.0.1:9000\", host: \"192.168.1.201\"2017/02/18 12:03:59 [error] 7519#7519: *35 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 192.168.1.207, server: www.xxxx.com, request: \"POST /Api/GetRegSvrInfo HTTP/1.1\", upstream: \"fastcgi://127.0.0.1:9000\", host: \"192.168.1.201\"2017/02/18 12:04:00 [error] 7519#7519: *37 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 192.168.1.207, server: www.xxxx.com, request: \"POST /Api/GetRegSvrInfo HTTP/1.1\", upstream: \"fastcgi://127.0.0.1:9000\", host: \"192.168.1.201\"2017/02/18 12:04:02 [error] 7519#7519: *39 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 192.168.1.207, server: www.xxxx.com, request: \"POST /Api/GetRegSvrInfo HTTP/1.1\", upstream: \"fastcgi://127.0.0.1:9000\", host: \"192.168.1.201\"2017/02/18 12:04:07 [error] 7519#7519: *9 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 192.168.1.207, server: www.xxxx.com, request: \"GET /Api/GetRegSvrInfo&amp;pid=1&amp;ver=3003 HTTP/1.1\", upstream: \"fastcgi://127.0.0.1:9000\", host: \"192.168.1.201:81\"2017/02/18 12:04:08 [error] 7519#7519: *42 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 192.168.1.207, server: www.xxxx.com, request: \"POST /Api/GetRegSvrInfo HTTP/1.1\", upstream: \"fastcgi://127.0.0.1:9000\", host: \"192.168.1.201\"2017/02/18 12:04:09 [error] 7519#7519: *44 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 192.168.1.207, server: www.xxxx.com, request: \"POST /Api/GetRegSvrInfo HTTP/1.1\", upstream: \"fastcgi://127.0.0.1:9000\", host: \"192.168.1.201\"2017/02/18 12:04:10 [error] 7519#7519: *46 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 192.168.1.207, server: www.xxxx.com, request: \"POST /Api/GetRegSvrInfo HTTP/1.1\", upstream: \"fastcgi://127.0.0.1:9000\", host: \"192.168.1.201\" 2.异常原因 ups请求9000端口之后重置 // 我遇见的问题 3.解决方案1$ iptables -L -n // 检查是否有其他进程占用9000端口 9000端口没有被占用 12$ vi /etc/sysconfig/iptables-A INPUT -i lo -j ACCEPT // 本地回环(lo一般指127.0.0.1),检查是否有这条配置 lo防火墙策略未配置 123$ iptables -A INPUT -i lo -j ACCEPT // 没有配置,执行这个指令$ iptables save // 保存$ iptables restart // 重启生效 4.依然未解决12$ vi /etc/php-fpm.d/www.conf // 这是我的PHP-FPM配置文件request_terminate_timeout = 0/600; // 这样解决一般是PHP某些脚本执行时间过长超时 顽固分子,就是不行!!! 1$ iptables stop // 关闭防火墙之后(慎用,生产环境谨慎操作),试试是否可以访问 如果可以访问,麻烦运维哥哥帮忙看一下防火墙策略o(╯□╰)o!!! 5.其他问题欢迎邮箱我一起讨论解决","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"nginx","slug":"nginx","permalink":"http://xupin.im/tags/nginx/"}]},{"title":"PHP防止XSS攻击、脚本访问Cookie","date":"2017-02-23T08:30:00.000Z","path":"2017/02/23/cookie-httponly/","text":"httponly是微软对cookie做的扩展,主要是解决用户的cookie可能被盗用的问题。 1.Cookie漏洞1234567891011121314151617181920212223242526272829303132333435363738Missing `httpOnly` Cookie Attribute 105925 http (80/tcp) High Vulnerability Detection Result:The cookies:Set-Cookie: PHPSESSID=esjpr7dkb64rgn1kjhr1r45j05; path=/ are missing the httpOnly attribute.Summary:The application is missing the 'httpOnly' cookie attributeSolution:Set the 'httpOnly' attribute for any session cookie.Vulnerability Detection Method:Check all cookies sent by the application for a missing 'httpOnly' attributeInsight:The flaw is due to a cookie is not using the 'httpOnly' attribute. Thisallows a cookie to be accessed by JavaScript which could lead to session hijacking attacks.CVSS Base Vector:AV:N/AC:L/Au:N/C:P/I:N/A:NAffected Software/OS:Application with session handling in cookies.References:https://www.owasp.org/index.php/HttpOnlyhttps://www.owasp.org/index.php/Testing_for_cookies_attributes_(OTG-SESS-002) 2.漏洞表现 跨站点脚本攻击 // 这种攻击手段具体表现,很多博主都写过,在此不表了 3.解决方案1$ vi /etc/php.ini // PHP 5.2版本及以上 session.cookie_httponly = true/1 1234567// PHP 5.2版本及以上ini_set('session.cookie_httponly', 1); // 注册php.ini配置session_set_cookie_params(0, NULL, NULL, NULL, TRUE);setcookie('cookieName', 'cookieValue', NULL, NULL, NULL, NULL, TRUE);setrawcookie('cookieName', 'cookieValue', NULL, NULL, NULL, NULL, TRUE);// PHP 5.1版本及以下header('Set-Cookie: hidden=value; httpOnly'); 4.网站安全扫描工具 Nikto、WebScarab等","tags":[{"name":"xss","slug":"xss","permalink":"http://xupin.im/tags/xss/"},{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"}]},{"title":"Nginx负载均衡配置","date":"2017-02-23T03:00:00.000Z","path":"2017/02/23/nginx-ups/","text":"nginx [engine x] is an HTTP and reverse proxy server, a mail proxy server, and a generic TCP/UDP proxy server, originally written by Igor Sysoev. 1.服务器列表 // 我们有如下两台服务器,都部署了Nginx 192.168.1.1 // host指向这台服务器 192.168.1.2 2.Nginx配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 打开192.168.1.1这台服务器的nginx.conf,编辑后保存http &#123; . . . // 无关紧要的部分忽略掉 upstream lee&#123; // 这里的ups name自定义,我这里使用lee // 这里除了80端口以外,其他端口都可以使用 server 127.0.0.1:8080; server 192.168.1.2:8080; &#125; server&#123; listen 80; // ups监听80 server_name www.xxx.com xxx.comn; // 这个可选,一般是你指向这台服务器的Host location / &#123; proxy_pass http://lee; // 这里是上面自定的ups name proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; &#125; server &#123; listen 8080; server_name 127.0.0.1; root /var/www/html; // 这里是你的Nginx根目录 index index.php index.html index.htm; location /status &#123; stub_status on; &#125; location ~ \\.php &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include /etc/nginx/fastcgi_params; &#125; location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf|js|css)$ &#123; expires 30d; &#125; &#125;&#125;// 打开192.168.1.2这台服务器的nginx.conf,编辑后保存http &#123; . . . // 无关紧要的部分忽略掉 server &#123; listen 8080; server_name 192.168.1.2; root /var/www/html; // 这里是你的Nginx根目录 index index.php index.html index.htm; location /status &#123; stub_status on; &#125; location ~ \\.php &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include /etc/nginx/fastcgi_params; &#125; location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf|js|css)$ &#123; expires 30d; &#125; &#125;&#125; 3.重新加载Nginx配置1234$ nginx -tc /etc/nginx/nginx.conf // 你nginx.conf所在的目录,检查配置是否存在问题nginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful$ nginx -s reload // 不需要停服,直接重载配置 4.Hi 007,任务完成12// 编辑个脚本测试一下,echo 'Hi 007';","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"nginx","slug":"nginx","permalink":"http://xupin.im/tags/nginx/"}]},{"title":"PHP + Apple苹果设备消息推送(APNS)","date":"2017-02-22T09:30:00.000Z","path":"2017/02/22/apple-msg-push/","text":"1.合成证书(需要两个文件.cer,.p12,苹果开发者后台获取) ios.cer,ios.p12 // 我这里的文件名 123456$ openssl x509 -in ios.cer -inform der -out ios_cer.pem$ openssl pkcs12 -nocerts -out ios_p12.pem -in ios.p12Enter Import Password: // 这里输入Apple后台文件导出时的密码MAC verified OKEnter PEM pass phrase: // 这里输入新的pem密码(用于代码中),我输入的是123456789$ cat ios_cer.pem ios_p12.pem &gt; key.pem 2.PHP推送代码12345678910111213141516171819202122232425// 初始化环境$ctx = stream_context_create();stream_context_set_option($ctx, 'ssl', 'local_cert', 'assets/key/key.pem'); // key文件的路径stream_context_set_option($ctx, 'ssl', 'passphrase', '123456789'); // 生成pem输入的密码// 建立APNS连接$fp = stream_socket_client( 'ssl://gateway.push.apple.com:2195', $err, $errstr, 60, STREAM_CLIENT_CONNECT|STREAM_CLIENT_PERSISTENT, $ctx);// 构建消息体,json编码$payload = json_encode( array( 'aps'=&gt;array('alert' =&gt; '这里是内容', 'sound' =&gt; '这里是提示声音')));// 转换二进制$msg = chr(0) . pack('n', 32) . pack('H*', '设备标识(Apple SDK可以获取)') . pack('n', strlen($payload)) . $payload;// 发送消息$result = fwrite($fp, $msg, strlen($msg));if(!$result)&#123; // 推送失败&#125;else&#123; // 推送成功&#125;fclose($fp); 3.APNS文档 https://developer.apple.com/notifications/","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"apns","slug":"apns","permalink":"http://xupin.im/tags/apns/"}]},{"title":"Nginx + PHP7 + Mysql(MariaDB) + Memcached + Redis的环境搭建(可选)","date":"2017-02-22T07:30:00.000Z","path":"2017/02/22/php7/","text":"PHP is a popular general-purpose scripting language that is especially suited to web development. Fast, flexible and pragmatic, PHP powers everything from your blog to the most popular websites in the world. 1.更新yum源,安装扩展包123$ yum update$ yum install epel-release$ yum install git 2.添加Nginx源1$ vi /etc/yum.repos.d/nginx.repo [nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1 3.安装开发库(可选)1$ yum install ntp make openssl openssl-devel pcre pcre-devel libpng libpng-devel libjpeg-6b libjpeg-devel-6b freetype freetype-devel gd gd-devel zlib zlib-devel gcc gcc-c++ libXpm libXpm-devel ncurses ncurses-devel libmcrypt libmcrypt-devel libxml2 libxml2-devel imake autoconf automake screen sysstat compat-libstdc++-33 curl curl-devel 4.安装Nginx123$ yum install nginx$ chkconfig --levels 235 nginx on // 设2、3、5级别开机启动$ service nginx start 5.安装Mysql(MariaDB)123$ yum install mariadb mariadb-server mariadb-devel$ chkconfig --levels 235 mariadb on$ service mariadb start 6.安装PHP-FPM1234$ rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm$ yum install php70w lighttpd-fastcgi php70w-cli php70w-gd php70w-imap php70w-ldap php70w-odbc php70w-pear php70w-xml php70w-xmlrpc php70w-mbstring php70w-mcrypt php70w-mssql php70w-snmp php70w-soap php70w-tidy php70w-common php70w-devel php70w-fpm php70w-mysql // 安装php和所需组件使PHP支持MySQL、FastCGI模式$ chkconfig --levels 235 php-fpm on$ service php-fpm start 7.安装Memcached(可选)123456789101112131415$ yum install –enablerepo=rpmforge memcached libevent libevent-devel$ wget https://launchpad.net/libmemcached/1.0/1.0.18/+download/libmemcached-1.0.18.tar.gz$ tar -zxf libmemcached-1.0.18.tar.gz$ cd libmemcached-1.0.18/$ ./configure$ make &amp;&amp; make install$ git clone https://github.com/php-memcached-dev/php-memcached.git$ cd php-memcached/$ git checkout php7$ phpize$ ./configure --disable-memcached-sasl$ make &amp;&amp; make install$ chkconfig --level 2345 memcached on$ service memcached start$ vim /etc/php.ini // 末行增加 [Memcached]extension=memcached.so 8.安装Redis(可选)12345678910$ yum install redis$ git clone https://github.com/phpredis/phpredis.git$ cd phpredis$ git checkout php7$ phpize$ ./configure$ make &amp;&amp; make install$ chkconfig --level 2345 redis on$ service redis start$ vim /etc/php.ini // 末行增加 [Redis]extension=redis.so 9.重启PHP-FPM1$ service php-fpm restart 完成","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"php","slug":"php","permalink":"http://xupin.im/tags/php/"}]}]