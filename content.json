[{"title":"Mysql学习笔记 - cursor","date":"2021-11-17T16:00:00.000Z","path":"2021/11/18/mysql-cursor/","text":"游标（cursor）是可以从数据库检索结果集中每次提取一行记录的机制，游标的作用就是对数据库检索结果集进行遍历，方便对记录进行操作。 特性三种特性： 只读 不能更新它 非滚动 根据SQL语句确定顺序，不能向后获取记录和跳过记录 敏感/不敏感 敏感游标指向的是数据表，不敏感游标指向的则是临时数据表。（Mysql使用的是敏感游标） 声明游标游标使用的变量必须在声明游标之前声明 123456789101112131415161718// Mysql// 不同于其他数据库，Mysql的游标必须声明在存储过程/函数中。create procedure cur_func()begin declare &#123;...VARs&#125; // e.g. declare email varchar(50) declare &#123;CUR_NAME&#125; cursor for &#123;STATEMENT&#125;; open &#123;CUR_NAME&#125;; fetch &#123;CUR_NAME&#125; into &#123;...VARs&#125; // e.g. fetch cur1 into email,name // 取出1行记录 &amp; 把值赋给变量email、name close &#123;CUR_NAME&#125;;end;// PgSqlbegin declare &#123;CUR_NAME&#125; cursor for &#123;STATEMENT&#125;; open &#123;CUR_NAME&#125;; fetch &#123;STATEMENT&#125; from &#123;CUR_NAME&#125; // e.g. fetch forward 10 from cur1 取出10行记录 close &#123;CUR_NAME&#125;;end; 原理游标有着类似指针的作用，它是遍历容器的一套接口（迭代器），简单实现（golang）: 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport \"fmt\"type CustomArray []interface&#123;&#125;type Iterator struct &#123; data CustomArray index int&#125;func main() &#123; cusArr := CustomArray&#123;\"1_1\", 22, 3.3&#125; for iter := cusArr.iterator(); iter.hasNext(); &#123; fmt.Println(iter.key(), iter.next()) &#125;&#125;// 迭代器func (arr CustomArray) iterator() *Iterator &#123; return &amp;Iterator&#123; data: arr, index: 0, &#125;&#125;// 游标func (iter *Iterator) key() int &#123; return iter.index&#125;// 下一个元素是否存在func (iter *Iterator) hasNext() bool &#123; return iter.index &lt; len(iter.data)&#125;// 取出数据&amp;移动游标func (iter *Iterator) next() interface&#123;&#125; &#123; val := iter.data[iter.index] iter.index += 1 return val&#125; 简单的说：游标返回一个数据集合迭代器，当你取一行记录同时游标指向下一个元素。 举例使用游标的DB库，以下：https://github.com/PyMySQL/PyMySQL/blob/46d17402af/pymysql/cursors.py#L278https://github.com/golang/go/blob/master/src/database/sql/sql.go#L2983","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"mysql","slug":"mysql","permalink":"http://xupin.im/tags/mysql/"}]},{"title":"Mysql学习笔记 - InnoDB并发死锁问题","date":"2021-11-14T16:00:00.000Z","path":"2021/11/15/mysql-deadlock/","text":"项目中某个定时任务执行过程中出现死锁问题，具体错误如下:1Error 1213: Deadlock found when trying to get lock; try restarting transaction 分析检查一下表引擎 &amp; 事务隔离级别123456789101112131415161718192021mysql&gt; show variables like '%storage_engine%';+---------------------------------+-----------+| Variable_name | Value |+---------------------------------+-----------+| default_storage_engine | InnoDB || default_tmp_storage_engine | InnoDB || disabled_storage_engines | || internal_tmp_mem_storage_engine | TempTable |+---------------------------------+-----------+4 rows in set (0.00 sec)mysql&gt; select @@global.tx_isolation;ERROR 1193 (HY000): Unknown system variable 'tx_isolation' // Mysql8.0以后取消了该变量mysql&gt; select @@transaction_isolation;+-------------------------+| @@transaction_isolation |+-------------------------+| REPEATABLE-READ |+-------------------------+1 row in set (0.00 sec) 默认使用的引擎是InnoDB，Insert、Update、Delete操作会触发排它锁（X锁）即行锁，所以怀疑是不是触发了共享锁（S锁）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120mysql&gt; show engine innodb status;=====================================2021-11-15 02:42:28 0x2b1f5b160700 INNODB MONITOR OUTPUT=====================================Per second averages calculated from the last 59 seconds...------------------------LATEST DETECTED DEADLOCK------------------------2021-11-12 14:21:02 0x2b204ca06700*** (1) TRANSACTION:TRANSACTION 3805455, ACTIVE 0 sec insertingmysql tables in use 1, locked 1LOCK WAIT 4 lock struct(s), heap size 1136, 3 row lock(s), undo log entries 1MySQL thread id 875327, OS thread handle 47411963238144, query id 20765167 10.85.62.212 dsc updateINSERT INTO `user_tag_distributes` (`created_at`,`updated_at`,`deleted_at`,`app_id`,`tag_name`,`tag_value`,`account_num`) VALUES ('2021-11-12 14:21:02.386','2021-11-12 14:21:02.386',NULL,'im','churn_model_v2','0.70709264',1)*** (1) HOLDS THE LOCK(S):RECORD LOCKS space id 334 page no 341 n bits 160 index PRIMARY of table `api`.`user_tag_distributes` trx id 3805455 lock_mode X locks rec but not gapRecord lock, heap no 89 PHYSICAL RECORD: n_fields 11; compact format; info bits 0 0: len 8; hex 000000000002515d; asc Q];; 1: len 6; hex 0000003a110f; asc : ;; 2: len 7; hex 81000001960110; asc ;; 3: len 7; hex 99ab18e5420f14; asc B ;; 4: len 7; hex 99ab18e5420f14; asc B ;; 5: SQL NULL; 6: SQL NULL; 7: len 2; hex 696d; asc im;; 8: len 14; hex 636875726e5f6d6f64656c5f7632; asc churn_model_v2;; 9: len 10; hex 302e3730373039323634; asc 0.70709264;; 10: len 3; hex 800001; asc ;;*** (1) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 334 page no 203 n bits 392 index tag of table `api`.`user_tag_distributes` trx id 3805455 lock mode S waitingRecord lock, heap no 88 PHYSICAL RECORD: n_fields 3; compact format; info bits 32 0: len 14; hex 636875726e5f6d6f64656c5f7632; asc churn_model_v2;; 1: len 9; hex 302e37303730393735; asc 0.7070975;; 2: len 8; hex 0000000000022d5f; asc -_;;*** (2) TRANSACTION:TRANSACTION 3805441, ACTIVE 0 sec fetching rowsmysql tables in use 1, locked 1LOCK WAIT 89 lock struct(s), heap size 24784, 17767 row lock(s), undo log entries 10247MySQL thread id 875354, OS thread handle 47415383693056, query id 20765093 10.85.62.212 dsc updatingDELETE FROM `user_tag_distributes` WHERE app_id = 'im' and tag_name = 'churn_model_v2'*** (2) HOLDS THE LOCK(S):RECORD LOCKS space id 334 page no 203 n bits 392 index tag of table `api`.`user_tag_distributes` trx id 3805441 lock_mode X locks rec but not gapRecord lock, heap no 88 PHYSICAL RECORD: n_fields 3; compact format; info bits 32 0: len 14; hex 636875726e5f6d6f64656c5f7632; asc churn_model_v2;; 1: len 9; hex 302e37303730393735; asc 0.7070975;; 2: len 8; hex 0000000000022d5f; asc -_;;*** (2) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 334 page no 341 n bits 160 index PRIMARY of table `api`.`user_tag_distributes` trx id 3805441 lock_mode X waitingRecord lock, heap no 89 PHYSICAL RECORD: n_fields 11; compact format; info bits 0 0: len 8; hex 000000000002515d; asc Q];; 1: len 6; hex 0000003a110f; asc : ;; 2: len 7; hex 81000001960110; asc ;; 3: len 7; hex 99ab18e5420f14; asc B ;; 4: len 7; hex 99ab18e5420f14; asc B ;; 5: SQL NULL; 6: SQL NULL; 7: len 2; hex 696d; asc im;; 8: len 14; hex 636875726e5f6d6f64656c5f7632; asc churn_model_v2;; 9: len 10; hex 302e3730373039323634; asc 0.70709264;; 10: len 3; hex 800001; asc ;;*** WE ROLL BACK TRANSACTION (1)------------TRANSACTIONS------------Trx id counter 3945122Purge done for trx's n:o &lt; 3945122 undo n:o &lt; 0 state: running but idleHistory list length 3LIST OF TRANSACTIONS FOR EACH SESSION:---TRANSACTION 328886640459544, not started0 lock struct(s), heap size 1136, 0 row lock(s)---TRANSACTION 328886640456152, not started0 lock struct(s), heap size 1136, 0 row lock(s)---TRANSACTION 328886640455304, not started0 lock struct(s), heap size 1136, 0 row lock(s)---TRANSACTION 328886640457000, not started0 lock struct(s), heap size 1136, 0 row lock(s)---TRANSACTION 328886640448520, not started0 lock struct(s), heap size 1136, 0 row lock(s)---TRANSACTION 328886640447672, not started0 lock struct(s), heap size 1136, 0 row lock(s)---TRANSACTION 328886640452760, not started0 lock struct(s), heap size 1136, 0 row lock(s)---TRANSACTION 328886640458696, not started0 lock struct(s), heap size 1136, 0 row lock(s)---TRANSACTION 328886640446824, not started0 lock struct(s), heap size 1136, 0 row lock(s)---TRANSACTION 328886640453608, not started0 lock struct(s), heap size 1136, 0 row lock(s)---TRANSACTION 328886640457848, not started0 lock struct(s), heap size 1136, 0 row lock(s)---TRANSACTION 328886640451912, not started0 lock struct(s), heap size 1136, 0 row lock(s)---TRANSACTION 328886640451064, not started0 lock struct(s), heap size 1136, 0 row lock(s)---TRANSACTION 328886640454456, not started0 lock struct(s), heap size 1136, 0 row lock(s)---TRANSACTION 328886640450216, not started0 lock struct(s), heap size 1136, 0 row lock(s)---TRANSACTION 328886640449368, not started0 lock struct(s), heap size 1136, 0 row lock(s)---TRANSACTION 328886640445976, not started0 lock struct(s), heap size 1136, 0 row lock(s)---TRANSACTION 328886640445128, not started0 lock struct(s), heap size 1136, 0 row lock(s)...----------------------------END OF INNODB MONITOR OUTPUT============================ 通过以上信息确认是因为[事务1]Insert &amp; [事务2]Delete互相等待对方事务释放锁的问题造成死锁，最后[事务1]进行回滚。 原因review代码梳理一下业务逻辑，场景应该如下： trx1 trx2 BEGIN BEGIN DELETE FROM user_tag_distributes WHERE app_id = ‘im’ and tag_name = ‘churn_model_v2’ DELETE FROM user_tag_distributes WHERE app_id = ‘im’ and tag_name = ‘churn_model_v2’ INSERT INTO user_tag_distributes (created_at,updated_at,deleted_at,app_id,tag_name,tag_value,account_num) VALUES (‘2021-11-12 14:21:02.386’,’2021-11-12 14:21:02.386’,NULL,’im’,’churn_model_v2’,’0.70709264’,1) ERROR 1213 (40001): Deadlock found when trying to get lock ROLLBACK … COMMIT 可以看出[事务1]进行Insert操作时发现[事务2]进行Delete操作且已申请X锁，[事务1]想要获取S锁则需要[事务2]提交，所以[事务1]、[事务2]在相互等待对方提交事务（释放锁）。 解决方案目前想到的几种措施： 尽量避免在并发程序中Delete &amp; Insert操作无缝执行 并发程序采用分布式锁控制 程序不允许并发执行 https://dev.mysql.com/doc/refman/8.0/en/mysql-nutshell.htmlhttps://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"mysql","slug":"mysql","permalink":"http://xupin.im/tags/mysql/"}]},{"title":"Mysql学习笔记 - 数据迁移","date":"2021-11-11T16:00:00.000Z","path":"2021/11/12/mysql-migrate/","text":"之前项目数据表有分表设计，现在因为业务量增长数据表数据量膨胀数倍导致单表性能不理想 … 所以希望在不影响用户使用的情况下扩展数据表（迁移） 数据迁移方案基本分为热迁移和冷迁移两种方式 冷迁移 通俗的来说就是停机迁移，比如某些游戏合服维护等 优点: 操作可靠性高、数据一致性有保证、数据回滚方便 缺点: 用户体验差 热迁移 在不停机的情况下把数据表迁移，新旧表双写 优点: 用户无感知 缺点: 容易丢失数据、数据一致性不好保证 这种热迁移方式是不依赖第三方服务，纯靠DB完成迁移，极端场景下可靠性不确定。","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"mysql","slug":"mysql","permalink":"http://xupin.im/tags/mysql/"}]},{"title":"Git小知识 - depth","date":"2021-10-31T16:00:00.000Z","path":"2021/11/01/git-depth/","text":"有时候git项目比较大，git clone会因为各种原因中断，但是Git并不会断点续“传”再次clone又是重新来过,类似这种问题…让人很是苦恼123$ error: RPC failed; HTTP 504 curl 22 The requested URL returned error: 504 Gateway Time-out$ ...$ error: RPC failed; curl 18 transfer closed with outstanding read data remaining 解决方式 git配置流 1234$ git config --global http.lowSpeedLimit 0 // 最小速度$ git config --global http.lowSpeedTime 999999 // 最大速度$ git config --global http.postBuffer 524288000 // 文件大小$ git config --global compression 0 // 关闭压缩 分块拉取 1$ git clone --depth=1 &#123;repo&#125; // 拉取最新的代码（最后一次commit） 但这样会带来其他的小问题，就是拉下来的代码默认分支既不是master也不是其他分支 … 需要拉取完整的项目123$ git fetch --unshallow // 拉取深层代码$ git config remote.origin.fetch \"+refs/heads/*:refs/remotes/origin/*\" // 修正remote关系（修改之前: \"fetch = +refs/heads/master:refs/remotes/origin/master\"）$ git fetch -pv // 拉取所有分支","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"git","slug":"git","permalink":"http://xupin.im/tags/git/"}]},{"title":"设计模式 - 控制反转/依赖注入","date":"2020-10-17T16:00:00.000Z","path":"2020/10/18/design-ioc-di/","text":"Laravel框架中控制反转和依赖注入功能是怎么实现的？其实控制反转和依赖注入是一种设计思想，它最早源于Java Spring框架设计中的机制，所以身边如果有做Java开发的小伙伴~简单聊聊就能明白许多。 1.依赖注入依赖注入（Dependency Injection），通俗的解释是当我们构建对象时需要的参数，只要不是手动创建而是以实例对象的形式注入都可以称为依赖注入。 举个例子，一个小游戏中玩家可以创建不同的职业。 1234567891011121314151617181920212223242526272829303132333435363738394041// 职业接口interface Role &#123; // 获取职业名 public function getName();&#125;class Dh implements Role &#123; // 职业名 protected $name = '猎魔人'; // 攻击成长 protected $attack; // 速度成长 protected $speed; // 气血成长 protected $hp; public function __construct($attack,$speed,$hp) &#123; $this-&gt;attack = $attack; $this-&gt;speed = $speed; $this-&gt;hp = $hp; &#125; public function getName() &#123; return $this-&gt;name; &#125;&#125;// 玩家类class Player &#123; // 职业 protected $role; public function __construct($role) &#123; $this-&gt;role = $role; &#125;&#125;// 猎魔人$dh = new Dh(100, 100, 60);// 玩家1-&gt;猎魔人$player1 = new Player($dh); 以上是创建玩家角色的逻辑，创建角色“player1”时选择角色“dh”，那么这种方式其实就是依赖注入。 2.控制反转（Ioc）控制反转（Inversion of Control），从字面意思来理解就是把控制权反转，那么究竟怎么反转呢？ 之前创建玩家角色的逻辑，通过程序可以看出所有依赖对象都是程序主动去创建（职业对象，玩家对象）。那么如果我们想把所有需要的参数都提前准备好，怎么优化？ 123456789101112131415161718192021222324252627282930313233343536373839class Container&#123; protected $binds; protected $instances; public function bind($abstract, $concrete) &#123; if ($concrete instanceof Closure) &#123; $this-&gt;binds[$abstract] = $concrete; &#125; else &#123; $this-&gt;instances[$abstract] = $concrete; &#125; &#125; public function make($abstract, $parameters = []) &#123; if (isset($this-&gt;instances[$abstract])) &#123; return $this-&gt;instances[$abstract]; &#125; array_unshift($parameters, $this); return call_user_func_array($this-&gt;binds[$abstract], $parameters); &#125;&#125;$container = new Container();$container-&gt;bind('player', function($container, $role) &#123; return new Player($container-&gt;make($role));&#125;);$container-&gt;bind('dh', function($container) &#123; return new Dh(100, 100, 60);&#125;);// 玩家1-&gt;猎魔人$player1 = $container-&gt;make('player', ['dh']); 加入了一个名叫“Container”的类，里面存放提前设计好的对象，当程序需要某些依赖对象时“Container”自动帮你去寻找执行。这其实就是Ioc设计思想中遵循“Don’t call us, we’ll call you”的原则，不需要程序去创建依赖，而是主动去帮程序寻找相应依赖。这也就是所说的控制反转，从狭义上讲依赖注入其实算是控制反转的一种实现。 最后可能很多小伙伴会觉得控制反转的思想和工厂模式很相像，它们是不是就是同一个东西呢？有兴趣的小伙伴可以去看看Dependency Injection vs Factory Pattern。","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"design","slug":"design","permalink":"http://xupin.im/tags/design/"}]},{"title":"Mysql学习笔记 - 聚簇索引和回表查询的关系","date":"2020-08-11T16:00:00.000Z","path":"2020/08/12/mysql-clustered-index/","text":"之前简单了解过Mysql的索引，今天来学习一下Mysql（InnoDB）的聚簇索引以及SQL为什么会产生回表查询？ 1. 什么是回表查询？都知道Mysql存储的数据结构是B+Tree，所以当查询数据的时候能最快找到叶子节点的检索方式时是最快的。比如：主键直接定位行记录，而有些查询需要先检索索引树找到叶子节点的主键值，再通过主键值定位行记录这种扫描2次索引树的方式就叫做回表查询。 如何确定SQL语句会不会造成回表查询？如下表：12345678910CREATE TABLE `users` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user` varchar(125) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL, `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL, `status` tinyint(4) NOT NULL, `created_at` datetime NOT NULL, PRIMARY KEY (`id`) USING BTREE, UNIQUE INDEX `user`(`user`) USING BTREE, INDEX `name`(`name`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Compact; 2种查询方式： 123456789101112131415# 未回表查询EXPLAIN SELECT id,name FROM users WHERE name = 'test1';+------+-------------+-------+------+---------------+------+---------+-------+------+--------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+------+-------------+-------+------+---------------+------+---------+-------+------+--------------------------+| 1 | SIMPLE | users | ref | name | name | 202 | const | 1 | Using where; Using index |+------+-------------+-------+------+---------------+------+---------+-------+------+--------------------------+# 回表查询EXPLAIN SELECT id,user,name FROM users WHERE name = 'test1';+------+-------------+-------+------+---------------+------+---------+-------+------+-----------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+------+-------------+-------+------+---------------+------+---------+-------+------+-----------------------+| 1 | SIMPLE | users | ref | name | name | 202 | const | 1 | Using index condition |+------+-------------+-------+------+---------------+------+---------+-------+------+-----------------------+ 注意看Extra字段，当值为Using index condition时表示该SQL需要回表查询，那以上两条SQL到底有什么不同呢？ SQL1命中name索引并且在索引树的叶子节点找到主键id，满足了查询需求所以不需要回表查询其他字段。 SQL2同样是命中name索引并且在索引树叶子节点找到主键id，但还有一个user字段没有得到，所以需要拿着主键id去索引树查询user字段。 以上就是是否回表查询的区别，回表查询会额外产生一次查询的开销，故此效率较低。不过回表查询和聚簇索引又有什么关联呢？为什么回表查询需要遍历2次索引树呢？ 2. 聚簇索引InnoDB的索引类型之前有说过，多数使用B+Tree做索引但在实现上又区分为：聚簇索引和辅助索引。 聚簇索引（Clustered Index） 聚簇索引的叶子节点存储行记录，InnoDB有且只有一个聚簇索引。聚簇索引的每一个叶子节点都有一个指向相邻叶子节点的指针，所以面对Range查询聚簇索引效率很高。 1InnoDB默认主键是聚簇索引，如果没有定义主键则第一个Not Null &amp; Unique索引列为聚簇索引。如果以上条件都不满足，则会生成一个6字节的隐式自增长主键`row-id`。 （这也是为什么InnoDB引擎下要求数据表尽可能都要创建主键的原因。） 辅助索引（Secondary Index） 辅助索引的叶子节点存储主键值（聚簇索引）。 了解了索引树的结构，其实也就明白了为什么明明命中了索引却还会产生回表查询需要扫描2次索引树，即：先扫描辅助索引树拿到主键值，再扫描聚簇索引树获取行记录。 3. 如何避免回表查询？避免回表查询这里有个概念：覆盖索引（Covering index），Mysql官方虽然没有明确定义覆盖索引但是有同样的概念出现。 查询的字段尽可能在一棵索引树都能获取到，避免回表。 （概念出处：Using index） 具体怎么操作呢？直接上SQL。12ALTER TABLE `users` DROP INDEX `name`;ALTER TABLE `users` ADD INDEX `user_name` ( `user`, `name` ); 创建user、name复合索引，这样就能够覆盖索引不需要回表。 最后埋个坑，后面有时间会继续学习相比辅助索引聚簇索引平均会减少多少次IO操作。","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"mysql","slug":"mysql","permalink":"http://xupin.im/tags/mysql/"}]},{"title":"Redis学习笔记 - Key事件通知","date":"2020-08-09T16:00:00.000Z","path":"2020/08/10/redis-keyspace-notify/","text":"网上购物看到自己喜欢的东西加入购物车然后付款，但是在付款的突然不想要了 … 往往这个订单会给一个30分钟的支付时间，时间一到就自动关闭了 所以这是怎么做到的呢？ 1.实现方式 轮询 1脚本每隔一定时间就去数据表检查一下状态，是否过期需要关闭。 定时器 1创建订单时开始计时，计时结束后直接处理关闭订单。 数据库事件+存储过程 1数据库建立检查事件，每隔一定时间去执行一次存储过程。 Key事件通知 1对于更改任何Redis Key的每个操作，都可以配置Redis将消息发布到Pub/Sub，然后订阅这些通知。 2.数据库事件+存储过程不多说，直接上SQL 订单表 1234567CREATE TABLE `orders` ( `id` int(11) NOT NULL AUTO_INCREMENT, `good_id` int(11) NOT NULL, `status` tinyint(1) NOT NULL COMMENT '0:待付款，1:已付款，-1:订单关闭', `created_at` datetime NOT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Compact; 创建存储过程，处理关闭订单。 1234CREATE PROCEDURE job_proce()BEGIN update orders set status = -1 where time_to_sec(timediff(now(), created_at)) &gt; 1800 and status = 0;END 创建事件，调用存储过程。 123456SET GLOBAL event_scheduler = 1; CREATE EVENT IF NOT EXISTS job_eventON SCHEDULE EVERY 1 SECOND # 1秒检查一次ON COMPLETION PRESERVE DO CALL job_proce(); 开启事件。 1ALTER EVENT job_event ON COMPLETION PRESERVE ENABLE; 这样job_event事件就会以1秒/次的频率去执行job_proce存储过程执行数据检查。 3. Key事件通知Key事件通知（Redis Keyspace Notifications）机制自2.8版本以后出现，该机制默认是关闭的。可通过配置redis.conf进行开启1234567891011121314notify-keyspace-events Ex # E表示Key事件通知，x代表Key过期行为。# notify-keyspace-events可配置参数# K 键空间事件，以__keyspace@&lt;db&gt;__前缀发布。# E 键事件事件，以__keyevent@&lt;db&gt;__前缀发布。# g 通用命令（非类型特定），如DEL，EXPIRE，RENAME等等# $ 字符串命令# l 列表命令# s 集合命令# h 哈希命令# z 有序集合命令# x 过期事件（每次键到期时生成的事件）# e 被驱逐的事件（当一个键由于达到最大内存而被驱逐时产生的事件）# A g$lshzxe的别名，因此字符串AKE表示所有的事件。 修改配置开启Key事件通知以后，当Redis在删除过期Key的时候会向指定channel（过期行为的channel：__keyevent@0__:expired） publish消息，该消息可以使用subscribe/psubscribe进行订阅。12345127.0.0.1:6379&gt; PSUBSCRIBE __keyevent@0__:expiredReading messages... (press Ctrl-C to quit)1) \"psubscribe\"2) \"__keyevent@0__:expired\"3) (integer) 1 所以我们只需要写个程序执行redis-&gt;psubscribe()进行监听即可。 最后emmmm…","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"redis","slug":"redis","permalink":"http://xupin.im/tags/redis/"}]},{"title":"Git小知识 - Clone项目速度慢的小技巧","date":"2020-07-04T16:00:00.000Z","path":"2020/07/05/git-cloning-slow/","text":"碰上github网络抽风的时候，恰巧你又需要拉取github上托管的项目，这个时候看着2kb/s的下载速度是不是很抓狂？ 粗暴的解决方式打开ipaddress查询以下三个域名的ip，写到hosts文件中。 github.com github.global.ssl.fastly.net codeload.github.com 进阶的方式 挂代理，哦豁export ALL_PROXY=socks5://127.0.0.1:4000 究极方式 复制你要拉取的项目github地址，比如：https://github.com/v2ray/v2ray-core 打开码云，创建仓库-&gt;从 GitHub / GitLab 导入仓库 搞定！git clone https://gitee.com/xupinbest/v2ray-core","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"github","slug":"github","permalink":"http://xupin.im/tags/github/"}]},{"title":"Go学习笔记 - goroutine","date":"2020-06-11T16:00:00.000Z","path":"2020/06/12/goroutine/","text":"在现在大数据、高并发，到处都充斥着流量的互联网时代，能不能应对高并发俨然已经发展成一个衡量服务端架构是否合格的标准，作为程序媛我们思考如何利用语言在代码层面最优设计能应对并发的程序去并行处理任务。在程序中对于任务并行处理一般趋于使用：进程、线程，以及另外一种：协程。支持协程的语言有很多，比如：C/C++、Ruby、 Python（2.5+）、Golang等等，它们有些是本身语言支持协程，有些则是需要引入第三方包来使用。不过，我们主要来学习一下Golang这门语言（简称Go），它是如何理解以及实现协程的。 一、进程、线程和协程的前世今生都知道一台计算机的核心是CPU，它承担着所有的运算。而计算机承载的操作系统（内核）则是负责所有任务的处理和调度CPU以及资源的分配。如果用人类来比喻，大脑是CPU，思维则是操作系统（内核）。 进程最早的计算机每次只能运行一个程序，如果还有其他程序需要执行则要排队等待。后来CPU运算能力提高了，这种方式过于原始有些浪费性能，于是尝试让多个程序可以并行执行，但是这样面临一个新的问题：跑在同一个CPU中的程序都会使用计算机资源，那程序的运行状态和数据怎么保障？进程。1进程是内核资源管理分配的最小单位，每个进程都有独立的虚拟地址空间。内核中的每个程序都运行在独立进程的上下文中，上下文是由程序正常运行需要的一系列参数组成，参数包括存储器中的代码和数据，寄存器中的内容以及进程打开的文件描述符（文件句柄）等。可以把上下文通俗理解为：`环境`。 如果程序在运行过程中需要进行IO操作，IO操作阻塞了程序后面的计算，这时候CPU属于空闲状态，那内核会把CPU切换到其他进程去处理。不过当进程数量变高以后，计算机的大部分资源都被进程切换这个操作消耗掉了。为什么说进程切换操作消耗资源代价比较高？1所谓进程切换其实就是上下文切换，需要切换新的页表并加载新的虚拟地址空间、切换内核栈以及硬件上下文等。只要发生进程切换操作就得反复进入内核，加载切换一系列状态。 线程为了减少这种开销，线程应运而生。1线程是内核调度CPU执行的最小单位，线程是运行在进程上下文的逻辑流，线程是具体执行程序的单位。一个进程至少包含一个主线程（可以拥有多个子线程），但是一个线程只能存在于一个进程中。 线程切换相比进程切换开销就小了很多，线程切换只需要把寄存器刷新即可。 协程后面程序媛们发现线程这样还是有性能瓶颈（IO阻塞），无论是进程还是线程因为涉及到大量的计算机资源，所以都是由内核调度管理。能不能开发一种由代码控制的线程呢？这就是协程。 1协程是由用户控制的线程（用户态线程），协程在程序中实现自我调度，不需要像进程切换一样进入内核加载切换状态，提高了线程在IO上的性能问题（IO多路复用）。 但是协程也有个致命的问题，假如进程中的某一程序出现了阻塞操作同时被CPU中断处理（抢占式调度），那么该进程中的所有线程都会被阻塞。 后面会专门写一篇关于进程和线程以及协程的特性以及区别。（不够详细，埋坑Orz~） 二、什么是goroutine？上面简单学习了进程和线程以及协程的渊源，虽然不够详细但是我们大概知道其实在进程或者线程甚至于协程存在的性能瓶颈大部分是CPU调度问题。 1go func() // Go语言启动协程，只需要使用go关键字即可启动协程运行函数。使用go关键字创建的这个协程就叫做`goroutine` 之前说了goroutine是Go语言的协程，其实这么理解是可以的但goroutine比协程更强大。它们使用的线程模型有着本质的区别，如下： goroutine通过通道来通信，而协程通过让出执行和恢复操作来通信。 goroutine通过Go语言的调度器进行调度，而协程通过程序本身调度。 大部分语言或者第三方库提供的协程就是使用的用户态线程模型，但goroutine使用的不是传统的用户态线程模型。以下主流的线程模型： 内核级线程模型 内核级别的线程的状态切换需要内核直接处理，所以内核清楚的知道每一个KSE（Kernel Scheduling Entity）的存在（即内核线程和KSE是一对一关系），它们可以全系统内进行资源的竞争。 用户级线程模型（用户态线程，协程） 用户态级别的线程受用户控制，内核并不直接知道用户态线程的存在（为什么这么说？因为用户态线程和内核线程存在着多对一的关系，即多个用户态线程对应一个内核线程），一般用户态多线程属于同一个进程，所以它们只能在进程内进行资源竞争。 两级线程模型（混合型线程模型） 两级线程模型吸取了内核级和用户级线程的经验，两级线程模型下的线程和内核线程处于多对多的关系。一个进程内的多个线程可以分别绑定内核线程，既可以多个线程绑定多个内核线程也可以多个线程绑定一个内核线程，当某个线程内的程序产生阻塞其绑定的内核线程被CPU中断处理，进程内的其他线程可以重新与其他内核线程绑定。 goroutine使用的正是两级线程模型，但是这种多个线程跑在多个内核中，既不是用户级线程模型完全靠自身调度也不是内核级线程模型完全依赖内核调度，而是用户和内核协同调度。因为这种模型复杂性较高，所以Go语言开发了自己的runtime调度器。 三、Go runtime调度器Go runtime调度器的结构由三部分组成: G Goroutine，每个goroutine有对应的G结构体，G结构体储存goroutine的上下文信息。G并不能直接被调度，需要绑定对应的P才能被调度执行。 P Processor，为G和M进行调度的逻辑处理器，对于G来说P像是内核，而在M看来P相当于上下文。P的数量可以在程序中代码控制，如下: 1runtime.GOMAXPROCS(runtime.NumCPU()) // 该值最大为256。 M Machine，负责调度任务（可以理解为内核线程的抽象），代表着操作系统内核，是真正处理任务的服务。M的数量不是固定的，受Go runtime调度器控制。（不过该值最大为10000，可以参考：src/runtime/proc.go） 值得一提的是Go语言在最初的版本中Go runtime调度器的结构是GM模型（并非GMP模型），P服务是因为GM模型在并发上出现很大的性能损耗。有兴趣的小伙伴可以看一下Go runtime的核心开发者Dmitry Vyukov发现的问题Scalable Go Scheduler Design Doc。 简单说了一下Go runtime调度器中的GPM模型的概念，那么GPM究竟是怎么调度的呢？首先当通过go func()创建一个G对象的时候，G会被优先放入P的本地队列。为了执行G M需要绑定一个P，然后M启动内核线程并循环从P的本地队列取出G并执行。 当P发现当前绑定的M被阻塞时会转入绑定其他M（新的M可能是被创建或者从内核线程缓存中取出）。 如果M处理完了当前P的本地队列里的G后，P会尝试从全局队列里取G来执行（同样P也会周期性的检查全局队列是否有G可以执行）。如果全局队列没有可以执行的G，P会随机挑选另外一个P并从它的本地队列中取出一半G到自己的本地队列中执行。这个动作使用调度算法work-stealing（工作窃取算法）实现。 最后以上就是Go runtime调度器的运行原理（大概），后面有更深入的理解会补充进来。","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"goroutine","slug":"goroutine","permalink":"http://xupin.im/tags/goroutine/"}]},{"title":"Mysql小知识 - 查找连续编号中的缺失编号","date":"2020-04-12T16:00:00.000Z","path":"2020/04/13/mysql-trick/","text":"在和小伙伴讨论问题的时候，小伙伴突然问了我这样一个小问题，数据库中如何查找连续编号中的缺失编号？ 1.描述场景大概是这样，有一份连续数据ID：1 … 27，其中ID：6，7，14的数据丢了。结构如下：1234567891011121314151617181920212223242526272829303132CREATE TABLE `letter` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 27 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Compact;INSERT INTO `letter` VALUES (1, 'A');INSERT INTO `letter` VALUES (2, 'B');INSERT INTO `letter` VALUES (3, 'C');INSERT INTO `letter` VALUES (4, 'D');INSERT INTO `letter` VALUES (5, 'E');# INSERT INTO `letter` VALUES (6, 'F');# INSERT INTO `letter` VALUES (7, 'J');INSERT INTO `letter` VALUES (8, 'H');INSERT INTO `letter` VALUES (9, 'I');INSERT INTO `letter` VALUES (10, 'J');INSERT INTO `letter` VALUES (11, 'K');INSERT INTO `letter` VALUES (12, 'L');INSERT INTO `letter` VALUES (13, 'M');# INSERT INTO `letter` VALUES (14, 'N');INSERT INTO `letter` VALUES (15, 'O');INSERT INTO `letter` VALUES (16, 'P');INSERT INTO `letter` VALUES (17, 'Q');INSERT INTO `letter` VALUES (18, 'R');INSERT INTO `letter` VALUES (19, 'S');INSERT INTO `letter` VALUES (20, 'T');INSERT INTO `letter` VALUES (21, 'U');INSERT INTO `letter` VALUES (22, 'V');INSERT INTO `letter` VALUES (23, 'W');INSERT INTO `letter` VALUES (24, 'X');INSERT INTO `letter` VALUES (25, 'Y');INSERT INTO `letter` VALUES (26, 'Z'); 怎么把6，7，14这三条数据找出来？方法有很多种哈，今天我们说一下如何利用SQL快速查询出来。大概思路是把ID+1，然后查询ID+1这个值是否存在ID列表中，如果不存在那肯定就是缺失的。SQL如下：123456SELECT id + 1 AS id FROM `letter` WHERE id + 1 NOT IN ( SELECT id FROM `letter` ) 但是这样会有一个小问题，就是MAX(id)+1（27）也会被查询出来，所以：123456789101112SELECT id + 1 AS id FROM `letter` WHERE id + 1 NOT IN ( SELECT id FROM `letter` ) AND id &lt;( SELECT max( id ) FROM `letter` ) 2.优化1234567891011121314151617181920SELECT start_id, ( SELECT MIN(id)- 1 FROM `letter` WHERE id &gt; start_id ) AS end_id FROM ( SELECT id + 1 AS start_id FROM `letter` WHERE id + 1 NOT IN ( SELECT id FROM `letter` ) AND id &lt;( SELECT max(id) FROM `letter` ) ) AS max_id ORDER BY start_id 这种情况适用于查找整数类型的连续编号，那么如果编号是string类型的呢？后面有机会再补充进来=,=。","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"mysql","slug":"mysql","permalink":"http://xupin.im/tags/mysql/"}]},{"title":"Redis学习笔记 - 集群","date":"2020-03-26T16:00:00.000Z","path":"2020/03/27/redis-cluster/","text":"之前粗浅的学习了Redis三种集群策略的主从复制和哨兵策略，现在最后这篇来学习一下Redis Cluster也就是最后一个集群策略。 1.什么是集群？集群（Cluster），Redis2.6版本（正式版本是3.0）推出的分布式解决方案，有效解决了单Master节点写操作的压力并且分布式存储数据，大大提高了负载能力。 在Redis发布3.0正式版本前，一般使用代理中间件来实现分布式集群策略。这里不展开学习了，有兴趣的小伙伴自行研究。 特点 Cluster策略是分布式部署，节点间相互协调工作。 因为对主从复制和哨兵策略都称为集群策略，所以为了防止误解在下文中提及的集群（Cluster）策略，直接用Cluster称呼。 Cluster至少要3个Master节点，并且是无中心化设计。 客户端使用Cluster，不需要连接所有节点，只需要连接Cluster中任意一个可用节点即可。 数据的分布式存储不需要指定，Cluster会自动完成。 优点 Cluster策略拥有主从复制和哨兵策略的优点。 解决了单Master节点写操作的压力。 分布式存储数据，提高了负载能力。 支持线性扩容。 缺点 部分操作命令受限，比如mset，目前只能支持同一个插槽（slot）的key进行操作。 事务机制不支持多节点操作。 不支持多数据库，即只有db0。 2.如何配置（新旧方式） 旧方式，./redis-trib.rb create –replicas {SLAVE_NUM} {IP}:{PORT} … {IP}:{PORT} 新方式，./redis-cli –cluster create –cluster-replicas {SLAVE_NUM} {IP}:{PORT} … {IP}:{PORT} redis.conf示例12345678910111213# 是否以守护进程方式运行daemonize yes/no# 是否启用Clustercluster-enabled yes/no# 节点信息配置文件，自动生成。# FILE_NAME：配置文件名cluster-cluster-config-file &#123;FILE_NAME&#125;# 节点连接超时时间# MS：超时时间（单位：Millisecond）cluster-node-timeout &#123;MS&#125; 3.工作机制 Redis节点启动，节点根据配置cluster-enabled判断是否加入Cluster。 新节点通过cluster meet {IP} {PORT}命令和其他节点感知并建立连接，节点间会通过Gossip协议PING/PONG命令来检测状态和交换信息。 Cluster计算并且分配主节点插槽数量。这个地方注意，不是插槽数量，是每个节点的插槽数量。插槽数量是固定的：16384。 插槽分配成功之后，Cluster开始服务。 4.如何感知新节点？当给某一节点发送命令cluster meet {IP} {PORT}（新节点），该节点就会尝试与新节点建立连接，具体流程： 该节点向新节点发送MEET命令。 新节点接收到MEET命令后，回复PONG命令。 该节点接收到新节点返回的PONG命令，知道新节点成功接收了自己的MEET命令。 该节点向新节点发送PING命令。 新节点接收到该节点发送的PING命令，知道该节点已经成功接收到自己返回的PONG命令。 该节点和新节点握手完成，建立连接。 最后，该节点会将新节点的信息通过Gossip协议同步给Cluster中的其他节点，让其他节点也与新节点进行握手，建立连接。 可以通过cluster nodes命令查看集群中哪些节点已经建立连接。 5.数据插槽说到插槽（slot）不得不提一下，为了能够让数据平均分配到多个节点上而采用的数据分区算法。常见的数据分区算法：范围（Range）、哈希（Hash）、一致性哈希算法和虚拟哈希槽等。 Cluster采用的虚拟哈希槽数据分区算法，所有的key根据哈希函数映射到0 ~ 16383插槽内（公式：slot = crc16(key) &amp; 16383），之前也提到过插槽也是平均分配到每个Master节点的。 虚拟哈希槽的特点 降低了节点和数据之间的耦合性，方便线性扩容&amp;动态管理节点。 节点自己管理和插槽的对应关系。 支持查询节点、插槽和key的对应关系。 可以通俗理解为，插槽是Cluster管理数据的基本单位。 6.动态管理节点假如我们原有4个Master节点（M1 … M4），但是现在因为数据增量问题临时加一个Master节点（M5），我们需要怎么操作呢？ 启动M5节点，客户端发送MEET命令让M5节点加入到Cluster中，现在M5节点没有任何插槽所以不会接受任何读写操作。 在M5节点执行cluster setslot {SLOT} importing {SOURCE_NODE_ID}命令，让M5节点准备导入{SLOT}插槽。 在拥有这个{SLOT}插槽的源节点上面执行cluster setslot {SLOT} migrating {M5_NODE_ID}，让源节点准备好迁出插槽。 这时候如果客户端操作的key存在于{SLOT}插槽中，那么这个操作由源节点处理。如果key不存在于{SLOT}插槽中，这个操作将由M5节点操作。 现在源节点的{SLOT}插槽不会创建任何新的key，需要把源节点{SLOT}插槽中的key迁移到M5节点。执行cluster getkeysinslot {SLOT} {COUNT}命令获取{SLOT}插槽中指定{COUNT}数量的key列表。 在源节点对每个key执行migrate命令，把key迁移到M5节点。 在源节点和M5节点执行cluster setslot {SLOT} NODE {M5_NODE_ID}，完成迁移。 这就是动态增加节点的流程了，可能在新的Redis版本中增加了节点迁移工具，但是核心流程应该还是这样。 7.Hash Tag学习了数据插槽，我们知道Redis在key分配到插槽的这一操作完全是自动化的，不过当我们有需求对不同的key需要放到同一插槽中的时候，这个时候要怎么操作呢？我们只需要在key中加入{}符号即可，比如： {UID_1001}:following {UID_1001}:followers 这两个key会被分配到同一插槽，原理就是当key中存在{}符号，哈希算法只会针对{}符号内的字符串。 8.插槽为什么是16384？这个值能修改吗？首先crc16算法算出的值有16bit，2^16即65536。也就是说该算法的值在0 ~ 65535之间，那么为什么作者还是选择了16384即0 ~ 16383。 很开心，对于这个疑问Redis作者给了明确的回答。前面我们知道每个节点之间会以每秒1次的频率互相发送心跳包（PING）&amp;交换信息（信息分为消息头和消息体），之前也提了交换的信息体里面主要包含节点的信息等，那么消息头的内容呢？如下：123456789101112131415161718192021222324typedef struct &#123; char sig[4]; /* Siganture \"RCmb\" (Redis Cluster message bus). */ uint32_t totlen; /* Total length of this message */ uint16_t ver; /* Protocol version, currently set to 1. */ uint16_t port; /* TCP base port number. */ uint16_t type; /* Message type */ uint16_t count; /* Only used for some kind of messages. */ uint64_t currentEpoch; /* The epoch accordingly to the sending node. */ uint64_t configEpoch; /* The config epoch if it's a master, or the last epoch advertised by its master if it is a slave. */ uint64_t offset; /* Master replication offset if node is a master or processed replication offset if node is a slave. */ char sender[CLUSTER_NAMELEN]; /* Name of the sender node */ unsigned char myslots[CLUSTER_SLOTS/8]; char slaveof[CLUSTER_NAMELEN]; char myip[NET_IP_STR_LEN]; /* Sender IP, if not all zeroed. */ char notused1[34]; /* 34 bytes reserved for future usage. */ uint16_t cport; /* Sender TCP cluster bus port */ uint16_t flags; /* Sender node flags */ unsigned char state; /* Cluster state from the POV of the sender */ unsigned char mflags[3]; /* Message flags: CLUSTERMSG_FLAG[012]_... */ union clusterMsgData data; /* message body*/&#125; clusterMsg; 其中有个myslots字段要注意，该字段使用位图，即1bit代表1slot，如果该bit为1即说明该插槽属于这个节点。那么该字段的大小为：16384 / 8bit / 1024b = 2kb。也就是消息头不考虑其他信息的情况，单是myslots就已经有2kb大小。 那么消息体呢？之前已经提到了消息体中会包含节点信息。具体是什么样的呢？消息体每次携带最少3个节点的信息，数量约为总节点数的1/10。如果节点数量越多，消息体越大。 如果插槽数量是65535，那么该字段的大小放大为：65535 / 8bit / 1024b = 8kb。这对于每秒1次频率的心跳包来讲，带宽开销是极大的。 上面说了节点越多，消息体也就越大，如果节点超过1000个也会导致网络拥堵，因为Redis作者不建议Cluster节点的数量超过1000，那么对于1000个以下的节点来说16384个插槽也就够用了。 第三个考虑是关于位图的压缩问题，我还没有搞明白~~所以这里不展开说了，先埋个坑。 这个值能修改吗？16384插槽数量是写死在Redis源代码中的，所以是不可以更改的。 附上关于作者的回答 https://github.com/antirez/redis/issues/2576 最后Cluster在故障恢复主从切换的机制（包括：主观宕机、客观宕机、投票选举、主从切换）和哨兵策略基本一致，所以在这里就不学习Cluster关于故障恢复主从切换的相关知识了。 前面提到过Gossip协议，它主要职责就是各节点间的信息交换，常用的Gossip消息可分为： ping pong meet fail 后面会专门来学习Gossip协议的知识（-,-再次埋个坑）。","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"redis","slug":"redis","permalink":"http://xupin.im/tags/redis/"}]},{"title":"Redis学习笔记 - 哨兵","date":"2020-03-25T16:00:00.000Z","path":"2020/03/26/redis-sentinel/","text":"现在这篇来学习一下Redis Sentinel即哨兵策略的相关知识。 1.什么是哨兵？哨兵（Sentinel），Redis2.6版本（正式版本是2.8，现2.6版本已被废弃）开始提供的一种集群策略，核心思想是解决了主从复制（Replication）在Master节点故障，无法自动切换Slave节点为新Master节点的问题。 特点 哨兵策略是分布式部署，节点间相互协调工作。 哨兵集群至少要3个节点。 可以把哨兵看作是一种特殊的Redis服务。 优点 哨兵策略拥有主从复制的优点。 哨兵策略解决了Master节点故障，无法自动切换Slave节点为新Master节点的问题。 缺点 Master节点写操作的压力没有得到解决。 数据存储能力还是受到单节点限制。 2.如何配置（多种方式） 启动Redis哨兵，./redis-sentinel redis-sentinel.conf 启动Redis服务时并且启动哨兵，./redis-server redis-sentinel.conf –sentinel redis-sentinel.conf示例1234567891011121314151617181920212223242526# 哨兵监控的节点。# MASTER_NAME：自定义的Master节点名称。# IP：Master节点的地址。# PORT：Master节点的端口。# QUORUM：当Master节点故障，确认Master节点odown最少的哨兵数量。sentinel monitor &#123;MASTER_NAME&#125; &#123;IP&#125; &#123;PORT&#125; &#123;QUORUM&#125;# 哨兵验证# PASS：Master节点的auth，需要注意的时哨兵不能同时为Master节点和Slave节点设置密码，所以auth需要保持一致。sentinel auth-pass &#123;MASTER_NAME&#125; &#123;PASS&#125;# 哨兵心跳Ping最大时间，如果哨兵向Master节点发送Ping超过这个时间或者回复err，那么哨兵会主观（sdown）认为该Master节点已经处于不可用状态。# MS：心跳Ping等待响应的最大时间（单位：Millisecond）。sentinel down-after-milliseconds &#123;MASTER_NAME&#125; &#123;MS&#125;# 同时同步数据的Slave节点数量# SLAVE_NUM：当Master节点故障，Slave节点通过竞选当选新Master节点，最多允许几个Slave节点开始同步新Master的数据。sentinel parallel-syncs &#123;MASTER_NAME&#125; &#123;SLAVE_NUM&#125;# 主从节点切换所需要的最大时间。# MS：主从节点切换所需要的最大时间（单位：Millisecond）。sentinel failover-timeout &#123;MASTER_NAME&#125; &#123;MS&#125;# Master节点故障调用的脚本# SCRIPT_PATH：脚本路径sentinel notification-script &#123;MASTER_NAME&#125; &#123;SCRIPT_PATH&#125; 3.工作机制 哨兵向已知节点和哨兵发送心跳包检测状态。 Master节点无效回复，哨兵判断Master节点状态：主观宕机，客观宕机。 Master节点被确定客观宕机，进行领头（Leader）哨兵选举。 准备进行主从切换的领头哨兵获取其他哨兵的授权。 授权成功，从Slave节点中选举新Master节点。 领头哨兵把新Master节点信息同步给其他哨兵，其他哨兵把新Master节点信息同步对应Slave节点。 4.心跳包每个哨兵以每秒钟1次的频率向它已知的Master节点、Slave节点和其他哨兵发送PING命令，希望得到的有效回复如下：123PING replied with +PONG.PING replied with -LOADING error.PING replied with -MASTERDOWN error. 其它任何回复或者无回复都是无效回复。 5.哨兵和节点之间的自动发现机制通过Redis的pub/sub系统实现，每个哨兵都会向自己监控的节点对应的channel：sentinel:hello发送一条消息（消息体包含自己的{IP}、{PORT}和{RUNID}以及Master节点的完整配置），每个订阅该channel的哨兵都可以消费这条消息并且能发现到其他哨兵的存在，如果某个哨兵发现自己维护的节点配置低于新接收的节点配置，则会用新的节点配置进行覆盖。 6.主观/客观宕机如果一个Master节点在收到PING命令后没有在有效时间内（down-after-milliseconds）进行有效回复，则会被标记为主观宕机（sdown，Subjectively Down）。 哨兵会获取其他哨兵检测该节点的状态，命令：12345# IP：主观宕机的Master节点地址# PORT：主观宕机的Master节点端口# CURRENT_EPOCH：哨兵的配置纪元，用于领头哨兵选举。# RUNID：可以是*和哨兵的RunID，当值是 * 代表检测节点是否主观宕机，如果是RunID则用于领头哨兵选举。SENTINEL is-master-down-byaddr &#123;IP&#125; &#123;PORT&#125; &#123;CURRENT_EPOCH&#125; &#123;RUNID&#125; 当有足够数量（{QUORUM}）的哨兵都认为该Master节点处于主观宕机状态。则该Master节点会被标记为客观宕机（odown，Objectively Down），若没有足够数量的哨兵都认为该Master节点处于主观宕机状态，则不会被标记为客观宕机，同时如果该Master节点重新返回哨兵有效回复，该Master节点主观宕机状态会被移除。 7.领头哨兵选举因为只需要一个哨兵完成主从切换，所以需要选举一个领头哨兵。 每个哨兵都会发送SENTINEL is-master-down-byaddr命令希望成为领头哨兵。收到该命令的哨兵如果没有同意过其他哨兵的同样命令，那么同意该请求，否则拒绝。 如果某一哨兵发现同意自己请求的哨兵数量并且数量大于等于{QUORUM}，那么它将成为领头哨兵。 如果选举过程中有多个哨兵当选领头哨兵，等待一段时间后选举会重新进行。 该方法基于raft算法领头选举方法实现。 8.主从切换授权当选举出领头哨兵之后并未马上进行主从切换，领头哨兵还需要获取{MAJORITY}数量的哨兵授权。1# MAJORITY：该值不可配置，Redis自行计算。公式：majority = voters / 2 + 1 如果{QUORUM} &lt; {MAJORITY}，领头哨兵需要{MAJORITY}数量的哨兵进行授权。 如果{QUORUM} &gt;= {MAJORITY}，那么领头哨兵需要{QUORUM}数量的哨兵授权才可以。 当领头哨兵获得授权之后，正式开始主从切换流程。 9.主从切换开始主从切换（failover），首先领头哨兵会选举出一个Slave节点出来作为新Master节点，该Slave节点选举参考参数： 该节点和Master节点断开的时长，如果一个Slave节点与Master节点断开连接时间已经超过down-after-milliseconds参数的10倍，再加上Master宕机的时长，该Slave节点就会被认为不适合选举为新的Master节点。 1(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state Slave节点的优先级（slave-priority），slave-priority越低优先级越高。 复制数据偏移量（复制数据最完整） RunID（最小的） 10.配置同步在领头哨兵完成主从切换之后，会在本地生成最新的Master配置然后通过pub/sub消息机制同步给其他哨兵，其他哨兵则更新对应的Master节点配置。 那么其他哨兵怎么知道这份配置是最新的呢？ 领头哨兵准备执行主从切换前，会从要切换成新Master节点的Slave节点取得一个configuration epoch，可以理解为配置版本号。如果领头哨兵主从切换失败了，那么其他哨兵会等待failover-timeout时间然后接替继续执行切换，每次接替都会重新获取一个configuration epoch，作为新的配置版本号。如果领头哨兵切换成功，那么其他哨兵会根据自己的配置版本号来更新对应Slave节点的Master节点配置。 最后为什么说哨兵最少要3个节点，举个例子： 如果是2个节点，{QUORUM}值为1，此时其中一台服务器出现客观宕机。领头哨兵需要进行主从切换，在进行主从切换前需要获取{MAJORITY}数量的哨兵同意，该{MAJORITY}参数最小的值是：2，此时领头哨兵无法进行主从切换。 https://redis.io/topics/sentinel","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"redis","slug":"redis","permalink":"http://xupin.im/tags/redis/"}]},{"title":"Redis学习笔记 - 主从复制","date":"2020-03-24T16:00:00.000Z","path":"2020/03/25/redis-replication/","text":"Redis单点配置的情况下如果服务出现故障宕机，那么服务也就处于不可用状态，假如是生产环境那么带来的后果会有很严重，所以出现了高可用方案：集群策略。 1.三种集群策略Redis提供了三种集群策略，它们分别是： 主从复制（Replication） 哨兵（Sentinel） 集群（Cluster） 这三种策略会逐一学习，本篇主要学习策略之一主从复制（Replication）。 2.主从复制的概念在主从复制（Replication）策略中，服务分为两类：Master节点、Slave节点。 特点 Master节点可以拥有多个Slave节点，但Slave节点只能服务一个Master节点。 数据复制方向只能是Master节点-&gt;Slave节点。 优点 实现了多机热数据备份，提高了面对宕机数据恢复的灾备能力。 在主从复制的基础上实现读写分离提高服务吞吐量，即：Master节点提供写服务，Slave节点提供读服务。 如果Master节点宕机可以快速切换使用Slave节点提供服务。 缺点 Master节点故障，无法自动切换Slave节点为新Master节点的问题。 Master节点写操作的压力没有得到解决。 数据存储能力还是受到单节点限制。 3.如何配置（多种方式） 在Slave节点服务器redis.conf增加配置行，slaveof {MASTER_IP} {MASTER_PORT}。 启动redis-server时，./redis-server slaveof {MASTER_IP} {MASTER_PORT}。 在redis-cli命令行界面输入，slaveof {MASTER_IP} {MASTER_PORT}。 4.工作机制 Slave节点执行slaveof命令，保存Master节点信息。 节点内部的定时任务发现主节点信息，开始尝试Socket连接主节点。 连接建立成功，Slave节点发送ping命令，期望得到pong命令响应，否则发起重连。 如果主节点有设置auth，那么进行auth验证，成功继续，失败终止。（非必须，根据Master节点是否配置auth决定） Slave节点同步Master节点全量数据集。（该操作是Master节点向Slave节点发送数据哟） Master节点持续把写命令同步Slave节点。 5.同步命令Redis主从复制数据有两个命令，sync和psync，sync是Redis2.8版本之前的同步方法，psync是Redis2.8版本以后优化sync新设计同步方法。在这会着重学习psync，也会捎带说一下为什么sync会被优化。 首先，psync需要3个参数支持： Master节点和Slave节点复制数据的偏移量。 1Master节点和Slave节点复制数据的偏移量，主要作用是通过对比复制偏移量，来判断Master节点和Slave节点数据是否一致。 Master节点复制积压缓冲区。 1psync的特性之一，用于增量数据复制和补救丢失的复制数据。 Master节点的RunID（Replication ID）。 1Redis服务启动的时，都会生成一个40位的唯一RunID。 Master节点和Slave节点复制数据的偏移量：每个参与复制数据的节点都会维护一份复制偏移量，Master节点在处理完写命令后，会把命令的字节长度进行累加，Slave节点每秒钟会向Master节点上报自己的复制偏移量，因此Master节点也会记录Slave节点的偏移量。Master节点持续把写命令同步Slave节点，Slave节点成功接收到之后也会累加自身的偏移量。查看偏移量：123&gt;info replicationmaster_repl_offset:&#123;NUM&#125; # Master节点偏移量slave_repl_offset:&#123;NUM&#125; # Slave节点偏移量 复制积压缓冲区：复制积压缓冲区是一个保存在Master节点拥有固定长度的队列，该队列先进先出，大小受repl-backlog-size参数控制（默认：1MB），查看缓冲区：12&gt;info replicationrepl_backlog_size:&#123;NUM&#125;（byte） Master节点的RunID（Replication ID）：该ID主要是用来识别Redis服务节点，因为如果使用IP+PORT方式，假如Master节点重启之后修改了RDB/AOF备份文件，此时Slave节点再基于原来的复制偏移量进行复制数据是不可靠的。查看RunID：12&gt;info serverrun_id:8d252f66c3ef89bd60a060cf8dc5cfe3d511c5e4 psync命令使用方式1psync &#123;RUNID&#125; &#123;OFFSET&#125; 6.增量/全量复制知道了命令如何使用，那么当Slave节点发送psync命令给Master节点之后会发生什么？流程分为全量复制和增量复制两种。 全量复制，如果Slave节点发送的命令是：psync ? -1 Master节点知道Slave节点要全量复制数据，返回命令则是：+fullresync {RUNID} {OFFSET}，同时Master节点会执行RDB备份并且使用复制积压缓冲区来记录此后所有的写命令。Master节点 RDB备份完成之后向Slave节点发送备份文件，同时继续缓冲写命令，在备份文件发送完毕后Master节点会向Slave节点发送缓冲区的写命令。Slave节点在收到Master节点发送的备份文件之后，会丢弃所有的旧数据，开始载入备份文件并且开始执行Master节点发送缓冲区的写命令。 值得一提的是，在Slave节点加载备份文件的时候数据处于不可靠阶段，此时可以通过参数slave-server-stale-data（yes、no）配置是否响应请求，yes响应，no则抛出“SYNC with master in progress”。 如果备份从创建到传输完毕消耗时间大于repl-timeout参数的值，Slave节点将会放弃接收备份文件并且清理已经下载的临时文件。 增量复制，Master节点会根据{RUNID}和{OFFSET}决定返回结果。 Master节点首先会检查{RUNID}是否与自身一致，如果不一致将会执行全量数据复制。如果一致会根据{OFFSET}参数在缓冲区查找，如果数据偏移量之后的数据存在缓冲区，返回命令：+continue，表示可以增量复制数据。如果返回命令+err，表示Master节点版本过低不支持psync命令，将会使用sync进行全量复制数据。 最后最后学习一下为什么sync会被优化？ 使用sync命令，在网络或者其他不可抗力因素导致Master节点和Slave节点断开连接，需要重新进行一次全量数据复制，Slave节点数据恢复成本极高。 https://redis.io/topics/replication http://try.redis.io","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"redis","slug":"redis","permalink":"http://xupin.im/tags/redis/"}]},{"title":"Mysql学习笔记 - 分片和分区","date":"2020-03-22T16:00:00.000Z","path":"2020/03/23/mysql-sharding-partition/","text":"之前在复习Mysql主从知识的同时，小伙伴考了我一个问题，分片和分区有什么差别 … 乍一听可能只是名词上的不同，但其实它们俩的确不是同一个东西。 1.什么是分片（Sharding）？我们举个例子，一张文章表。结构如下：123456789CREATE TABLE `mark`.`article` ( `id` int NOT NULL AUTO_INCREMENT, `type` varchar(20) NOT NULL COMMENT '类型', `title` varchar(255) NOT NULL COMMENT '标题', `content` longtext NOT NULL COMMENT '内容', `author` varchar(20) NOT NULL COMMENT '作者', `date` datetime NOT NULL COMMENT '日期', PRIMARY KEY (`id`)); 需求如下： 用户打开app会直接展示文章列表（类型，标题，作者，日期） 点击文章查看详情 那么这张表在数据量比较小的初期应对访问是没什么问题的。但是随着数据量日益膨胀，查询效率会越来越低，因为里面content字段非常巨大。 这时候要怎么优化呢？把content字段拆出去，因为访问最多的请求并不需要content，怎么拆呢？结构如下： 1234567891011121314151617# 文章表CREATE TABLE `mark`.`article` ( `id` int NOT NULL AUTO_INCREMENT, `type` varchar(20) NOT NULL COMMENT '类型', `title` varchar(255) NOT NULL COMMENT '标题', `c_id` int NOT NULL COMMENT '文章ID', `author` varchar(20) NOT NULL COMMENT '作者', `created_at` datetime NOT NULL COMMENT '日期', PRIMARY KEY (`id`));# 文章内容表CREATE TABLE `mark`.`article_content` ( `id` int NOT NULL AUTO_INCREMENT, `content` longtext NOT NULL COMMENT '内容', `created_at` datetime NOT NULL COMMENT '日期', PRIMARY KEY (`id`)); 2.垂直（纵向）切分上述这种情况就是分片的一种，垂直切分也被称为纵向切分，这种分片的方式不仅可以跨表也可以跨库。 优点 拆分规则简单。 数据模块清晰。 容易维护，容易定位问题。 缺点 如果分片表跨库，那么在SQL层无法进行连表查询，只能在程序层处理。 事务处理复杂度变高。 后期表结构的扩展性受限。 3.水平（横向）切分说到了垂直切分，那就不得不提一下水平切分也被称之为横向切分。同样举个例子，一张用户日志表。结构如下：12345CREATE TABLE `mark`.`user_log` ( `u_id` int NOT NULL COMMENT '用户ID', `content` longtext NOT NULL COMMENT '日志内容', `created_at` datetime NOT NULL COMMENT '创建日期'); 需求如下： 根据用户ID快速检索日志信息 情况一样，在数据量比较小的时候功能响应速度应该还可以，但是随着数据量增长的比较厉害。查询效率会呈断崖式下降。 那么这时候要怎么优化呢？我们按照用户ID去拆分表，即每个用户存储的日志固定在一张表。结构如下：12345CREATE TABLE `mark`.`user_log_&#123;NUM&#125;` ( `u_id` int NOT NULL COMMENT '用户ID', `content` longtext NOT NULL COMMENT '日志内容', `created_at` datetime NOT NULL COMMENT '创建日期'); 为了省事，后面{NUM}是个数字哈，每个用户进来我们会利用摘要算法（比如：crc32）取个固定数值，然后固定把对应的数据存储到相应的表内。 优点 不会出现跨库无法连表查询的情况。 事务处理相对简单。 很难出现扩展性受限的问题。 缺点 数据分布不平均，可能一张表10W行，另外一张100W行。 难维护，定位问题需要前置算法查询。 后期数据迁移比较麻烦。 4.什么是分区（Partition）？分片简单说了说，那么接下来要学习一下分区。分区和分片比较明显的一点是：分片多是利用程序配合来实现，分区则是数据库（不仅仅是Mysql，其它数据库也有）提供的机制。 首先，分区分为4种模式： Range List Hash Key 5.RangeRange（范围）大概的思想是将数据进行分段，比如按照日期将内购表进行拆分，分为不同的年份。 1234567891011CREATE TABLE purchase (id INT, app_id INT, name VARCHAR(50), money NUMERIC(20,4),currency VARCHAR(10),created_at DATE)PARTITION BY RANGE( YEAR(created_at) ) ( PARTITION p0 VALUES LESS THAN (1990), PARTITION p1 VALUES LESS THAN (1995), PARTITION p2 VALUES LESS THAN (2000), PARTITION p3 VALUES LESS THAN (2005), PARTITION p4 VALUES LESS THAN (2010), PARTITION p5 VALUES LESS THAN (2015));# 也可以按照金额来进行分区。# PARTITION BY RANGE( money ) (); 写入以下数据1234567891011INSERT INTO purchase(app_id,name,money,currency,created_at) VALUES(600001,'desk organiser',6.0000,'CNY','2003-10-15'),(600001,'alarm clock',12.0000,'CNY','1997-11-05'),(600002,'chair',30.0000,'CNY','2009-03-10'),(600002,'bookcase',68.0000,'CNY','1989-01-10'),(600002,'exercise bike',128.0000,'CNY','2014-05-09'),(600003,'sofa',258.0000,'CNY','1987-06-05'),(600003,'espresso maker',648.0000,'CNY','2011-11-22'),(600004,'aquarium',99.0000,'USD','1992-08-04'),(600005,'study desk',129.0000,'USD','2006-09-16'),(600006,'lava lamp',299.0000,'USD','1998-12-25'); 然后我们观察一下，可能通过肉眼看没什么变化，执行这条查看分区状态的SQL1234567891011121314151617SELECT partition_name part, partition_expression expr, table_rows FROM information_schema.PARTITIONS WHERE table_schema = SCHEMA () AND table_name = '&#123;TABLE&#125;';# 结果如下part | expr | descr | table_rowsp0 | YEAR(created_at) | 1990 | 2p1 | YEAR(created_at) | 1995 | 1p2 | YEAR(created_at) | 2000 | 2p3 | YEAR(created_at) | 2005 | 1p4 | YEAR(created_at) | 2010 | 2p5 | YEAR(created_at) | 2015 | 2 很明显，数据分别按照规则写进了分区表p0 ~ p5。 6.ListList（列表）模式，多用于对于指定字段的数值进行明确的数据拆分。 123456789CREATE TABLE purchase (id INT, app_id INT, name VARCHAR(50), money NUMERIC(20,4),currency VARCHAR(10),created_at DATE)PARTITION BY LIST( app_id ) ( PARTITION p0 VALUES IN (600001), PARTITION p1 VALUES IN (600002), PARTITION p2 VALUES IN (600003), PARTITION p3 VALUES IN (600004), PARTITION p4 VALUES IN (600005), PARTITION p5 VALUES IN (600006)); 写入同样的数据，之后执行查看分区状态的SQL。1234567part | expr | descr | table_rowsp0 | app_id | 600001 | 2p1 | app_id | 600002 | 3p2 | app_id | 600003 | 2p3 | app_id | 600004 | 1p4 | app_id | 600005 | 1p5 | app_id | 600006 | 1 7.HashHash（哈希）模式通过对一个或多个字段进行Hash计算，通过这个Hash值来进行分区（是不是感觉很像分片，其实分片的思想就是根据分区衍生而来）。 123CREATE TABLE purchase (id INT, app_id INT, name VARCHAR(50), money NUMERIC(20,4),currency VARCHAR(10),created_at DATE)PARTITION BY HASH( YEAR(created_at) )PARTITIONS 4; # 为了区别，设4个分区。 然后写入同样的数据，之后执行查看分区状态的SQL。12345part| expr | descr | table_rowsp0 | YEAR(created_at) | NULL | 1p1 | YEAR(created_at) | NULL | 3p2 | YEAR(created_at) | NULL | 3p3 | YEAR(created_at) | NULL | 3 8.KeyKey（键）模式和Hash模式极其相似，可能有一点区别就是，Hash模式下是用户自定义规则进行Hash计算，而Key模式是Mysql使用自己的函数进行Hash计算。 123CREATE TABLE purchase (id INT, app_id INT, name VARCHAR(50), money NUMERIC(20,4),currency VARCHAR(10),created_at DATE)PARTITION BY KEY( created_at )PARTITIONS 3; # 为了区别，设3个分区。 重复步骤，写入同样的数据，之后执行查看分区状态的SQL。1234part| expr | descr | table_rowsp0 | `created_at` | NULL | 2p1 | `created_at` | NULL | 3p2 | `created_at` | NULL | 5 Key模式和Hash模式在expr上面有了直观的不同表现，Hash模式是：YEAR(created_at)，而Key模式是：created_at。这就是我们前面提到的Hash计算方式的区别。 9.最后其实Mysql分区还有第5种模式，叫做Composite（复合）模式，比如：Range - Key123456789101112CREATE TABLE purchase (id INT, app_id INT, name VARCHAR(50), money NUMERIC(20,4),currency VARCHAR(10),created_at DATE)PARTITION BY RANGE( YEAR( created_at ) ) SUBPARTITION BY KEY( created_at )SUBPARTITIONS 3( PARTITION p0 VALUES LESS THAN (1990), PARTITION p1 VALUES LESS THAN (1995), PARTITION p2 VALUES LESS THAN (2000), PARTITION p3 VALUES LESS THAN (2005), PARTITION p4 VALUES LESS THAN (2010), PARTITION p5 VALUES LESS THAN (2015)); 这里就不展开Composite（复合）模式的学习了，最后通过以上的例子，可以看出分区也是有垂直分区和水平分区的说法的。 https://dev.mysql.com/doc/mysql-partitioning-excerpt/5.7/en/partitioning-management.html","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"mysql","slug":"mysql","permalink":"http://xupin.im/tags/mysql/"}]},{"title":"Mysql学习笔记 - 刷脏机制","date":"2020-03-20T16:00:00.000Z","path":"2020/03/21/mysql-checkpoint/","text":"之前学习了LRU算法和Mysql缓冲池使用的LRU变体算法，其中有个共同点就是当LRU链表写满以后如果再有新数据进来会淘汰尾部的数据，那么Mysql淘汰这些尾部数据的时候是否会进行什么操作呢？这就是我们在最后提到了一个参数Modified db pages，即脏页。 1.什么是脏页？ 脏页，这个名词很抽象从字面意思去看可能很不解，脏页是当内存中的数据页和磁盘中的数据页内容不一致时，这个数据页称之为脏页。因为从操作系统的角度来讲，自己读入的数据被外部所修改等于被污染，所以叫脏页。 当内存中的数据页和磁盘中的数据页数据一致，叫干净页。 2.脏页什么时候会刷新？ 缓冲池（buffer pool）空间不足，也就是LRU链表写满时，新数据进来时淘汰掉的尾部数据脏页。 redo log不可用时，需要强制将脏页列表中的一些数据页刷入磁盘。 Mysql在服务器负载较小时，会主动进行刷脏操作。 Mysql服务正常关闭，会刷新所有脏页。 3.什么是redo log？InnoDB中两块非常重要的日志，一个是undo log，另外一个就是我们接下来要学习的redo log。前者用来保证事务的原子性以及InnoDB的MVCC（Mutil-Version Concurrency Control），后者用来保证事务的持久性。 那么什么时候写redo log呢？当数据库对数据做修改的时候，需要把数据页从磁盘读到缓冲池中，然后在缓冲池中进行修改。但是InnoDB采用的是WAL（Write Ahead Log）策略来防止数据丢失，也就是事务提交时，先写redo log才会再去修改内存数据页。 redo log的文件名默认以ib_logfile{NUM}，存储在my.cnf中datadir目录下面，受以下两个参数控制 innodb_log_file_size，日志大小 innodb_log_files_in_group，日志个数，默认是2个。 所以redo log的大小等于innodb_log_files_in_group*innodb_log_file_size。 既然redo log会产生，那么什么时候会被覆盖呢？redo log被设计成可循环使用，当日志文件写满时那些已经被刷入磁盘中的数据就可以被覆盖啦。 WAL（Write Ahead Log），是关系数据库系统中用于提供原子性和持久性（ACID属性中的两个）的一系列技术，ARIES是WAL系列技术常用的算法，在文件系统中WAL通常称为journaling。WAL的主要思想是将元数据的实时变更操作写入日志文件中，然后在系统负载较小时再把日志刷入磁盘。主要是为了减少磁盘的IO操作，此处就不展开学习了。先Mark一下 4.CheckpointCheckpoint（检查点），在数据库中一般是用来把redo log脏页刷入磁盘的一个操作，通过LSN保存记录，作用是当发生宕机等crash情况时，再次启动时会查询Checkpoint，在该Checkpoint之后发生的事务修改恢复到磁盘。通俗来解释，就像我们玩一些游戏每过不久就会存一次档，然后如果游戏客户端不幸crash重新进入最近的一次存档即可，同理。 Checkpoint存在的目的： 缩短恢复数据时间。 缓冲池写满时，淘汰脏页刷入磁盘。 redo log写满时，进行刷脏操作。 那么怎么查看我们的检查点呢？可以使用命令show engine innodb status来查看：12345678910111213&gt;show engine innodb status\\G;---LOG---Log sequence number 1597945Log flushed up to 1597945Last Checkpoint at 1597945Max Checkpoint age 7782360Checkpoint age target 7539162Modified age 0Checkpoint age 00 pending log writes, 0 pending chkp writes8 log i/o's done, 0.42 log i/o's/second 12345Log sequence number | 当前系统LSN最大值，新的日志LSN将在此基础上生成（LSN+新日志的大小）。Log flushed up to | 当前已经写入日志文件的LSN。Last Checkpoint at | 当前已经写入Checkpoint的LSN。Max Checkpoint age | Percona的XtraDB参数，此处不过多解释。Checkpoint age target | 同上。 LSN（Log Sequence Number），LSN是日志空间中每条日志的结束点，用字节偏移量来表示。每个数据页有LSN，redo log也有LSN，Checkpoint亦有LSN。该LSN记录当前数据页最后一次修改的LSN号，用于在恢复数据时对比重做日志LSN号决定是否对该数据页进行恢复数据。可以通俗理解为，存档编号。 5.Checkpoint什么时候会触发？InnoDB存储引擎有两种Checkpoint，分别是： Sharp Checkpoint Fuzzy Checkpoint Sharp Checkpoint发生在数据库服务关闭时，将所有脏页刷入磁盘，此时innodb_fast_shutdown参数的值为1（innodb_fast_shutdown参数的值：0、1、2），这是默认机制。但是考虑到如果数据库在使用时也执行这种机制，数据库的性能会受到影响，所以Fuzzy Checkpoint刷新部分脏页的这种机制产生了。 Fuzzy Checkpoint刷新部分脏页，也分为以下几种方式： Master Thread Checkpoint FLUSH_LRU_LIST Checkpoint Dirty Page too much Checkpoint Async/Sync Flush Checkpoint Master Thread Checkpoint 主线程以每秒或者每十秒从缓冲池的脏页列表（Flush List）刷新一定比例的数据页回磁盘，这个操作过程是异步的不会阻塞线程。 FLUSH_LRU_LIST Checkpoint InnoDB需要保证LRU链表中有足够空闲页可以使用，在InnoDB1.1.x版本前，如果LRU链表写满有新的数据进来如果淘汰尾部脏页，会触发Checkpoint机制强制进行刷脏操作。该操作是阻塞线程的，所以在InnoDB1.2.x版本开始，这个操作放到Page Cleaner Thread来处理，每次刷新LRU链表脏页的数量受innodb_lru_scan_depth参数控制（默认：1024）。 Dirty Page too much Checkpoint 当LRU链表中脏页数量过多时（比例），InnoDB为了保证缓冲池中有足够多的空闲页可以使用，会强制触发Checkpoint机制进行刷脏操作。此值受innodb_max_dirty_pages_pct参数控制（默认：75%）。 Async/Sync Flush Checkpoint 为了保证redo log循环使用的可重用性，在redo log不可用时会强制触发Checkpoint刷脏操作。在InnoDB1.2.x版本以前，Async Flush Checkpoint会阻塞当前查询线程，Sync Flush Checkpoint会阻塞所有查询线程。InnoDB1.2.X之后放到单独的Page Cleaner Thread来处理。 6.最后关于Async/Sync Flush Checkpoint刷脏方式的原理有些复杂，这里先Mark一下，暂时不展开学习了。 前面说到的Percona XtraDB https://www.percona.com/doc/percona-server/8.0/scalability/innodb_io.html","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"mysql","slug":"mysql","permalink":"http://xupin.im/tags/mysql/"}]},{"title":"PHP学习笔记 - 文件分片上传","date":"2020-03-18T16:00:00.000Z","path":"2020/03/19/laravel-chunk-upload/","text":"1.什么是分片上传？ 如果我们上传的文件是一个很大的文件，那么上传的时间应该会比较久，再加上网络不稳定各种因素的影响，很容易导致传输中断。 服务端一般都会设置固定大小的接收BUFF，往往上传文件的体积是该值的几何倍数。 分片上传的原理大致可以描述为，把一个较大文件分成若干份的分片一个一个传输，服务端在接收到最后一个分片后进行合并资源。 2.前端前端使用Dropzone控件，DropzoneJS是一个开源库，提供带有图像预览的拖放文件上传并且有分割文件分片上传的机制，当然该控件不仅仅可以上传图片，经测试视频，Word等文件一样可以。 Dropzone官网提供了一个simple.html的上传demo（js、css文件路径有改动过），内容如下：1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;Dropzone simple example&lt;/title&gt;&lt;!-- DO NOT SIMPLY COPY THOSE LINES. Download the JS and CSS files from the latest release (https://github.com/enyo/dropzone/releases/latest), and host them yourself!--&gt;&lt;script src=\"./dropzone.js\"&gt;&lt;/script&gt;&lt;link rel=\"stylesheet\" href=\"./dropzone.css\"&gt;&lt;p&gt; This is the most minimal example of Dropzone. The upload in this example doesn't work, because there is no actual server to handle the file upload.&lt;/p&gt;&lt;!-- Change /upload-target to your upload address --&gt;&lt;form action=\"api/upload\" class=\"dropzone\"&gt;&lt;/form&gt; Dropzone官方提供的demo默认是没有开启分片上传的，需要修改dropzone.js123456789101112/** * Whether you want files to be uploaded in chunks to your server. This can't be * used in combination with `uploadMultiple`. * * See [chunksUploaded](#config-chunksUploaded) for the callback to finalise an upload. */chunking: false, // 修改为true,即开启分片/** * If `chunking` is `true`, then this defines the chunk size in bytes. */chunkSize: 2000000, // 默认分片大小，单位：Byte 3.后端 框架：Laravel 6.8扩展：laravel-chunk-upload代码如下：1234567891011121314151617181920212223242526 // create the file receiver$receiver = new FileReceiver(\"file\", $request, HandlerFactory::classFromRequest($request));// check if the upload is success, throw exception or return response you needif ($receiver-&gt;isUploaded() === false) &#123; throw new UploadMissingFileException();&#125;// receive the file$save = $receiver-&gt;receive();// check if the upload has finished (in chunk mode it will send smaller files)if ($save-&gt;isFinished()) &#123; // save the file and return any response you need, current example uses `move` function. If you are // not using move, you need to manually delete the file by unlink($save-&gt;getFile()-&gt;getPathname()) return $this-&gt;saveFile($save-&gt;getFile());&#125;// we are in chunk mode, lets send the current progress/** @var AbstractHandler $handler */$handler = $save-&gt;handler();return response()-&gt;json([ \"done\" =&gt; $handler-&gt;getPercentageDone(), 'status' =&gt; true]); 4.Demo https://github.com/xupin/chunk-upload-example","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"laravel","slug":"laravel","permalink":"http://xupin.im/tags/laravel/"},{"name":"dropzone","slug":"dropzone","permalink":"http://xupin.im/tags/dropzone/"}]},{"title":"Mysql学习笔记 - LRU算法","date":"2020-03-17T16:00:00.000Z","path":"2020/03/18/mysql-lru/","text":"1.什么是LRU？LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“最近使用的页面数据会在未来一段时期内仍然被使用,已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用”。 2.LRU的实现LRU算法最常见的实现是使用链表来保存数据，该链表是双向链表，然后利用先进先出的特性，最新写入的数据会最快被获取。 访问不存在的数据时，缓存数据则会写入链表的头部，链表写满时会淘汰掉尾部的缓存数据。 当缓存数据被访问时，则将该缓存数据向链表头部移动。 优点：面对频繁访问的热点数据，查询效率高 缺点：如果一次查询扫描全表，那么LRU列表会被污染 3.Mysql LRU算法有何不同？Mysql（InnoDB）的缓冲池（buffer pool）使用了LRU算法的变体，将链表分为三个部分：young、midpoint、old。链表比例(5、3)分配给young、old。其中young占据5/8，old占据3/8，此比例受参数innodb_old_blocks_pct控制。 young是链表中最近访问过的新子表。 old是链表中最近访问的旧子表。 midpoint是介于新子表 &amp; 旧子表的边界中间位置（也可以理解为旧子表的头部）。 数据库刚启动LRU链表为空时，此时会检查Free List中是否有空闲的数据页，如果有则从Free List中删除并且在LRU链表中写入相同的数据页。 访问不存在的数据页时，数据页不会直接写入链表的头部，而是写入中间位置，如果链表满了则会从旧子表尾部淘汰数据页。 当数据页被访问时，则判断访问数据页的时间是否大于设定innodb_old_blocks_time（默认：1000ms），如果大于则向链表头部移动，如果小于其位置不变。 改进优点：能够防止单次大量的全表扫描污染整个LRU链表。 4.Mysql LRU相关查询命令123456789101112131415161718192021222324252627282930&gt;show engine innodb status\\G;----------------------BUFFER POOL AND MEMORY----------------------Total memory allocated 137756672; in additional pool allocated 0Total memory allocated by read views 88Internal hash tables (constant factor + variable factor) Adaptive hash index 2217584 (2213368 + 4216) Page hash 139112 (buffer pool 0 only) Dictionary cache 593780 (554768 + 39012) File system 83536 (82672 + 864) Lock system 333248 (332872 + 376) Recovery system 0 (0 + 0)Dictionary memory allocated 39012Buffer pool size 8191Buffer pool size, bytes 134201344Free buffers 8048Database pages 143Old database pages 0Modified db pages 0Pending reads 0Pending writes: LRU 0, flush list 0, single page 0Pages made young 0, not young 00.00 youngs/s, 0.00 non-youngs/sPages read 143, created 0, written 00.00 reads/s, 0.00 creates/s, 0.00 writes/sNo buffer pool page gets since the last printoutPages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/sLRU len: 143, unzip_LRU len: 0I/O sum[0]:cur[0], unzip sum[0]:cur[0] 123456Buffer pool size | innodb_buffer_pool的大小Free buffers | 当前Free List中数据页数量Database pages | LRU链表中数据页数量Old database pages | LRU链表中旧子表数据页数量Modified db pages | LRU链表中脏页数量Pages made young 0, not young 0 | 数据页从old移至young的行为：page made young,数据页因为innodb_old_blocks_time导致没有从old移至young的行为：page not young。后面的数值是该行为发生的次数。","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"mysql","slug":"mysql","permalink":"http://xupin.im/tags/mysql/"}]},{"title":"Mysql学习笔记 - Int长度的问题","date":"2020-03-15T11:30:00.000Z","path":"2020/03/15/mysql-int-length/","text":"创建数据表的时候我们总是要考虑存储数据的字段该用哪种类型、多少长度比较合适，不过在Mysql中如果字段类型是Int，此时长度是不生效的。 1.Int类型的长度问题12345CREATE TABLE `test` ( `id` int(3) NOT NULL, `name` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci 有这样一张表，id是Int类型长度3的字段，那么理论上是不能存储长度超过3的值，比如：1INSERT INTO `test`(`id`, `name`) VALUES (1000000, &apos;name&apos;); 不过结果是意外的，这条数据可以正常写入。 2.Int类型的长度为什么不生效翻了一下Mysql的数据类型文档，发现这么一句话： 对于整数类型，M表示最大显示宽度。 对于浮点和定点类型，M是可以存储的总位数（精度）。 对于字符串类型，M是最大长度。 M的最大允许值取决于数据类型。 所以这个Int类型的“长度”其实叫宽度，也可以理解为显示长度。 3.如果存储的数据长度低于显示宽度会怎样？1INSERT INTO `test`(`id`, `name`) VALUES (1, &apos;name&apos;); 当然是可以写入的，但是好像并没有什么特别的不一样，不过我们再执行一条SQL1ALTER TABLE `test` MODIFY COLUMN `id` int(3) UNSIGNED ZEROFILL; 这次数据产生变化了，变成了这样123id | name001 | name1000000 | name 4.为什么要设计显示宽度？我也没有得出明确的答案，和小伙伴讨论这个问题~ta觉得是为了方便排序，你觉得呢？","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"mysql int length","slug":"mysql-int-length","permalink":"http://xupin.im/tags/mysql-int-length/"}]},{"title":"Go学习笔记 - 定时任务调度","date":"2020-01-18T16:00:00.000Z","path":"2020/01/19/go-console/","text":"每一个任务都需要编写一个Crontab命令，这是件很麻烦且很不友好的事情。 任务调度器允许你以代码的形式定义调度命令，并且服务器上只需要一个Crontab命令即可, 任务调度又是我们俗称的 “计划任务” 1.工欲善其事，必先利其器Github一番搜索，发现Golang有个cron包（robfig/cron）大概满足需求，于是学习一下。 2.介绍看了一遍文档，cron包支持的已经很全面了~~~不用自己造轮子了。 表达式 兼容Linux的crontab表达式（支持分钟级别）。 日志 可以很详细的记录调度的任务状态 时区 支持任务级别的时区配置 预定义计划 支持在未来指定的时间去运行 线程安全问题 该cron lib管理任务队列的slice没有做并发安全考虑，可能会出现任务竟抢行为。 3.实例1234567891011121314151617181920212223242526package mainimport ( \"fmt\" \"time\" \"github.com/robfig/cron\")func main() &#123; c := cron.New() c.AddFunc(\"* * * * * *\", test) c.Start() timer := time.NewTimer(time.Second * 10) for &#123; select &#123; case &lt;-timer.C: timer.Reset(time.Second * 10) &#125; &#125;&#125;func test() &#123; fmt.Println(\"I'm a test script!\")&#125; 12345$ go run .I'm a test script!!!I'm a test script!!!I'm a test script!!!... 4.简单封装 main.go 123456789101112131415package mainimport \"cron-example/console\"func main() &#123; quitChan := make(chan bool, 1) // console go func() &#123; console.Default() &#125;() &lt;-quitChan&#125; console.go 12345678910111213141516171819202122232425262728293031package consoleimport ( \"log\" \"time\" \"cron-example/console/commands\" \"github.com/robfig/cron\")func schedule(c *cron.Cron) &#123; c.AddFunc(\"* * * * * *\", commands.Test)&#125;func Default() &#123; log.Println(\"Starting...\") c := cron.New() c.Start() schedule(c) timer := time.NewTimer(time.Second * 10) for &#123; select &#123; case &lt;-timer.C: timer.Reset(time.Second * 10) &#125; &#125;&#125; https://github.com/xupin/go-cron-example","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"golang","slug":"golang","permalink":"http://xupin.im/tags/golang/"}]},{"title":"PHP小知识 - aliyundb SQLSetStatement is NOT supported","date":"2020-01-06T16:00:00.000Z","path":"2020/01/07/php-aliyundb/","text":"PHP项目在数据库迁移使用ADB（aliyundb）时发现这个问题，具体错误描述是：1SQLSTATE[HY000]: General error: 1815 [15022, 2020010711034801025210201503151413416] statement type: class com.alibaba.fastsql.sql.ast.statement.SQLSetStatement is NOT supported! (SQL: select * from `users`) 在排查该问题的过程中，尝试了各种方式，降版本、使用原生语句等，甚至查找ADB手册和Issue还是无法解决。 1.原因因为ADB兼容Mysql但是有些机制还是略有不同，阅读源码后发现比如：ADB就不能很好的支持本地预处理语句，这也是该异常的原因。 2.解决方案PHP PDO链接的属性值PDO::ATTR_EMULATE_PREPARES需要设置为true1PDO::ATTR_EMULATE_PREPARES =&gt; true","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"php","slug":"php","permalink":"http://xupin.im/tags/php/"}]},{"title":"Go学习笔记 - WEB框架Gin","date":"2019-12-30T16:00:00.000Z","path":"2019/12/31/go-gin/","text":"Gin 是一个用 Go (Golang) 编写的 HTTP web 框架。 它是一个类似于 martini 但拥有更好性能的 API 框架, 由于 httprouter，速度提高了近 40 倍。 1.有哪些优点 较高的性能（Golang WEB框架比对数据） 简单易用的中间件 使用了性能高可扩展的HTTP路由httprouter 社区长期有着很高的活跃度 Github星星多（Orz） …等 2.安装/更新安装1$ go get github.com/gin-gonic/gin 更新1$ go get -u github.com/gin-gonic/gin 3.Hello World1234567891011121314151617181920package mainimport ( \"github.com/gin-gonic/gin\")func main() &#123; // 框架 g := gin.Default() // 路由 g.GET(\"/t\", test) // 服务端口 g.Run(\":4000\")&#125;func test(c *gin.Context) &#123; c.String(200, \"Hallo!\")&#125; 运行1$ go run main.go 访问 http://127.0.0.1:4000/t ，页面输出Hallo!。 4.路由Gin支持的路由方式和大部分主流框架基本一致。12345678910111213func main() &#123; g := gin.Default() g.GET(\"/someGet\", getting) g.POST(\"/somePost\", posting) g.PUT(\"/somePut\", putting) g.DELETE(\"/someDelete\", deleting) g.PATCH(\"/somePatch\", patching) g.HEAD(\"/someHead\", head) g.OPTIONS(\"/someOptions\", options) g.Run(\":4000\")&#125; Gin同样也支持路由参数，不过不支持路由正则表达式。1234567891011121314151617181920func main() &#123; g := gin.Default() // 此 handler 只能匹配 /user/&#123;PARAM&#125; g.GET(\"/user/:name\", func(c *gin.Context) &#123; name := c.Param(\"name\") c.String(http.StatusOK, \"Hello %s\", name) &#125;) // 此 handler 会匹配 /user/&#123;PARAM&#125;/ 和 /user/&#123;PARAM&#125;/&#123;ACTION_2&#125; // 如果访问 /user/&#123;PARAM&#125;，在没有 \"/user/:name\" 路由的情况下，会重定向至 /user/&#123;PARAM&#125;/ 匹配当前路由。 g.GET(\"/user/:name/*action\", func(c *gin.Context) &#123; name := c.Param(\"name\") action := c.Param(\"action\") message := name + \" is \" + action c.String(http.StatusOK, message) &#125;) g.Run(\":4000\")&#125; 5.路由组Gin在路由分组上的做法和其他框架也都是一致的，再次体现了Gin简单易用极容易上手的优点。1234567891011121314151617func main() &#123; g := gin.Default() userGroup := g.Group(\"/user\") &#123; userGroup.POST(\"/login\", ctrls.Login) userGroup.POST(\"/logout\", ctrls.Logout) &#125; reportGroup := g.Group(\"/report\") &#123; reportGroup.POST(\"/revenue\", ctrls.RevenueReport) reportGroup.POST(\"/cost\", ctrls.CostReport) &#125; g.Run(\":4000\")&#125; 6.中间件Gin的中间件分为：全局，路由组，路由级别。123456789101112131415func main() &#123; g := gin.Default() // 全局中间件 g.Use(middleware) // 路由组中间件 routerGroup := g.Group(\"/user\", middleware) &#123; // 路由中间件 routerGroup.GET(\"/login\", middleware, ctrls.Login) &#125; g.Run(\":4000\")&#125; 7.参数Gin如何获取请求参数？下面的简单例子：123456789101112131415161718192021222324func main() &#123; g := gin.Default() // URL参数 // URL：/user?email=mark@im.com g.GET(\"/user\", func(c *gin.Context) &#123; // 使用 DefaultQuery 或者 Query email := c.DefaultQuery(\"email\", \"default value\") email = c.Query(\"email\") c.String(http.StatusOK, \"Hallo, %s\", email) &#125;) // POST参数 g.POST(\"/user/login\", func(c *gin.Context) &#123; // 使用 DefaultPostForm 或者 PostForm email := c.PostForm(\"email\") email = c.DefaultPostForm(\"email\", \"default value\") c.String(http.StatusOK, \"Hallo, %s\", email) &#125;) g.Run(\":4000\")&#125; 最后Gin支持的操作还有很多，比如：数据绑定、数据验证、上传文件、静态资源嵌入等。 Gin没有提供的组件也有很多，比如：ORM、Console、日志滚动分割等。 仁者见仁智者见智，Gin专注做HTTP WEB框架的核心，更多扩展需要开发人员自己去选择，组件化的设计无疑是好的。","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"golang","slug":"golang","permalink":"http://xupin.im/tags/golang/"}]},{"title":"分屏工具 - Tmux","date":"2019-12-23T16:00:00.000Z","path":"2019/12/24/tmux/","text":"Tmux是一个终端多路复用器：它使从单个屏幕创建，访问和控制多个终端成为可能。Tmux可能会与屏幕分离，并继续在后台运行，然后再重新连接。 1.Tmux的结构 Session Window Panel 即，Tmux允许访问多个会话，每个会话可以拥有多个窗口，每个窗口还可以进行划分窗格。 2.安装运行Tmux安装12345678# centos$ yum install tmux# ubuntu$ apt install tmux# mac$ brew install tmux 运行1$ tmux 效果图，如下： 底面状态栏的左侧是会话窗口相关信息，右侧是系统相关信息。 退出 1$ exit // 或者Ctrl + D 3.Tmux怎么分屏呢？首先，在Tmux中所有的快捷键都是以Ctrl + B开头的（默认是这样）。 横向划分窗格：Ctrl + B %竖向划分窗格：Ctrl + B “（英文） 窗格分好了，怎么切换窗格呢？ Ctrl + B Up/Down/Left/Right（键盘方向键）亦或自定义键。12345vim ~/.tmux.confbind h select-pane -Lbind j select-pane -Dbind k select-pane -Ubind l select-pane -R 示例图，如下： 最后本小白文仅仅简单教会入门使用Tmux，Tmux支持的操作远远不止这么简单。 比如快捷键： 新建窗口：Ctrl + B c 切换下一个窗口：Ctrl + B n 切换上一个窗口：Ctrl + B p 比如命令： 新建会话：tmux new -s 会话列表：tmux ls / tmux list-session 关于Tmux更多内容可以去官方文档了解一下 https://github.com/tmux/tmux#documentation","tags":[{"name":"tmux","slug":"tmux","permalink":"http://xupin.im/tags/tmux/"},{"name":"tools","slug":"tools","permalink":"http://xupin.im/tags/tools/"}]},{"title":"ES学习笔记 - 实现列分组统计","date":"2019-12-16T16:00:00.000Z","path":"2019/12/17/elasticsearch-group/","text":"Elasticsearch是Elastic Stack核心的分布式搜索和分析引擎。 1.背景因为业务调整采用了ES作为数据库，所以需要了解ES对于这一块的设计如何实现类似Mysql中Group By的查询的效果。 2.实现方式ES实现Group By有两种方式：TermsAgg、CompositeAgg，它们也具有不同程度的优缺点。 TermsAgg的使用方式非常粗暴，直接进行桶嵌套即可，如下: TermsAgg请求DSL语句12345678910111213141516171819&#123; \"aggregations\": &#123; \"group_app\": &#123; \"terms\": &#123; \"field\": \"app\", \"size\": 1000000 &#125;, \"aggregations\": &#123; \"group_campaign_id\": &#123; \"terms\": &#123; \"field\": \"campaign_id\", \"size\": 1000000 &#125; &#125; &#125; &#125; &#125;, \"size\": 0&#125; TermsAgg执行结果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&#123; \"took\": 142, \"timed_out\": false, \"_shards\": &#123; \"total\": 5, \"successful\": 5, \"skipped\": 0, \"failed\": 0 &#125;, \"hits\": &#123; \"total\": 175033, \"max_score\": 0.0, \"hits\": [] &#125;, \"aggregations\": &#123; \"group_app\": &#123; \"doc_count_error_upper_bound\": 0, \"sum_other_doc_count\": 0, \"buckets\": [ &#123; \"key\": \"com.aa.bb.cc\", \"doc_count\": 59929, \"group_campaign_id\": &#123; \"doc_count_error_upper_bound\": 0, \"sum_other_doc_count\": 0, \"buckets\": [ &#123; \"key\": \"Campaign_118\", \"doc_count\": 56466 &#125;, &#123; \"key\": \"Campaign_119\", \"doc_count\": 1937 &#125; ] &#125; &#125;, &#123; \"key\": \"com.dd.ee.ff\", \"doc_count\": 23231, \"group_campaign_id\": &#123; \"doc_count_error_upper_bound\": 0, \"sum_other_doc_count\": 0, \"buckets\": [ &#123; \"key\": \"Campaign_120\", \"doc_count\": 16692 &#125;, &#123; \"key\": \"Campaign_121\", \"doc_count\": 5336 &#125; ] &#125; &#125; ] &#125; &#125;&#125; CompositeAgg的使用方式略微有一些不同，下面： CompositeAgg请求DSL语句1234567891011121314151617181920212223242526&#123; \"aggregations\": &#123; \"group_by\": &#123; \"composite\": &#123; \"sources\": [ &#123; \"app\": &#123; \"terms\": &#123; \"field\": \"app\" &#125; &#125; &#125;, &#123; \"campaign_id\": &#123; \"terms\": &#123; \"field\": \"campaign_id\" &#125; &#125; &#125; ], \"size\": 1000 &#125; &#125; &#125;, \"size\": 0&#125; CompositeAgg执行结果123456789101112131415161718192021222324252627282930313233343536373839&#123; \"took\": 14, \"timed_out\": false, \"_shards\": &#123; \"total\": 5, \"successful\": 5, \"skipped\": 0, \"failed\": 0 &#125;, \"hits\": &#123; \"total\": 175033, \"max_score\": 0.0, \"hits\": [] &#125;, \"aggregations\": &#123; \"group_by\": &#123; \"after_key\": &#123; \"app\": \"com.dd.ee.ff\", \"campaign_id\": \"Campaign_120\" &#125;, \"buckets\": [ &#123; \"key\": &#123; \"app\": \"com.aa.bb.cc\", \"campaign_id\": \"Campaign_119\" &#125;, \"doc_count\": 182 &#125;, &#123; \"key\": &#123; \"app\": \"com.dd.ee.ff\", \"campaign_id\": \"Campaign_120\" &#125;, \"doc_count\": 40 &#125; ] &#125; &#125;&#125; 3.优缺点TermsAgg 优点：使用简单、没有数据量限制。 缺点：数据结构层次深、不支持分页。 CompositeAgg 优点：使用简单、数据结构清晰可读，支持分页。 缺点：有数据量限制。 最后至于ES这两种分组方式的性能方面还没有研究，后续学习笔记会更新性能上面的差异。 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-composite-aggregation.html // 附上ES官方文档","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://xupin.im/tags/elasticsearch/"}]},{"title":"Nginx - 正向/反向代理","date":"2019-12-16T16:00:00.000Z","path":"2019/12/17/nginx-proxy/","text":"代理通常用于在几台服务器之间分配负载，无缝显示来自不同网站的内容或通过除HTTP之外的协议将处理请求传递给应用服务器。 1.代理的常用场景及优点正向代理 gfw科学上网。 客户端访问鉴权。 反向代理 负载均衡。 保证内网的安全，阻止web攻击。 2.正向代理和反向代理有什么不同比较通俗的来解释：正向代理代理的是客户端，服务端不知道实际发起请求的客户端、反向代理代理的是服务端，客户端不知道实际接收请求的服务端。 一张图表示（来源：知乎wplulala）","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"nginx","slug":"nginx","permalink":"http://xupin.im/tags/nginx/"}]},{"title":"Mysql学习笔记 - 索引","date":"2019-12-16T11:30:00.000Z","path":"2019/12/16/mysql-index/","text":"索引用于快速查找具有特定列值的行。没有索引，MySQL必须从第一行开始，然后通读整个表以找到相关的行。如果表中有相关​​列的索引，MySQL可以快速确定要在数据文件中间查找的位置，而不必查看所有数据。这比顺序读取每一行要快得多。InnoDB和MyIsam只支持Btree，因此默认均是Btree，Memory和Heap支持Hash和Btree，如无明确声明，则默认索引均是Hash（包括主键）。 1.Mysql有哪些常用的索引 主键索引：数据列不允许重复，不允许为null，一个表只能有一个主键。 唯一索引：数据列不允许重复，允许为null，一个表允许多个列创建唯一索引。 普通索引：基本的索引类型，没有唯一性的限制，允许为null。 全文索引：全文索引是目前实现大数据搜索的关键技术。 2.Mysql索引的建立原则Mysql的索引遵循最左原则，在创建多列索引时，要根据业务需求，where条件中使用最频繁的一列放在最左边。 12345678910111213index(a,b,c)where a = v // 使用awhere a = v and b = v // 使用a,bwhere a = v and b = v and c = v // 使用a,b,cwhere b = v // 未使用索引where a = v and c = v // 使用awhere b = v and c = v // 未使用索引where a &gt; v // 是否使用索引，取决于查询结果集，如果全表扫描速度比索引速度快，那么不使用索引。where a like \"v%\" // 使用awhere a like \"%v%\" // 不适用索引 3.如何分析SQL语句执行性能以下是两种分析SQL性能的常用方式，explain、show profiles/show profile。 explain + SQL语句，获取SQL分析数据 select_type：对应SQL语句的查询复杂度。 table：正在访问的表。 partitions：数据所在的分区。 type：表示是否用上索引，以及索引是如何使用的，此字段决定索引的性能。ALL&lt;TYPE&lt;RANGE&lt;REF&lt;CONST possible_keys：查询条件存在的索引。 key：触发的索引。 key_len：索引字段的长度。 ref：索引访问，返回所有匹配某个单值的行。 rows：执行查询必须检查的行数，在InnoDB中此值不精确。 filtered：条件过滤出的行数的百分比。 extra：查询分析结果的额外信息，很重要 e.g. Using index、Using where … show profiles获得当前会话中执行的SQL语句，字段为：Query_ID, Duration, Query，show profile all for query {Query_ID} 4.Mysql中索引建立常见问题 为经常需要排序、分组和联合操作的字段建立索引 为常作为查询条件的字段建立索引 索引列值保证唯一性 索引建立的数量不要过多 索引列不要使用函数或者表达式 行锁依赖索引的建立 普通索引的数据重复率过高会导致索引失效 最左原则","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"mysql","slug":"mysql","permalink":"http://xupin.im/tags/mysql/"}]},{"title":"Mysql学习笔记 - 事务隔离级别","date":"2019-12-05T04:30:00.000Z","path":"2019/12/05/mysql-transaction/","text":"什么是事务？事务（Transaction）一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)，具有4个特性：原子性、一致性、隔离性、持久性，简称ACID。 那么Mysql的事务隔离级别又是什么呢？Mysql的事务隔离级别分别是4种：未提交读（Read Uncommitted）、已提交读（Read Committed）、Repeatable Read（可重复读）、Serializable（可串行化）。可以简单理解为Mysql事务的4种执行标准。 一、ACID特性 原子性（Atomicity）：一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。 一致性（Consistency）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。 隔离性（Isolation）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（Durability）：指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。 二、Mysql事务隔离级别 未提交读（Read Uncommitted），指当前事务可以读取到其他事务还未提交的数据变化，最容易带来的问题是脏读（Dirty Read），很少应用到生产环境。 已提交读（Read Committed），大部分数据库默认隔离级别但不包括Mysql，指当前事务可以读取其他事务已提交的数据变化，具有隔离性的基本标准，但是在出现交叉事务的并发操作场景中会发生两次读取的数据结果集不一致的问题，即不可重复读（Nonrepeatable Read）。 Repeatable Read（可重复读），Mysql数据库的默认隔离级别，这里顺便解释一下为什么Mysql的隔离级别不是Read Committed，因为在Mysql5.0之前日志格式只有statement这一种，这种格式导致主从复制一致性很难得到保证。这种隔离级别可以解决Nonrepeatable Read的问题，但如果也出现在交叉事务的并发操作场景会出现幻读（Phantom Read）的现象，这一行为状态是当前事务不能及时有效的读取其他事务的数据变化。 Serializable（可串行化），Mysql事务隔离最高级别，望文生义大概意思是事务的执行是有序（串行化顺序）的，不存在事务交叉执行的场景从而解决了Phantom Read的问题，但是在高并发的业务场景下请求会出现阻塞、超时、锁竟抢的问题，系统的可用性也随之降低。 收尾 https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html // Mysql事务官方文档","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"mysql","slug":"mysql","permalink":"http://xupin.im/tags/mysql/"}]},{"title":"Mysql学习笔记 - 悲观锁/乐观锁","date":"2019-12-04T11:30:00.000Z","path":"2019/12/04/pessimistic-optimistic/","text":"什么是锁？在多进程（线程）编程中为了数据的一致性、有效性，如果一资源被某进程（线程）上锁，那么在释放锁之前其他进程（线程）无法进行操作或者等待获取（上）锁。 一、悲观锁悲观锁（Pessimistic locking），顾名思义对待任何事务都持悲观态度，做任何事情都会认为会有竞抢行为~所以在进行任何操作之前都要做好万全准备（上锁）才会继续执行后续的操作。通常是利用系统提供的锁机制来实现。比如：12Mysql中的上锁命令：for update、lock in share mode等Redis中的一些操作命令：setnx、getset等（原子操作） 二、乐观锁乐观锁（Optimistic locking），和悲观锁相反对待任何事务都持乐观态度，只会在最后即将执行操作的时刻前才会进行验证。通常是通过程序配合来实现。比如：1update `orders` set hash = md5(now()) where uid = 1 and hash = &#123;lastHash&#125;; 三、优缺点悲观锁优点很鲜明，因为每次执行的操作都是独占的，数据的一致性、有效性、安全性较高。但缺点同样突出，每次操作都会产生上锁的开销，在并发请求比较密集的情况下容易阻塞或者驳回请求，甚至是造成死锁，也大大降低了系统的性能。 乐观锁优点是省去了锁的开销，能较高的提高系统吞吐量，缺点是如果出现在并发高且竟抢（冲突）行为比较多的场景下数据的一致性很难保证。","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"mysql","slug":"mysql","permalink":"http://xupin.im/tags/mysql/"}]},{"title":"Redis学习笔记 - 持久化方式","date":"2019-12-03T07:30:00.000Z","path":"2019/12/03/redis-aof-rdb/","text":"Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。 一、Redis数据存储的方式有两种12单纯的缓存模式, 整个数据的生命周期随着Redis Server的停止而消失。persistence模式, 数据会持续备份到磁盘文件。 二、Redis如何实现持久化存储？Redis提供了两种方式。12RDB(Redis DataBase)AOF(Append-only file) 三、RDBRDB的工作原理有点像运维脚本自动化定时备份数据一样，当内存中的数据到达配置的阈值就会执行DUMP操作备份数据到临时文件,备份成功结束后重命名为dump.rdb文件。123优点：fork子进程来进行备份,父进程不会进行io操作。恢复数据时的速度很快。缺点：这种方式是每隔一次才会进行备份,假如下一次备份前down机会丢失部分数据。而且如果备份的数据比较大，fork的子进程将会比较耗时，这段时间内会导致父进程阻塞。补充：因为这种每隔一段时间去备份一次的方式，类似快照。所以又叫 Snapshot。 四、AOFAOF的工作原理是讲写操作（数据）格式化追加到日志尾部，该日志文件保存了所有的历史操作数据，这一点非常类似Mysql中的bin.log。12优点：AOF这种方式可以保证较高的数据完整性，可以设置不同的策略，比如不保存，每一秒钟保存一次，或者每执行一个命令保存一次。AOF的默认策略为每一秒钟保存一次, 就算出现down机最多也就丢失1秒钟的数据, AOF备份数据因为是在后台线程执行fork子进程, 所以不会阻塞主线程。缺点：对于同样规模的数据备份的文件体积AOF要大于RDB。在备份速度上面也会慢于RDB，恢复速度同样也没有RDB快。 五、AOF备份触发机制1231. Redis服务端接收到客户端bgrewriteaof指令请求，如果当前没有在进行备份那么立即进行备份，否则等待备份完毕之后再执行备份。2. Redis conf配置了auto-aof-rewrite-percentage和auto-aof-rewrite-min-size参数，并且当前AOF文件大小server.aof_current_size大于auto-aof-rewrite-min-size，且AOF文件大小的增长率大于auto-aof-rewrite-percentage时触发备份。3. 使用config set appendonly yes命令时，调用startAppendOnly()函数触发备份。 六、那究竟使用哪种方式？12RDB 会有丢失数据风险，备份文件体积小，数据备份/恢复速度快。AOF 数据完整性更加安全，但是频繁备份需要过多的io操作性能会受到影响，备份文件体积较大，数据恢复速度慢。 首先，我们明白AOF, RDB的优缺点之后可以概括出: AOF适合热备，RDB适合冷备，Redis4.0以后允许使用aof-use-rdb-preamble配置项打开RDB-AOF混合持久化。 七、RDB/AOF混合使用的之后备份文件的变化当RDB和AOF同时开启之后121. Redis默认会优先加载AOF的配置文件。2. AOF备份文件的内容格式发生改变，备份文件前半段是RDB格式的全量数据后半段是Redis命令格式的增量数据。 八、AOF文件内容格式AOF文件内容格式是Redis通讯协议RESP（REdis Serialization Protocol）格式的命令文本存储，在此不展开学习后续会专门学习Redis的RESP协议。 最后附上Redis对于持久化方式说明的文档 https://redis.io/topics/persistence","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"redis","slug":"redis","permalink":"http://xupin.im/tags/redis/"}]},{"title":"设备通知推送 - Google FCM","date":"2017-02-27T16:00:00.000Z","path":"2017/02/28/google-msg-push/","text":"Firebase 是一个移动平台，可以帮助您快速开发高品质应用，扩大用户群，并赚取更多收益。Firebase 由多种互补功能组成，您可以自行组合和匹配这些功能以满足自己的需求。 1.获取Google推送的KEY(Google应用后台) AIzaSyCm5Vufc1FAtWE1kupGhVDRb0ThkCoWC7d // 这个是我的 2.PHP推送代码12345678910111213141516171819202122232425262728293031// 初始化环境$url = 'https://fcm.googleapis.com/fcm/send';$ch = curl_init($url);curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);curl_setopt($ch, CURLOPT_RETURNTRANSFER,1);curl_setopt($ch, CURLOPT_POST, 1);$header = array( 'Content-Type: application/json', 'Authorization: key=AIzaSyCm5Vufc1FAtWE1kupGhVDRb0ThkCoWC7d' // 这里是刚才的KEY);curl_setopt($ch, CURLOPT_HTTPHEADER, $header);// 构建消息体,json编码$content = json_encode(['notification'=&gt;[ 'title' =&gt; '这里是标题', 'body' =&gt; '这里是内容', 'icon' =&gt; '这里是后台设置的iconName'],'to'=&gt;'设备标识(Google SDK可以获取)','registration_ids'=&gt;['设备标识','设备标识'] // 如果要推送多台设备,可以使用此字段,最多支持1000台设备]);curl_setopt($ch, CURLOPT_POSTFIELDS, $content);$ret = json_decode(curl_exec($ch), true);$ret['success']; // 推送成功数$ret['failure']; // 推送失败数 3.返回值示例1234567891011121314151617&#123; \"multicast_id\": 7669649331143639654, \"success\": 3, \"failure\": 0, \"canonical_ids\": 0, \"results\": [ &#123; \"message_id\": \"0:1488360060090224%6490a2d16490a2d1\" &#125;, &#123; \"message_id\": \"0:1488360060095871%6490a2d16490a2d1\" &#125;, &#123; \"message_id\": \"0:1488360060090765%6490a2d16490a2d1\" &#125; ]&#125; 4.Google(FCM) 文档 https://firebase.google.com/docs","tags":[{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"},{"name":"google fcm","slug":"google-fcm","permalink":"http://xupin.im/tags/google-fcm/"}]},{"title":"设备通知推送 - Apple APNS","date":"2017-02-21T16:00:00.000Z","path":"2017/02/22/apple-msg-push/","text":"1.合成证书(需要两个文件.cer,.p12,苹果开发者后台获取) ios.cer,ios.p12 // 我这里的文件名 123456$ openssl x509 -in ios.cer -inform der -out ios_cer.pem$ openssl pkcs12 -nocerts -out ios_p12.pem -in ios.p12Enter Import Password: // 这里输入Apple后台文件导出时的密码MAC verified OKEnter PEM pass phrase: // 这里输入新的pem密码(用于代码中),我输入的是123456789$ cat ios_cer.pem ios_p12.pem &gt; key.pem 2.PHP推送代码12345678910111213141516171819202122232425// 初始化环境$ctx = stream_context_create();stream_context_set_option($ctx, 'ssl', 'local_cert', 'assets/key/key.pem'); // key文件的路径stream_context_set_option($ctx, 'ssl', 'passphrase', '123456789'); // 生成pem输入的密码// 建立APNS连接$fp = stream_socket_client( 'ssl://gateway.push.apple.com:2195', $err, $errstr, 60, STREAM_CLIENT_CONNECT|STREAM_CLIENT_PERSISTENT, $ctx);// 构建消息体,json编码$payload = json_encode( array( 'aps'=&gt;array('alert' =&gt; '这里是内容', 'sound' =&gt; '这里是提示声音')));// 转换二进制$msg = chr(0) . pack('n', 32) . pack('H*', '设备标识(Apple SDK可以获取)') . pack('n', strlen($payload)) . $payload;// 发送消息$result = fwrite($fp, $msg, strlen($msg));if(!$result)&#123; // 推送失败&#125;else&#123; // 推送成功&#125;fclose($fp); 3.APNS文档 https://developer.apple.com/notifications/","tags":[{"name":"apns","slug":"apns","permalink":"http://xupin.im/tags/apns/"},{"name":"develop","slug":"develop","permalink":"http://xupin.im/tags/develop/"}]},{"title":"游戏 - 源码学习","date":"1999-12-31T16:00:00.000Z","path":"2000/01/01/game-source-code/","text":"长期分享和交换各种手游源码，欢迎来撩～","tags":[{"name":"game","slug":"game","permalink":"http://xupin.im/tags/game/"}]}]